var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);

// node_modules/redux-persist/lib/integration/react.js
var require_react = __commonJS({
  "node_modules/redux-persist/lib/integration/react.js"(exports) {
    "use strict";
    exports.__esModule = !0;
    exports.PersistGate = void 0;
    var _react = _interopRequireWildcard(require("react"));
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      var newObj = {};
      if (obj != null) {
        for (var key in obj)
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};
            desc.get || desc.set ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
          }
      }
      return newObj.default = obj, newObj;
    }
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    var PersistGate2 = /* @__PURE__ */ function(_PureComponent) {
      _inherits(PersistGate3, _PureComponent);
      function PersistGate3() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, PersistGate3);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        return _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(PersistGate3)).call.apply(_getPrototypeOf2, [this].concat(args))), _defineProperty3(_assertThisInitialized(_this), "state", {
          bootstrapped: !1
        }), _defineProperty3(_assertThisInitialized(_this), "_unsubscribe", void 0), _defineProperty3(_assertThisInitialized(_this), "handlePersistorState", function() {
          var persistor2 = _this.props.persistor, _persistor$getState = persistor2.getState(), bootstrapped = _persistor$getState.bootstrapped;
          bootstrapped && (_this.props.onBeforeLift ? Promise.resolve(_this.props.onBeforeLift()).finally(function() {
            return _this.setState({
              bootstrapped: !0
            });
          }) : _this.setState({
            bootstrapped: !0
          }), _this._unsubscribe && _this._unsubscribe());
        }), _this;
      }
      return _createClass(PersistGate3, [{
        key: "componentDidMount",
        value: function() {
          this._unsubscribe = this.props.persistor.subscribe(this.handlePersistorState), this.handlePersistorState();
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          this._unsubscribe && this._unsubscribe();
        }
      }, {
        key: "render",
        value: function() {
          return typeof this.props.children == "function" && this.props.loading && console.error("redux-persist: PersistGate expects either a function child or loading prop, but not both. The loading prop will be ignored."), typeof this.props.children == "function" ? this.props.children(this.state.bootstrapped) : this.state.bootstrapped ? this.props.children : this.props.loading;
        }
      }]), PersistGate3;
    }(_react.PureComponent);
    exports.PersistGate = PersistGate2;
    _defineProperty3(PersistGate2, "defaultProps", {
      children: null,
      loading: null
    });
  }
});

// node_modules/redux-persist/lib/constants.js
var require_constants = __commonJS({
  "node_modules/redux-persist/lib/constants.js"(exports) {
    "use strict";
    exports.__esModule = !0;
    exports.DEFAULT_VERSION = exports.REGISTER = exports.PURGE = exports.PERSIST = exports.PAUSE = exports.REHYDRATE = exports.FLUSH = exports.KEY_PREFIX = void 0;
    var KEY_PREFIX2 = "persist:";
    exports.KEY_PREFIX = KEY_PREFIX2;
    var FLUSH3 = "persist/FLUSH";
    exports.FLUSH = FLUSH3;
    var REHYDRATE4 = "persist/REHYDRATE";
    exports.REHYDRATE = REHYDRATE4;
    var PAUSE3 = "persist/PAUSE";
    exports.PAUSE = PAUSE3;
    var PERSIST3 = "persist/PERSIST";
    exports.PERSIST = PERSIST3;
    var PURGE3 = "persist/PURGE";
    exports.PURGE = PURGE3;
    var REGISTER2 = "persist/REGISTER";
    exports.REGISTER = REGISTER2;
    var DEFAULT_VERSION2 = -1;
    exports.DEFAULT_VERSION = DEFAULT_VERSION2;
  }
});

// node_modules/redux-persist/lib/stateReconciler/autoMergeLevel1.js
var require_autoMergeLevel1 = __commonJS({
  "node_modules/redux-persist/lib/stateReconciler/autoMergeLevel1.js"(exports) {
    "use strict";
    exports.__esModule = !0;
    exports.default = autoMergeLevel12;
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(source, !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(source).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function autoMergeLevel12(inboundState, originalState, reducedState, _ref) {
      var debug = _ref.debug, newState = _objectSpread3({}, reducedState);
      return inboundState && _typeof2(inboundState) === "object" && Object.keys(inboundState).forEach(function(key) {
        if (key !== "_persist") {
          if (originalState[key] !== reducedState[key]) {
            debug && console.log("redux-persist/stateReconciler: sub state for key `%s` modified, skipping.", key);
            return;
          }
          newState[key] = inboundState[key];
        }
      }), debug && inboundState && _typeof2(inboundState) === "object" && console.log("redux-persist/stateReconciler: rehydrated keys '".concat(Object.keys(inboundState).join(", "), "'")), newState;
    }
  }
});

// node_modules/redux-persist/lib/createPersistoid.js
var require_createPersistoid = __commonJS({
  "node_modules/redux-persist/lib/createPersistoid.js"(exports) {
    "use strict";
    exports.__esModule = !0;
    exports.default = createPersistoid2;
    var _constants = require_constants();
    function createPersistoid2(config) {
      var blacklist2 = config.blacklist || null, whitelist = config.whitelist || null, transforms = config.transforms || [], throttle = config.throttle || 0, storageKey = "".concat(config.keyPrefix !== void 0 ? config.keyPrefix : _constants.KEY_PREFIX).concat(config.key), storage3 = config.storage, serialize;
      config.serialize === !1 ? serialize = function(x) {
        return x;
      } : typeof config.serialize == "function" ? serialize = config.serialize : serialize = defaultSerialize2;
      var writeFailHandler = config.writeFailHandler || null, lastState = {}, stagedState = {}, keysToProcess = [], timeIterator = null, writePromise = null, update = function(state) {
        Object.keys(state).forEach(function(key) {
          !passWhitelistBlacklist(key) || lastState[key] !== state[key] && keysToProcess.indexOf(key) === -1 && keysToProcess.push(key);
        }), Object.keys(lastState).forEach(function(key) {
          state[key] === void 0 && passWhitelistBlacklist(key) && keysToProcess.indexOf(key) === -1 && lastState[key] !== void 0 && keysToProcess.push(key);
        }), timeIterator === null && (timeIterator = setInterval(processNextKey, throttle)), lastState = state;
      };
      function processNextKey() {
        if (keysToProcess.length === 0) {
          timeIterator && clearInterval(timeIterator), timeIterator = null;
          return;
        }
        var key = keysToProcess.shift(), endState = transforms.reduce(function(subState, transformer) {
          return transformer.in(subState, key, lastState);
        }, lastState[key]);
        if (endState !== void 0)
          try {
            stagedState[key] = serialize(endState);
          } catch (err) {
            console.error("redux-persist/createPersistoid: error serializing state", err);
          }
        else
          delete stagedState[key];
        keysToProcess.length === 0 && writeStagedState();
      }
      function writeStagedState() {
        Object.keys(stagedState).forEach(function(key) {
          lastState[key] === void 0 && delete stagedState[key];
        }), writePromise = storage3.setItem(storageKey, serialize(stagedState)).catch(onWriteFail);
      }
      function passWhitelistBlacklist(key) {
        return !(whitelist && whitelist.indexOf(key) === -1 && key !== "_persist" || blacklist2 && blacklist2.indexOf(key) !== -1);
      }
      function onWriteFail(err) {
        writeFailHandler && writeFailHandler(err), err && console.error("Error storing data", err);
      }
      var flush = function() {
        for (; keysToProcess.length !== 0; )
          processNextKey();
        return writePromise || Promise.resolve();
      };
      return {
        update,
        flush
      };
    }
    function defaultSerialize2(data) {
      return JSON.stringify(data);
    }
  }
});

// node_modules/redux-persist/lib/getStoredState.js
var require_getStoredState = __commonJS({
  "node_modules/redux-persist/lib/getStoredState.js"(exports) {
    "use strict";
    exports.__esModule = !0;
    exports.default = getStoredState2;
    var _constants = require_constants();
    function getStoredState2(config) {
      var transforms = config.transforms || [], storageKey = "".concat(config.keyPrefix !== void 0 ? config.keyPrefix : _constants.KEY_PREFIX).concat(config.key), storage3 = config.storage, debug = config.debug, deserialize;
      return config.deserialize === !1 ? deserialize = function(x) {
        return x;
      } : typeof config.deserialize == "function" ? deserialize = config.deserialize : deserialize = defaultDeserialize2, storage3.getItem(storageKey).then(function(serialized) {
        if (serialized)
          try {
            var state = {}, rawState = deserialize(serialized);
            return Object.keys(rawState).forEach(function(key) {
              state[key] = transforms.reduceRight(function(subState, transformer) {
                return transformer.out(subState, key, rawState);
              }, deserialize(rawState[key]));
            }), state;
          } catch (err) {
            throw debug && console.log("redux-persist/getStoredState: Error restoring data ".concat(serialized), err), err;
          }
        else
          return;
      });
    }
    function defaultDeserialize2(serial) {
      return JSON.parse(serial);
    }
  }
});

// node_modules/redux-persist/lib/purgeStoredState.js
var require_purgeStoredState = __commonJS({
  "node_modules/redux-persist/lib/purgeStoredState.js"(exports) {
    "use strict";
    exports.__esModule = !0;
    exports.default = purgeStoredState2;
    var _constants = require_constants();
    function purgeStoredState2(config) {
      var storage3 = config.storage, storageKey = "".concat(config.keyPrefix !== void 0 ? config.keyPrefix : _constants.KEY_PREFIX).concat(config.key);
      return storage3.removeItem(storageKey, warnIfRemoveError2);
    }
    function warnIfRemoveError2(err) {
      err && console.error("redux-persist/purgeStoredState: Error purging data stored state", err);
    }
  }
});

// node_modules/redux-persist/lib/persistReducer.js
var require_persistReducer = __commonJS({
  "node_modules/redux-persist/lib/persistReducer.js"(exports) {
    "use strict";
    exports.__esModule = !0;
    exports.default = persistReducer2;
    var _constants = require_constants(), _autoMergeLevel = _interopRequireDefault(require_autoMergeLevel1()), _createPersistoid = _interopRequireDefault(require_createPersistoid()), _getStoredState = _interopRequireDefault(require_getStoredState()), _purgeStoredState = _interopRequireDefault(require_purgeStoredState());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(source, !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(source).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose2(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source, key) || (target[key] = source[key]));
      }
      return target;
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    var DEFAULT_TIMEOUT2 = 5e3;
    function persistReducer2(config, baseReducer) {
      if (!config)
        throw new Error("config is required for persistReducer");
      if (!config.key)
        throw new Error("key is required in persistor config");
      if (!config.storage)
        throw new Error("redux-persist: config.storage is required. Try using one of the provided storage engines `import storage from 'redux-persist/lib/storage'`");
      var version = config.version !== void 0 ? config.version : _constants.DEFAULT_VERSION, debug = config.debug || !1, stateReconciler = config.stateReconciler === void 0 ? _autoMergeLevel.default : config.stateReconciler, getStoredState2 = config.getStoredState || _getStoredState.default, timeout = config.timeout !== void 0 ? config.timeout : DEFAULT_TIMEOUT2, _persistoid = null, _purge = !1, _paused = !0, conditionalUpdate = function(state) {
        return state._persist.rehydrated && _persistoid && !_paused && _persistoid.update(state), state;
      };
      return function(state, action8) {
        var _ref = state || {}, _persist = _ref._persist, rest = _objectWithoutProperties2(_ref, ["_persist"]), restState = rest;
        if (action8.type === _constants.PERSIST) {
          var _sealed = !1, _rehydrate = function(payload, err) {
            _sealed && console.error('redux-persist: rehydrate for "'.concat(config.key, '" called after timeout.'), payload, err), _sealed || (action8.rehydrate(config.key, payload, err), _sealed = !0);
          };
          if (timeout && setTimeout(function() {
            !_sealed && _rehydrate(void 0, new Error('redux-persist: persist timed out for persist key "'.concat(config.key, '"')));
          }, timeout), _paused = !1, _persistoid || (_persistoid = (0, _createPersistoid.default)(config)), _persist)
            return _objectSpread3({}, baseReducer(restState, action8), {
              _persist
            });
          if (typeof action8.rehydrate != "function" || typeof action8.register != "function")
            throw new Error("redux-persist: either rehydrate or register is not a function on the PERSIST action. This can happen if the action is being replayed. This is an unexplored use case, please open an issue and we will figure out a resolution.");
          return action8.register(config.key), getStoredState2(config).then(function(restoredState) {
            var migrate = config.migrate || function(s, v) {
              return Promise.resolve(s);
            };
            migrate(restoredState, version).then(function(migratedState) {
              _rehydrate(migratedState);
            }, function(migrateErr) {
              migrateErr && console.error("redux-persist: migration error", migrateErr), _rehydrate(void 0, migrateErr);
            });
          }, function(err) {
            _rehydrate(void 0, err);
          }), _objectSpread3({}, baseReducer(restState, action8), {
            _persist: {
              version,
              rehydrated: !1
            }
          });
        } else {
          if (action8.type === _constants.PURGE)
            return _purge = !0, action8.result((0, _purgeStoredState.default)(config)), _objectSpread3({}, baseReducer(restState, action8), {
              _persist
            });
          if (action8.type === _constants.FLUSH)
            return action8.result(_persistoid && _persistoid.flush()), _objectSpread3({}, baseReducer(restState, action8), {
              _persist
            });
          if (action8.type === _constants.PAUSE)
            _paused = !0;
          else if (action8.type === _constants.REHYDRATE) {
            if (_purge)
              return _objectSpread3({}, restState, {
                _persist: _objectSpread3({}, _persist, {
                  rehydrated: !0
                })
              });
            if (action8.key === config.key) {
              var reducedState = baseReducer(restState, action8), inboundState = action8.payload, reconciledRest = stateReconciler !== !1 && inboundState !== void 0 ? stateReconciler(inboundState, state, reducedState, config) : reducedState, _newState = _objectSpread3({}, reconciledRest, {
                _persist: _objectSpread3({}, _persist, {
                  rehydrated: !0
                })
              });
              return conditionalUpdate(_newState);
            }
          }
        }
        if (!_persist)
          return baseReducer(state, action8);
        var newState = baseReducer(restState, action8);
        return newState === restState ? state : conditionalUpdate(_objectSpread3({}, newState, {
          _persist
        }));
      };
    }
  }
});

// node_modules/redux-persist/lib/stateReconciler/autoMergeLevel2.js
var require_autoMergeLevel2 = __commonJS({
  "node_modules/redux-persist/lib/stateReconciler/autoMergeLevel2.js"(exports) {
    "use strict";
    exports.__esModule = !0;
    exports.default = autoMergeLevel22;
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(source, !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(source).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function autoMergeLevel22(inboundState, originalState, reducedState, _ref) {
      var debug = _ref.debug, newState = _objectSpread3({}, reducedState);
      return inboundState && _typeof2(inboundState) === "object" && Object.keys(inboundState).forEach(function(key) {
        if (key !== "_persist") {
          if (originalState[key] !== reducedState[key]) {
            debug && console.log("redux-persist/stateReconciler: sub state for key `%s` modified, skipping.", key);
            return;
          }
          if (isPlainEnoughObject(reducedState[key])) {
            newState[key] = _objectSpread3({}, newState[key], {}, inboundState[key]);
            return;
          }
          newState[key] = inboundState[key];
        }
      }), debug && inboundState && _typeof2(inboundState) === "object" && console.log("redux-persist/stateReconciler: rehydrated keys '".concat(Object.keys(inboundState).join(", "), "'")), newState;
    }
    function isPlainEnoughObject(o) {
      return o !== null && !Array.isArray(o) && _typeof2(o) === "object";
    }
  }
});

// node_modules/redux-persist/lib/persistCombineReducers.js
var require_persistCombineReducers = __commonJS({
  "node_modules/redux-persist/lib/persistCombineReducers.js"(exports) {
    "use strict";
    exports.__esModule = !0;
    exports.default = persistCombineReducers;
    var _redux = require("redux"), _persistReducer = _interopRequireDefault(require_persistReducer()), _autoMergeLevel = _interopRequireDefault(require_autoMergeLevel2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function persistCombineReducers(config, reducers) {
      return config.stateReconciler = config.stateReconciler === void 0 ? _autoMergeLevel.default : config.stateReconciler, (0, _persistReducer.default)(config, (0, _redux.combineReducers)(reducers));
    }
  }
});

// node_modules/redux-persist/lib/persistStore.js
var require_persistStore = __commonJS({
  "node_modules/redux-persist/lib/persistStore.js"(exports) {
    "use strict";
    exports.__esModule = !0;
    exports.default = persistStore2;
    var _redux = require("redux"), _constants = require_constants();
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }
    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]")
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
          arr2[i] = arr[i];
        return arr2;
      }
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(source, !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(source).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    var initialState5 = {
      registry: [],
      bootstrapped: !1
    }, persistorReducer = function() {
      var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : initialState5, action8 = arguments.length > 1 ? arguments[1] : void 0;
      switch (action8.type) {
        case _constants.REGISTER:
          return _objectSpread3({}, state, {
            registry: [].concat(_toConsumableArray(state.registry), [action8.key])
          });
        case _constants.REHYDRATE:
          var firstIndex = state.registry.indexOf(action8.key), registry = _toConsumableArray(state.registry);
          return registry.splice(firstIndex, 1), _objectSpread3({}, state, {
            registry,
            bootstrapped: registry.length === 0
          });
        default:
          return state;
      }
    };
    function persistStore2(store2, options, cb) {
      var optionsToTest = options || {}, bannedKeys = ["blacklist", "whitelist", "transforms", "storage", "keyPrefix", "migrate"];
      bannedKeys.forEach(function(k) {
        optionsToTest[k] && console.error('redux-persist: invalid option passed to persistStore: "'.concat(k, '". You may be incorrectly passing persistConfig into persistStore, whereas it should be passed into persistReducer.'));
      });
      var boostrappedCb = cb || !1, _pStore = (0, _redux.createStore)(persistorReducer, initialState5, options && options.enhancer ? options.enhancer : void 0), register2 = function(key) {
        _pStore.dispatch({
          type: _constants.REGISTER,
          key
        });
      }, rehydrate = function(key, payload, err) {
        var rehydrateAction = {
          type: _constants.REHYDRATE,
          payload,
          err,
          key
        };
        store2.dispatch(rehydrateAction), _pStore.dispatch(rehydrateAction), boostrappedCb && persistor2.getState().bootstrapped && (boostrappedCb(), boostrappedCb = !1);
      }, persistor2 = _objectSpread3({}, _pStore, {
        purge: function() {
          var results = [];
          return store2.dispatch({
            type: _constants.PURGE,
            result: function(purgeResult) {
              results.push(purgeResult);
            }
          }), Promise.all(results);
        },
        flush: function() {
          var results = [];
          return store2.dispatch({
            type: _constants.FLUSH,
            result: function(flushResult) {
              results.push(flushResult);
            }
          }), Promise.all(results);
        },
        pause: function() {
          store2.dispatch({
            type: _constants.PAUSE
          });
        },
        persist: function() {
          store2.dispatch({
            type: _constants.PERSIST,
            register: register2,
            rehydrate
          });
        }
      });
      return options && options.manualPersist || persistor2.persist(), persistor2;
    }
  }
});

// node_modules/redux-persist/lib/createMigrate.js
var require_createMigrate = __commonJS({
  "node_modules/redux-persist/lib/createMigrate.js"(exports) {
    "use strict";
    exports.__esModule = !0;
    exports.default = createMigrate;
    var _constants = require_constants();
    function createMigrate(migrations, config) {
      var _ref = config || {}, debug = _ref.debug;
      return function(state, currentVersion) {
        if (!state)
          return debug && console.log("redux-persist: no inbound state, skipping migration"), Promise.resolve(void 0);
        var inboundVersion = state._persist && state._persist.version !== void 0 ? state._persist.version : _constants.DEFAULT_VERSION;
        if (inboundVersion === currentVersion)
          return debug && console.log("redux-persist: versions match, noop migration"), Promise.resolve(state);
        if (inboundVersion > currentVersion)
          return console.error("redux-persist: downgrading version is not supported"), Promise.resolve(state);
        var migrationKeys = Object.keys(migrations).map(function(ver) {
          return parseInt(ver);
        }).filter(function(key) {
          return currentVersion >= key && key > inboundVersion;
        }).sort(function(a, b) {
          return a - b;
        });
        debug && console.log("redux-persist: migrationKeys", migrationKeys);
        try {
          var migratedState = migrationKeys.reduce(function(state2, versionKey) {
            return debug && console.log("redux-persist: running migration for versionKey", versionKey), migrations[versionKey](state2);
          }, state);
          return Promise.resolve(migratedState);
        } catch (err) {
          return Promise.reject(err);
        }
      };
    }
  }
});

// node_modules/redux-persist/lib/createTransform.js
var require_createTransform = __commonJS({
  "node_modules/redux-persist/lib/createTransform.js"(exports) {
    "use strict";
    exports.__esModule = !0;
    exports.default = createTransform;
    function createTransform(inbound, outbound) {
      var config = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, whitelist = config.whitelist || null, blacklist2 = config.blacklist || null;
      function whitelistBlacklistCheck(key) {
        return !!(whitelist && whitelist.indexOf(key) === -1 || blacklist2 && blacklist2.indexOf(key) !== -1);
      }
      return {
        in: function(state, key, fullState) {
          return !whitelistBlacklistCheck(key) && inbound ? inbound(state, key, fullState) : state;
        },
        out: function(state, key, fullState) {
          return !whitelistBlacklistCheck(key) && outbound ? outbound(state, key, fullState) : state;
        }
      };
    }
  }
});

// node_modules/redux-persist/lib/index.js
var require_lib = __commonJS({
  "node_modules/redux-persist/lib/index.js"(exports) {
    "use strict";
    exports.__esModule = !0;
    var _exportNames = {
      persistReducer: !0,
      persistCombineReducers: !0,
      persistStore: !0,
      createMigrate: !0,
      createTransform: !0,
      getStoredState: !0,
      createPersistoid: !0,
      purgeStoredState: !0
    };
    exports.purgeStoredState = exports.createPersistoid = exports.getStoredState = exports.createTransform = exports.createMigrate = exports.persistStore = exports.persistCombineReducers = exports.persistReducer = void 0;
    var _persistReducer = _interopRequireDefault(require_persistReducer());
    exports.persistReducer = _persistReducer.default;
    var _persistCombineReducers = _interopRequireDefault(require_persistCombineReducers());
    exports.persistCombineReducers = _persistCombineReducers.default;
    var _persistStore = _interopRequireDefault(require_persistStore());
    exports.persistStore = _persistStore.default;
    var _createMigrate = _interopRequireDefault(require_createMigrate());
    exports.createMigrate = _createMigrate.default;
    var _createTransform = _interopRequireDefault(require_createTransform());
    exports.createTransform = _createTransform.default;
    var _getStoredState = _interopRequireDefault(require_getStoredState());
    exports.getStoredState = _getStoredState.default;
    var _createPersistoid = _interopRequireDefault(require_createPersistoid());
    exports.createPersistoid = _createPersistoid.default;
    var _purgeStoredState = _interopRequireDefault(require_purgeStoredState());
    exports.purgeStoredState = _purgeStoredState.default;
    var _constants = require_constants();
    Object.keys(_constants).forEach(function(key) {
      key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(_exportNames, key) || (exports[key] = _constants[key]);
    });
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// node_modules/redux-persist/lib/storage/getStorage.js
var require_getStorage = __commonJS({
  "node_modules/redux-persist/lib/storage/getStorage.js"(exports) {
    "use strict";
    exports.__esModule = !0;
    exports.default = getStorage;
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    function noop() {
    }
    var noopStorage = {
      getItem: noop,
      setItem: noop,
      removeItem: noop
    };
    function hasStorage(storageType) {
      if ((typeof self > "u" ? "undefined" : _typeof2(self)) !== "object" || !(storageType in self))
        return !1;
      try {
        var storage3 = self[storageType], testKey = "redux-persist ".concat(storageType, " test");
        storage3.setItem(testKey, "test"), storage3.getItem(testKey), storage3.removeItem(testKey);
      } catch {
        return console.warn("redux-persist ".concat(storageType, " test failed, persistence will be disabled.")), !1;
      }
      return !0;
    }
    function getStorage(type) {
      var storageType = "".concat(type, "Storage");
      return hasStorage(storageType) ? self[storageType] : (console.error("redux-persist failed to create sync storage. falling back to noop storage."), noopStorage);
    }
  }
});

// node_modules/redux-persist/lib/storage/createWebStorage.js
var require_createWebStorage = __commonJS({
  "node_modules/redux-persist/lib/storage/createWebStorage.js"(exports) {
    "use strict";
    exports.__esModule = !0;
    exports.default = createWebStorage2;
    var _getStorage = _interopRequireDefault(require_getStorage());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function createWebStorage2(type) {
      var storage3 = (0, _getStorage.default)(type);
      return {
        getItem: function(key) {
          return new Promise(function(resolve, reject) {
            resolve(storage3.getItem(key));
          });
        },
        setItem: function(key, item) {
          return new Promise(function(resolve, reject) {
            resolve(storage3.setItem(key, item));
          });
        },
        removeItem: function(key) {
          return new Promise(function(resolve, reject) {
            resolve(storage3.removeItem(key));
          });
        }
      };
    }
  }
});

// node_modules/recharts/lib/util/types.js
var require_types = __commonJS({
  "node_modules/recharts/lib/util/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.adaptEventsOfChild = exports.adaptEventHandlers = exports.filterProps = void 0;
    var _isObject2 = _interopRequireDefault(require("lodash/isObject")), _react = require("react");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    var SVGContainerPropKeys = ["viewBox", "children"], SVGElementPropKeys = ["aria-activedescendant", "aria-atomic", "aria-autocomplete", "aria-busy", "aria-checked", "aria-colcount", "aria-colindex", "aria-colspan", "aria-controls", "aria-current", "aria-describedby", "aria-details", "aria-disabled", "aria-errormessage", "aria-expanded", "aria-flowto", "aria-haspopup", "aria-hidden", "aria-invalid", "aria-keyshortcuts", "aria-label", "aria-labelledby", "aria-level", "aria-live", "aria-modal", "aria-multiline", "aria-multiselectable", "aria-orientation", "aria-owns", "aria-placeholder", "aria-posinset", "aria-pressed", "aria-readonly", "aria-relevant", "aria-required", "aria-roledescription", "aria-rowcount", "aria-rowindex", "aria-rowspan", "aria-selected", "aria-setsize", "aria-sort", "aria-valuemax", "aria-valuemin", "aria-valuenow", "aria-valuetext", "className", "color", "height", "id", "lang", "max", "media", "method", "min", "name", "style", "target", "type", "width", "role", "tabIndex", "accentHeight", "accumulate", "additive", "alignmentBaseline", "allowReorder", "alphabetic", "amplitude", "arabicForm", "ascent", "attributeName", "attributeType", "autoReverse", "azimuth", "baseFrequency", "baselineShift", "baseProfile", "bbox", "begin", "bias", "by", "calcMode", "capHeight", "clip", "clipPath", "clipPathUnits", "clipRule", "colorInterpolation", "colorInterpolationFilters", "colorProfile", "colorRendering", "contentScriptType", "contentStyleType", "cursor", "cx", "cy", "d", "decelerate", "descent", "diffuseConstant", "direction", "display", "divisor", "dominantBaseline", "dur", "dx", "dy", "edgeMode", "elevation", "enableBackground", "end", "exponent", "externalResourcesRequired", "fill", "fillOpacity", "fillRule", "filter", "filterRes", "filterUnits", "floodColor", "floodOpacity", "focusable", "fontFamily", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontWeight", "format", "from", "fx", "fy", "g1", "g2", "glyphName", "glyphOrientationHorizontal", "glyphOrientationVertical", "glyphRef", "gradientTransform", "gradientUnits", "hanging", "horizAdvX", "horizOriginX", "href", "ideographic", "imageRendering", "in2", "in", "intercept", "k1", "k2", "k3", "k4", "k", "kernelMatrix", "kernelUnitLength", "kerning", "keyPoints", "keySplines", "keyTimes", "lengthAdjust", "letterSpacing", "lightingColor", "limitingConeAngle", "local", "markerEnd", "markerHeight", "markerMid", "markerStart", "markerUnits", "markerWidth", "mask", "maskContentUnits", "maskUnits", "mathematical", "mode", "numOctaves", "offset", "opacity", "operator", "order", "orient", "orientation", "origin", "overflow", "overlinePosition", "overlineThickness", "paintOrder", "panose1", "pathLength", "patternContentUnits", "patternTransform", "patternUnits", "pointerEvents", "points", "pointsAtX", "pointsAtY", "pointsAtZ", "preserveAlpha", "preserveAspectRatio", "primitiveUnits", "r", "radius", "refX", "refY", "renderingIntent", "repeatCount", "repeatDur", "requiredExtensions", "requiredFeatures", "restart", "result", "rotate", "rx", "ry", "seed", "shapeRendering", "slope", "spacing", "specularConstant", "specularExponent", "speed", "spreadMethod", "startOffset", "stdDeviation", "stemh", "stemv", "stitchTiles", "stopColor", "stopOpacity", "strikethroughPosition", "strikethroughThickness", "string", "stroke", "strokeDasharray", "strokeDashoffset", "strokeLinecap", "strokeLinejoin", "strokeMiterlimit", "strokeOpacity", "strokeWidth", "surfaceScale", "systemLanguage", "tableValues", "targetX", "targetY", "textAnchor", "textDecoration", "textLength", "textRendering", "to", "transform", "u1", "u2", "underlinePosition", "underlineThickness", "unicode", "unicodeBidi", "unicodeRange", "unitsPerEm", "vAlphabetic", "values", "vectorEffect", "version", "vertAdvY", "vertOriginX", "vertOriginY", "vHanging", "vIdeographic", "viewTarget", "visibility", "vMathematical", "widths", "wordSpacing", "writingMode", "x1", "x2", "x", "xChannelSelector", "xHeight", "xlinkActuate", "xlinkArcrole", "xlinkHref", "xlinkRole", "xlinkShow", "xlinkTitle", "xlinkType", "xmlBase", "xmlLang", "xmlns", "xmlnsXlink", "xmlSpace", "y1", "y2", "y", "yChannelSelector", "z", "zoomAndPan", "ref", "key", "angle"], EventKeys = ["dangerouslySetInnerHTML", "onCopy", "onCopyCapture", "onCut", "onCutCapture", "onPaste", "onPasteCapture", "onCompositionEnd", "onCompositionEndCapture", "onCompositionStart", "onCompositionStartCapture", "onCompositionUpdate", "onCompositionUpdateCapture", "onFocus", "onFocusCapture", "onBlur", "onBlurCapture", "onChange", "onChangeCapture", "onBeforeInput", "onBeforeInputCapture", "onInput", "onInputCapture", "onReset", "onResetCapture", "onSubmit", "onSubmitCapture", "onInvalid", "onInvalidCapture", "onLoad", "onLoadCapture", "onError", "onErrorCapture", "onKeyDown", "onKeyDownCapture", "onKeyPress", "onKeyPressCapture", "onKeyUp", "onKeyUpCapture", "onAbort", "onAbortCapture", "onCanPlay", "onCanPlayCapture", "onCanPlayThrough", "onCanPlayThroughCapture", "onDurationChange", "onDurationChangeCapture", "onEmptied", "onEmptiedCapture", "onEncrypted", "onEncryptedCapture", "onEnded", "onEndedCapture", "onLoadedData", "onLoadedDataCapture", "onLoadedMetadata", "onLoadedMetadataCapture", "onLoadStart", "onLoadStartCapture", "onPause", "onPauseCapture", "onPlay", "onPlayCapture", "onPlaying", "onPlayingCapture", "onProgress", "onProgressCapture", "onRateChange", "onRateChangeCapture", "onSeeked", "onSeekedCapture", "onSeeking", "onSeekingCapture", "onStalled", "onStalledCapture", "onSuspend", "onSuspendCapture", "onTimeUpdate", "onTimeUpdateCapture", "onVolumeChange", "onVolumeChangeCapture", "onWaiting", "onWaitingCapture", "onAuxClick", "onAuxClickCapture", "onClick", "onClickCapture", "onContextMenu", "onContextMenuCapture", "onDoubleClick", "onDoubleClickCapture", "onDrag", "onDragCapture", "onDragEnd", "onDragEndCapture", "onDragEnter", "onDragEnterCapture", "onDragExit", "onDragExitCapture", "onDragLeave", "onDragLeaveCapture", "onDragOver", "onDragOverCapture", "onDragStart", "onDragStartCapture", "onDrop", "onDropCapture", "onMouseDown", "onMouseDownCapture", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseMoveCapture", "onMouseOut", "onMouseOutCapture", "onMouseOver", "onMouseOverCapture", "onMouseUp", "onMouseUpCapture", "onSelect", "onSelectCapture", "onTouchCancel", "onTouchCancelCapture", "onTouchEnd", "onTouchEndCapture", "onTouchMove", "onTouchMoveCapture", "onTouchStart", "onTouchStartCapture", "onPointerDown", "onPointerDownCapture", "onPointerMove", "onPointerMoveCapture", "onPointerUp", "onPointerUpCapture", "onPointerCancel", "onPointerCancelCapture", "onPointerEnter", "onPointerEnterCapture", "onPointerLeave", "onPointerLeaveCapture", "onPointerOver", "onPointerOverCapture", "onPointerOut", "onPointerOutCapture", "onGotPointerCapture", "onGotPointerCaptureCapture", "onLostPointerCapture", "onLostPointerCaptureCapture", "onScroll", "onScrollCapture", "onWheel", "onWheelCapture", "onAnimationStart", "onAnimationStartCapture", "onAnimationEnd", "onAnimationEndCapture", "onAnimationIteration", "onAnimationIterationCapture", "onTransitionEnd", "onTransitionEndCapture"], filterProps = function(props, includeEvents, isSvg) {
      if (!props || typeof props == "function" || typeof props == "boolean")
        return null;
      var inputProps = props;
      if (/* @__PURE__ */ (0, _react.isValidElement)(props) && (inputProps = props.props), !(0, _isObject2.default)(inputProps))
        return null;
      var out = {};
      return Object.keys(inputProps).forEach(function(key) {
        (SVGElementPropKeys.includes(key) || isSvg && SVGContainerPropKeys.includes(key) || includeEvents && EventKeys.includes(key)) && (out[key] = inputProps[key]);
      }), out;
    };
    exports.filterProps = filterProps;
    var adaptEventHandlers = function(props, newHandler) {
      if (!props || typeof props == "function" || typeof props == "boolean")
        return null;
      var inputProps = props;
      if (/* @__PURE__ */ (0, _react.isValidElement)(props) && (inputProps = props.props), !(0, _isObject2.default)(inputProps))
        return null;
      var out = {};
      return Object.keys(inputProps).forEach(function(key) {
        EventKeys.includes(key) && (out[key] = newHandler || function(e) {
          return inputProps[key](inputProps, e);
        });
      }), out;
    };
    exports.adaptEventHandlers = adaptEventHandlers;
    var getEventHandlerOfChild = function(originalHandler, data, index) {
      return function(e) {
        return originalHandler(data, index, e), null;
      };
    }, adaptEventsOfChild = function(props, data, index) {
      if (!(0, _isObject2.default)(props) || _typeof2(props) !== "object")
        return null;
      var out = null;
      return Object.keys(props).forEach(function(key) {
        var item = props[key];
        EventKeys.includes(key) && typeof item == "function" && (out || (out = {}), out[key] = getEventHandlerOfChild(item, data, index));
      }), out;
    };
    exports.adaptEventsOfChild = adaptEventsOfChild;
  }
});

// node_modules/recharts/lib/container/Surface.js
var require_Surface = __commonJS({
  "node_modules/recharts/lib/container/Surface.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Surface = Surface;
    var _react = _interopRequireDefault(require("react")), _classnames = _interopRequireDefault(require("classnames")), _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose2(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source, key) || (target[key] = source[key]));
      }
      return target;
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    function Surface(props) {
      var children = props.children, width = props.width, height = props.height, viewBox = props.viewBox, className = props.className, style = props.style, others = _objectWithoutProperties2(props, ["children", "width", "height", "viewBox", "className", "style"]), svgView = viewBox || {
        width,
        height,
        x: 0,
        y: 0
      }, layerClass = (0, _classnames.default)("recharts-surface", className);
      return /* @__PURE__ */ _react.default.createElement("svg", _extends({}, (0, _types.filterProps)(others, !0, !0), {
        className: layerClass,
        width,
        height,
        style,
        viewBox: "".concat(svgView.x, " ").concat(svgView.y, " ").concat(svgView.width, " ").concat(svgView.height),
        version: "1.1"
      }), /* @__PURE__ */ _react.default.createElement("title", null, props.title), /* @__PURE__ */ _react.default.createElement("desc", null, props.desc), children);
    }
  }
});

// node_modules/recharts/lib/container/Layer.js
var require_Layer = __commonJS({
  "node_modules/recharts/lib/container/Layer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Layer = void 0;
    var _react = _interopRequireDefault(require("react")), _classnames = _interopRequireDefault(require("classnames")), _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose2(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source, key) || (target[key] = source[key]));
      }
      return target;
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    var Layer4 = /* @__PURE__ */ _react.default.forwardRef(function(props, ref) {
      var children = props.children, className = props.className, others = _objectWithoutProperties2(props, ["children", "className"]), layerClass = (0, _classnames.default)("recharts-layer", className);
      return /* @__PURE__ */ _react.default.createElement("g", _extends({
        className: layerClass
      }, (0, _types.filterProps)(others, !0), {
        ref
      }), children);
    });
    exports.Layer = Layer4;
  }
});

// node_modules/d3-shape/dist/d3-shape.js
var require_d3_shape = __commonJS({
  "node_modules/d3-shape/dist/d3-shape.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports == "object" && typeof module2 < "u" ? factory(exports, require("d3-path")) : typeof define == "function" && define.amd ? define(["exports", "d3-path"], factory) : (global2 = typeof globalThis < "u" ? globalThis : global2 || self, factory(global2.d3 = global2.d3 || {}, global2.d3));
    })(exports, function(exports2, d3Path) {
      "use strict";
      function constant(x2) {
        return function() {
          return x2;
        };
      }
      var abs = Math.abs, atan2 = Math.atan2, cos = Math.cos, max = Math.max, min = Math.min, sin = Math.sin, sqrt = Math.sqrt, epsilon = 1e-12, pi = Math.PI, halfPi = pi / 2, tau = 2 * pi;
      function acos(x2) {
        return x2 > 1 ? 0 : x2 < -1 ? pi : Math.acos(x2);
      }
      function asin(x2) {
        return x2 >= 1 ? halfPi : x2 <= -1 ? -halfPi : Math.asin(x2);
      }
      function arcInnerRadius(d) {
        return d.innerRadius;
      }
      function arcOuterRadius(d) {
        return d.outerRadius;
      }
      function arcStartAngle(d) {
        return d.startAngle;
      }
      function arcEndAngle(d) {
        return d.endAngle;
      }
      function arcPadAngle(d) {
        return d && d.padAngle;
      }
      function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
        var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2, t = y32 * x10 - x32 * y10;
        if (!(t * t < epsilon))
          return t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t, [x0 + t * x10, y0 + t * y10];
      }
      function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
        var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
        return dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1 && (cx0 = cx1, cy0 = cy1), {
          cx: cx0,
          cy: cy0,
          x01: -ox,
          y01: -oy,
          x11: cx0 * (r1 / r - 1),
          y11: cy0 * (r1 / r - 1)
        };
      }
      function arc() {
        var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null;
        function arc2() {
          var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw = a1 > a0;
          if (context || (context = buffer = d3Path.path()), r1 < r0 && (r = r1, r1 = r0, r0 = r), !(r1 > epsilon))
            context.moveTo(0, 0);
          else if (da > tau - epsilon)
            context.moveTo(r1 * cos(a0), r1 * sin(a0)), context.arc(0, 0, r1, a0, a1, !cw), r0 > epsilon && (context.moveTo(r0 * cos(a1), r0 * sin(a1)), context.arc(0, 0, r0, a1, a0, cw));
          else {
            var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t0, t1;
            if (rp > epsilon) {
              var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
              (da0 -= p0 * 2) > epsilon ? (p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0) : (da0 = 0, a00 = a10 = (a0 + a1) / 2), (da1 -= p1 * 2) > epsilon ? (p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1) : (da1 = 0, a01 = a11 = (a0 + a1) / 2);
            }
            var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
            if (rc > epsilon) {
              var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x00 = r0 * cos(a00), y00 = r0 * sin(a00), oc;
              if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
                var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                rc0 = min(rc, (r0 - lc) / (kc - 1)), rc1 = min(rc, (r1 - lc) / (kc + 1));
              }
            }
            da1 > epsilon ? rc1 > epsilon ? (t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw), t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw), context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01), rc1 < rc ? context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw) : (context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw), context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw), context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw))) : (context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw)) : context.moveTo(x01, y01), !(r0 > epsilon) || !(da0 > epsilon) ? context.lineTo(x10, y10) : rc0 > epsilon ? (t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw), t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw), context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01), rc0 < rc ? context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw) : (context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw), context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw), context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw))) : context.arc(0, 0, r0, a10, a00, cw);
          }
          if (context.closePath(), buffer)
            return context = null, buffer + "" || null;
        }
        return arc2.centroid = function() {
          var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a2 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
          return [cos(a2) * r, sin(a2) * r];
        }, arc2.innerRadius = function(_) {
          return arguments.length ? (innerRadius = typeof _ == "function" ? _ : constant(+_), arc2) : innerRadius;
        }, arc2.outerRadius = function(_) {
          return arguments.length ? (outerRadius = typeof _ == "function" ? _ : constant(+_), arc2) : outerRadius;
        }, arc2.cornerRadius = function(_) {
          return arguments.length ? (cornerRadius = typeof _ == "function" ? _ : constant(+_), arc2) : cornerRadius;
        }, arc2.padRadius = function(_) {
          return arguments.length ? (padRadius = _ == null ? null : typeof _ == "function" ? _ : constant(+_), arc2) : padRadius;
        }, arc2.startAngle = function(_) {
          return arguments.length ? (startAngle = typeof _ == "function" ? _ : constant(+_), arc2) : startAngle;
        }, arc2.endAngle = function(_) {
          return arguments.length ? (endAngle = typeof _ == "function" ? _ : constant(+_), arc2) : endAngle;
        }, arc2.padAngle = function(_) {
          return arguments.length ? (padAngle = typeof _ == "function" ? _ : constant(+_), arc2) : padAngle;
        }, arc2.context = function(_) {
          return arguments.length ? (context = _ ?? null, arc2) : context;
        }, arc2;
      }
      var slice = Array.prototype.slice;
      function array(x2) {
        return typeof x2 == "object" && "length" in x2 ? x2 : Array.from(x2);
      }
      function Linear(context) {
        this._context = context;
      }
      Linear.prototype = {
        areaStart: function() {
          this._line = 0;
        },
        areaEnd: function() {
          this._line = NaN;
        },
        lineStart: function() {
          this._point = 0;
        },
        lineEnd: function() {
          (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
        },
        point: function(x2, y2) {
          switch (x2 = +x2, y2 = +y2, this._point) {
            case 0:
              this._point = 1, this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
              break;
            case 1:
              this._point = 2;
            default:
              this._context.lineTo(x2, y2);
              break;
          }
        }
      };
      function curveLinear(context) {
        return new Linear(context);
      }
      function x(p) {
        return p[0];
      }
      function y(p) {
        return p[1];
      }
      function line(x$1, y$1) {
        var defined = constant(!0), context = null, curve = curveLinear, output = null;
        x$1 = typeof x$1 == "function" ? x$1 : x$1 === void 0 ? x : constant(x$1), y$1 = typeof y$1 == "function" ? y$1 : y$1 === void 0 ? y : constant(y$1);
        function line2(data) {
          var i, n = (data = array(data)).length, d, defined0 = !1, buffer;
          for (context == null && (output = curve(buffer = d3Path.path())), i = 0; i <= n; ++i)
            !(i < n && defined(d = data[i], i, data)) === defined0 && ((defined0 = !defined0) ? output.lineStart() : output.lineEnd()), defined0 && output.point(+x$1(d, i, data), +y$1(d, i, data));
          if (buffer)
            return output = null, buffer + "" || null;
        }
        return line2.x = function(_) {
          return arguments.length ? (x$1 = typeof _ == "function" ? _ : constant(+_), line2) : x$1;
        }, line2.y = function(_) {
          return arguments.length ? (y$1 = typeof _ == "function" ? _ : constant(+_), line2) : y$1;
        }, line2.defined = function(_) {
          return arguments.length ? (defined = typeof _ == "function" ? _ : constant(!!_), line2) : defined;
        }, line2.curve = function(_) {
          return arguments.length ? (curve = _, context != null && (output = curve(context)), line2) : curve;
        }, line2.context = function(_) {
          return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line2) : context;
        }, line2;
      }
      function area(x0, y0, y1) {
        var x1 = null, defined = constant(!0), context = null, curve = curveLinear, output = null;
        x0 = typeof x0 == "function" ? x0 : x0 === void 0 ? x : constant(+x0), y0 = typeof y0 == "function" ? y0 : constant(y0 === void 0 ? 0 : +y0), y1 = typeof y1 == "function" ? y1 : y1 === void 0 ? y : constant(+y1);
        function area2(data) {
          var i, j, k2, n = (data = array(data)).length, d, defined0 = !1, buffer, x0z = new Array(n), y0z = new Array(n);
          for (context == null && (output = curve(buffer = d3Path.path())), i = 0; i <= n; ++i) {
            if (!(i < n && defined(d = data[i], i, data)) === defined0)
              if (defined0 = !defined0)
                j = i, output.areaStart(), output.lineStart();
              else {
                for (output.lineEnd(), output.lineStart(), k2 = i - 1; k2 >= j; --k2)
                  output.point(x0z[k2], y0z[k2]);
                output.lineEnd(), output.areaEnd();
              }
            defined0 && (x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data), output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]));
          }
          if (buffer)
            return output = null, buffer + "" || null;
        }
        function arealine() {
          return line().defined(defined).curve(curve).context(context);
        }
        return area2.x = function(_) {
          return arguments.length ? (x0 = typeof _ == "function" ? _ : constant(+_), x1 = null, area2) : x0;
        }, area2.x0 = function(_) {
          return arguments.length ? (x0 = typeof _ == "function" ? _ : constant(+_), area2) : x0;
        }, area2.x1 = function(_) {
          return arguments.length ? (x1 = _ == null ? null : typeof _ == "function" ? _ : constant(+_), area2) : x1;
        }, area2.y = function(_) {
          return arguments.length ? (y0 = typeof _ == "function" ? _ : constant(+_), y1 = null, area2) : y0;
        }, area2.y0 = function(_) {
          return arguments.length ? (y0 = typeof _ == "function" ? _ : constant(+_), area2) : y0;
        }, area2.y1 = function(_) {
          return arguments.length ? (y1 = _ == null ? null : typeof _ == "function" ? _ : constant(+_), area2) : y1;
        }, area2.lineX0 = area2.lineY0 = function() {
          return arealine().x(x0).y(y0);
        }, area2.lineY1 = function() {
          return arealine().x(x0).y(y1);
        }, area2.lineX1 = function() {
          return arealine().x(x1).y(y0);
        }, area2.defined = function(_) {
          return arguments.length ? (defined = typeof _ == "function" ? _ : constant(!!_), area2) : defined;
        }, area2.curve = function(_) {
          return arguments.length ? (curve = _, context != null && (output = curve(context)), area2) : curve;
        }, area2.context = function(_) {
          return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area2) : context;
        }, area2;
      }
      function descending$1(a2, b) {
        return b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
      }
      function identity(d) {
        return d;
      }
      function pie() {
        var value = identity, sortValues = descending$1, sort = null, startAngle = constant(0), endAngle = constant(tau), padAngle = constant(0);
        function pie2(data) {
          var i, n = (data = array(data)).length, j, k2, sum2 = 0, index = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;
          for (i = 0; i < n; ++i)
            (v = arcs[index[i] = i] = +value(data[i], i, data)) > 0 && (sum2 += v);
          for (sortValues != null ? index.sort(function(i2, j2) {
            return sortValues(arcs[i2], arcs[j2]);
          }) : sort != null && index.sort(function(i2, j2) {
            return sort(data[i2], data[j2]);
          }), i = 0, k2 = sum2 ? (da - n * pa) / sum2 : 0; i < n; ++i, a0 = a1)
            j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k2 : 0) + pa, arcs[j] = {
              data: data[j],
              index: i,
              value: v,
              startAngle: a0,
              endAngle: a1,
              padAngle: p
            };
          return arcs;
        }
        return pie2.value = function(_) {
          return arguments.length ? (value = typeof _ == "function" ? _ : constant(+_), pie2) : value;
        }, pie2.sortValues = function(_) {
          return arguments.length ? (sortValues = _, sort = null, pie2) : sortValues;
        }, pie2.sort = function(_) {
          return arguments.length ? (sort = _, sortValues = null, pie2) : sort;
        }, pie2.startAngle = function(_) {
          return arguments.length ? (startAngle = typeof _ == "function" ? _ : constant(+_), pie2) : startAngle;
        }, pie2.endAngle = function(_) {
          return arguments.length ? (endAngle = typeof _ == "function" ? _ : constant(+_), pie2) : endAngle;
        }, pie2.padAngle = function(_) {
          return arguments.length ? (padAngle = typeof _ == "function" ? _ : constant(+_), pie2) : padAngle;
        }, pie2;
      }
      var curveRadialLinear = curveRadial$1(curveLinear);
      function Radial(curve) {
        this._curve = curve;
      }
      Radial.prototype = {
        areaStart: function() {
          this._curve.areaStart();
        },
        areaEnd: function() {
          this._curve.areaEnd();
        },
        lineStart: function() {
          this._curve.lineStart();
        },
        lineEnd: function() {
          this._curve.lineEnd();
        },
        point: function(a2, r) {
          this._curve.point(r * Math.sin(a2), r * -Math.cos(a2));
        }
      };
      function curveRadial$1(curve) {
        function radial(context) {
          return new Radial(curve(context));
        }
        return radial._curve = curve, radial;
      }
      function lineRadial(l) {
        var c2 = l.curve;
        return l.angle = l.x, delete l.x, l.radius = l.y, delete l.y, l.curve = function(_) {
          return arguments.length ? c2(curveRadial$1(_)) : c2()._curve;
        }, l;
      }
      function lineRadial$1() {
        return lineRadial(line().curve(curveRadialLinear));
      }
      function areaRadial() {
        var a2 = area().curve(curveRadialLinear), c2 = a2.curve, x0 = a2.lineX0, x1 = a2.lineX1, y0 = a2.lineY0, y1 = a2.lineY1;
        return a2.angle = a2.x, delete a2.x, a2.startAngle = a2.x0, delete a2.x0, a2.endAngle = a2.x1, delete a2.x1, a2.radius = a2.y, delete a2.y, a2.innerRadius = a2.y0, delete a2.y0, a2.outerRadius = a2.y1, delete a2.y1, a2.lineStartAngle = function() {
          return lineRadial(x0());
        }, delete a2.lineX0, a2.lineEndAngle = function() {
          return lineRadial(x1());
        }, delete a2.lineX1, a2.lineInnerRadius = function() {
          return lineRadial(y0());
        }, delete a2.lineY0, a2.lineOuterRadius = function() {
          return lineRadial(y1());
        }, delete a2.lineY1, a2.curve = function(_) {
          return arguments.length ? c2(curveRadial$1(_)) : c2()._curve;
        }, a2;
      }
      function pointRadial(x2, y2) {
        return [(y2 = +y2) * Math.cos(x2 -= Math.PI / 2), y2 * Math.sin(x2)];
      }
      function linkSource(d) {
        return d.source;
      }
      function linkTarget(d) {
        return d.target;
      }
      function link(curve) {
        var source = linkSource, target = linkTarget, x$1 = x, y$1 = y, context = null;
        function link2() {
          var buffer, argv = slice.call(arguments), s2 = source.apply(this, argv), t = target.apply(this, argv);
          if (context || (context = buffer = d3Path.path()), curve(context, +x$1.apply(this, (argv[0] = s2, argv)), +y$1.apply(this, argv), +x$1.apply(this, (argv[0] = t, argv)), +y$1.apply(this, argv)), buffer)
            return context = null, buffer + "" || null;
        }
        return link2.source = function(_) {
          return arguments.length ? (source = _, link2) : source;
        }, link2.target = function(_) {
          return arguments.length ? (target = _, link2) : target;
        }, link2.x = function(_) {
          return arguments.length ? (x$1 = typeof _ == "function" ? _ : constant(+_), link2) : x$1;
        }, link2.y = function(_) {
          return arguments.length ? (y$1 = typeof _ == "function" ? _ : constant(+_), link2) : y$1;
        }, link2.context = function(_) {
          return arguments.length ? (context = _ ?? null, link2) : context;
        }, link2;
      }
      function curveHorizontal(context, x0, y0, x1, y1) {
        context.moveTo(x0, y0), context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
      }
      function curveVertical(context, x0, y0, x1, y1) {
        context.moveTo(x0, y0), context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
      }
      function curveRadial(context, x0, y0, x1, y1) {
        var p0 = pointRadial(x0, y0), p1 = pointRadial(x0, y0 = (y0 + y1) / 2), p2 = pointRadial(x1, y0), p3 = pointRadial(x1, y1);
        context.moveTo(p0[0], p0[1]), context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
      }
      function linkHorizontal() {
        return link(curveHorizontal);
      }
      function linkVertical() {
        return link(curveVertical);
      }
      function linkRadial() {
        var l = link(curveRadial);
        return l.angle = l.x, delete l.x, l.radius = l.y, delete l.y, l;
      }
      var circle = {
        draw: function(context, size) {
          var r = Math.sqrt(size / pi);
          context.moveTo(r, 0), context.arc(0, 0, r, 0, tau);
        }
      }, cross = {
        draw: function(context, size) {
          var r = Math.sqrt(size / 5) / 2;
          context.moveTo(-3 * r, -r), context.lineTo(-r, -r), context.lineTo(-r, -3 * r), context.lineTo(r, -3 * r), context.lineTo(r, -r), context.lineTo(3 * r, -r), context.lineTo(3 * r, r), context.lineTo(r, r), context.lineTo(r, 3 * r), context.lineTo(-r, 3 * r), context.lineTo(-r, r), context.lineTo(-3 * r, r), context.closePath();
        }
      }, tan30 = Math.sqrt(1 / 3), tan30_2 = tan30 * 2, diamond = {
        draw: function(context, size) {
          var y2 = Math.sqrt(size / tan30_2), x2 = y2 * tan30;
          context.moveTo(0, -y2), context.lineTo(x2, 0), context.lineTo(0, y2), context.lineTo(-x2, 0), context.closePath();
        }
      }, ka = 0.8908130915292852, kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10), kx = Math.sin(tau / 10) * kr, ky = -Math.cos(tau / 10) * kr, star = {
        draw: function(context, size) {
          var r = Math.sqrt(size * ka), x2 = kx * r, y2 = ky * r;
          context.moveTo(0, -r), context.lineTo(x2, y2);
          for (var i = 1; i < 5; ++i) {
            var a2 = tau * i / 5, c2 = Math.cos(a2), s2 = Math.sin(a2);
            context.lineTo(s2 * r, -c2 * r), context.lineTo(c2 * x2 - s2 * y2, s2 * x2 + c2 * y2);
          }
          context.closePath();
        }
      }, square = {
        draw: function(context, size) {
          var w = Math.sqrt(size), x2 = -w / 2;
          context.rect(x2, x2, w, w);
        }
      }, sqrt3 = Math.sqrt(3), triangle = {
        draw: function(context, size) {
          var y2 = -Math.sqrt(size / (sqrt3 * 3));
          context.moveTo(0, y2 * 2), context.lineTo(-sqrt3 * y2, -y2), context.lineTo(sqrt3 * y2, -y2), context.closePath();
        }
      }, c = -0.5, s = Math.sqrt(3) / 2, k = 1 / Math.sqrt(12), a = (k / 2 + 1) * 3, wye = {
        draw: function(context, size) {
          var r = Math.sqrt(size / a), x0 = r / 2, y0 = r * k, x1 = x0, y1 = r * k + r, x2 = -x1, y2 = y1;
          context.moveTo(x0, y0), context.lineTo(x1, y1), context.lineTo(x2, y2), context.lineTo(c * x0 - s * y0, s * x0 + c * y0), context.lineTo(c * x1 - s * y1, s * x1 + c * y1), context.lineTo(c * x2 - s * y2, s * x2 + c * y2), context.lineTo(c * x0 + s * y0, c * y0 - s * x0), context.lineTo(c * x1 + s * y1, c * y1 - s * x1), context.lineTo(c * x2 + s * y2, c * y2 - s * x2), context.closePath();
        }
      }, symbols = [
        circle,
        cross,
        diamond,
        square,
        star,
        triangle,
        wye
      ];
      function symbol(type, size) {
        var context = null;
        type = typeof type == "function" ? type : constant(type || circle), size = typeof size == "function" ? size : constant(size === void 0 ? 64 : +size);
        function symbol2() {
          var buffer;
          if (context || (context = buffer = d3Path.path()), type.apply(this, arguments).draw(context, +size.apply(this, arguments)), buffer)
            return context = null, buffer + "" || null;
        }
        return symbol2.type = function(_) {
          return arguments.length ? (type = typeof _ == "function" ? _ : constant(_), symbol2) : type;
        }, symbol2.size = function(_) {
          return arguments.length ? (size = typeof _ == "function" ? _ : constant(+_), symbol2) : size;
        }, symbol2.context = function(_) {
          return arguments.length ? (context = _ ?? null, symbol2) : context;
        }, symbol2;
      }
      function noop() {
      }
      function point$3(that, x2, y2) {
        that._context.bezierCurveTo(
          (2 * that._x0 + that._x1) / 3,
          (2 * that._y0 + that._y1) / 3,
          (that._x0 + 2 * that._x1) / 3,
          (that._y0 + 2 * that._y1) / 3,
          (that._x0 + 4 * that._x1 + x2) / 6,
          (that._y0 + 4 * that._y1 + y2) / 6
        );
      }
      function Basis(context) {
        this._context = context;
      }
      Basis.prototype = {
        areaStart: function() {
          this._line = 0;
        },
        areaEnd: function() {
          this._line = NaN;
        },
        lineStart: function() {
          this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
        },
        lineEnd: function() {
          switch (this._point) {
            case 3:
              point$3(this, this._x1, this._y1);
            case 2:
              this._context.lineTo(this._x1, this._y1);
              break;
          }
          (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
        },
        point: function(x2, y2) {
          switch (x2 = +x2, y2 = +y2, this._point) {
            case 0:
              this._point = 1, this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
              break;
            case 1:
              this._point = 2;
              break;
            case 2:
              this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
            default:
              point$3(this, x2, y2);
              break;
          }
          this._x0 = this._x1, this._x1 = x2, this._y0 = this._y1, this._y1 = y2;
        }
      };
      function basis(context) {
        return new Basis(context);
      }
      function BasisClosed(context) {
        this._context = context;
      }
      BasisClosed.prototype = {
        areaStart: noop,
        areaEnd: noop,
        lineStart: function() {
          this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
        },
        lineEnd: function() {
          switch (this._point) {
            case 1: {
              this._context.moveTo(this._x2, this._y2), this._context.closePath();
              break;
            }
            case 2: {
              this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
              break;
            }
            case 3: {
              this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
              break;
            }
          }
        },
        point: function(x2, y2) {
          switch (x2 = +x2, y2 = +y2, this._point) {
            case 0:
              this._point = 1, this._x2 = x2, this._y2 = y2;
              break;
            case 1:
              this._point = 2, this._x3 = x2, this._y3 = y2;
              break;
            case 2:
              this._point = 3, this._x4 = x2, this._y4 = y2, this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
              break;
            default:
              point$3(this, x2, y2);
              break;
          }
          this._x0 = this._x1, this._x1 = x2, this._y0 = this._y1, this._y1 = y2;
        }
      };
      function basisClosed(context) {
        return new BasisClosed(context);
      }
      function BasisOpen(context) {
        this._context = context;
      }
      BasisOpen.prototype = {
        areaStart: function() {
          this._line = 0;
        },
        areaEnd: function() {
          this._line = NaN;
        },
        lineStart: function() {
          this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
        },
        lineEnd: function() {
          (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
        },
        point: function(x2, y2) {
          switch (x2 = +x2, y2 = +y2, this._point) {
            case 0:
              this._point = 1;
              break;
            case 1:
              this._point = 2;
              break;
            case 2:
              this._point = 3;
              var x0 = (this._x0 + 4 * this._x1 + x2) / 6, y0 = (this._y0 + 4 * this._y1 + y2) / 6;
              this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
              break;
            case 3:
              this._point = 4;
            default:
              point$3(this, x2, y2);
              break;
          }
          this._x0 = this._x1, this._x1 = x2, this._y0 = this._y1, this._y1 = y2;
        }
      };
      function basisOpen(context) {
        return new BasisOpen(context);
      }
      class Bump {
        constructor(context, x2) {
          this._context = context, this._x = x2;
        }
        areaStart() {
          this._line = 0;
        }
        areaEnd() {
          this._line = NaN;
        }
        lineStart() {
          this._point = 0;
        }
        lineEnd() {
          (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
        }
        point(x2, y2) {
          switch (x2 = +x2, y2 = +y2, this._point) {
            case 0: {
              this._point = 1, this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
              break;
            }
            case 1:
              this._point = 2;
            default: {
              this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + x2) / 2, this._y0, this._x0, y2, x2, y2) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y2) / 2, x2, this._y0, x2, y2);
              break;
            }
          }
          this._x0 = x2, this._y0 = y2;
        }
      }
      function bumpX(context) {
        return new Bump(context, !0);
      }
      function bumpY(context) {
        return new Bump(context, !1);
      }
      function Bundle(context, beta) {
        this._basis = new Basis(context), this._beta = beta;
      }
      Bundle.prototype = {
        lineStart: function() {
          this._x = [], this._y = [], this._basis.lineStart();
        },
        lineEnd: function() {
          var x2 = this._x, y2 = this._y, j = x2.length - 1;
          if (j > 0)
            for (var x0 = x2[0], y0 = y2[0], dx = x2[j] - x0, dy = y2[j] - y0, i = -1, t; ++i <= j; )
              t = i / j, this._basis.point(
                this._beta * x2[i] + (1 - this._beta) * (x0 + t * dx),
                this._beta * y2[i] + (1 - this._beta) * (y0 + t * dy)
              );
          this._x = this._y = null, this._basis.lineEnd();
        },
        point: function(x2, y2) {
          this._x.push(+x2), this._y.push(+y2);
        }
      };
      var bundle = function custom(beta) {
        function bundle2(context) {
          return beta === 1 ? new Basis(context) : new Bundle(context, beta);
        }
        return bundle2.beta = function(beta2) {
          return custom(+beta2);
        }, bundle2;
      }(0.85);
      function point$2(that, x2, y2) {
        that._context.bezierCurveTo(
          that._x1 + that._k * (that._x2 - that._x0),
          that._y1 + that._k * (that._y2 - that._y0),
          that._x2 + that._k * (that._x1 - x2),
          that._y2 + that._k * (that._y1 - y2),
          that._x2,
          that._y2
        );
      }
      function Cardinal(context, tension) {
        this._context = context, this._k = (1 - tension) / 6;
      }
      Cardinal.prototype = {
        areaStart: function() {
          this._line = 0;
        },
        areaEnd: function() {
          this._line = NaN;
        },
        lineStart: function() {
          this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
        },
        lineEnd: function() {
          switch (this._point) {
            case 2:
              this._context.lineTo(this._x2, this._y2);
              break;
            case 3:
              point$2(this, this._x1, this._y1);
              break;
          }
          (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
        },
        point: function(x2, y2) {
          switch (x2 = +x2, y2 = +y2, this._point) {
            case 0:
              this._point = 1, this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
              break;
            case 1:
              this._point = 2, this._x1 = x2, this._y1 = y2;
              break;
            case 2:
              this._point = 3;
            default:
              point$2(this, x2, y2);
              break;
          }
          this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
        }
      };
      var cardinal = function custom(tension) {
        function cardinal2(context) {
          return new Cardinal(context, tension);
        }
        return cardinal2.tension = function(tension2) {
          return custom(+tension2);
        }, cardinal2;
      }(0);
      function CardinalClosed(context, tension) {
        this._context = context, this._k = (1 - tension) / 6;
      }
      CardinalClosed.prototype = {
        areaStart: noop,
        areaEnd: noop,
        lineStart: function() {
          this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
        },
        lineEnd: function() {
          switch (this._point) {
            case 1: {
              this._context.moveTo(this._x3, this._y3), this._context.closePath();
              break;
            }
            case 2: {
              this._context.lineTo(this._x3, this._y3), this._context.closePath();
              break;
            }
            case 3: {
              this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
              break;
            }
          }
        },
        point: function(x2, y2) {
          switch (x2 = +x2, y2 = +y2, this._point) {
            case 0:
              this._point = 1, this._x3 = x2, this._y3 = y2;
              break;
            case 1:
              this._point = 2, this._context.moveTo(this._x4 = x2, this._y4 = y2);
              break;
            case 2:
              this._point = 3, this._x5 = x2, this._y5 = y2;
              break;
            default:
              point$2(this, x2, y2);
              break;
          }
          this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
        }
      };
      var cardinalClosed = function custom(tension) {
        function cardinal2(context) {
          return new CardinalClosed(context, tension);
        }
        return cardinal2.tension = function(tension2) {
          return custom(+tension2);
        }, cardinal2;
      }(0);
      function CardinalOpen(context, tension) {
        this._context = context, this._k = (1 - tension) / 6;
      }
      CardinalOpen.prototype = {
        areaStart: function() {
          this._line = 0;
        },
        areaEnd: function() {
          this._line = NaN;
        },
        lineStart: function() {
          this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
        },
        lineEnd: function() {
          (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
        },
        point: function(x2, y2) {
          switch (x2 = +x2, y2 = +y2, this._point) {
            case 0:
              this._point = 1;
              break;
            case 1:
              this._point = 2;
              break;
            case 2:
              this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
              break;
            case 3:
              this._point = 4;
            default:
              point$2(this, x2, y2);
              break;
          }
          this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
        }
      };
      var cardinalOpen = function custom(tension) {
        function cardinal2(context) {
          return new CardinalOpen(context, tension);
        }
        return cardinal2.tension = function(tension2) {
          return custom(+tension2);
        }, cardinal2;
      }(0);
      function point$1(that, x2, y2) {
        var x1 = that._x1, y1 = that._y1, x22 = that._x2, y22 = that._y2;
        if (that._l01_a > epsilon) {
          var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
          x1 = (x1 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n, y1 = (y1 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
        }
        if (that._l23_a > epsilon) {
          var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);
          x22 = (x22 * b + that._x1 * that._l23_2a - x2 * that._l12_2a) / m, y22 = (y22 * b + that._y1 * that._l23_2a - y2 * that._l12_2a) / m;
        }
        that._context.bezierCurveTo(x1, y1, x22, y22, that._x2, that._y2);
      }
      function CatmullRom(context, alpha) {
        this._context = context, this._alpha = alpha;
      }
      CatmullRom.prototype = {
        areaStart: function() {
          this._line = 0;
        },
        areaEnd: function() {
          this._line = NaN;
        },
        lineStart: function() {
          this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
        },
        lineEnd: function() {
          switch (this._point) {
            case 2:
              this._context.lineTo(this._x2, this._y2);
              break;
            case 3:
              this.point(this._x2, this._y2);
              break;
          }
          (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
        },
        point: function(x2, y2) {
          if (x2 = +x2, y2 = +y2, this._point) {
            var x23 = this._x2 - x2, y23 = this._y2 - y2;
            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
          }
          switch (this._point) {
            case 0:
              this._point = 1, this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
              break;
            case 1:
              this._point = 2;
              break;
            case 2:
              this._point = 3;
            default:
              point$1(this, x2, y2);
              break;
          }
          this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
        }
      };
      var catmullRom = function custom(alpha) {
        function catmullRom2(context) {
          return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
        }
        return catmullRom2.alpha = function(alpha2) {
          return custom(+alpha2);
        }, catmullRom2;
      }(0.5);
      function CatmullRomClosed(context, alpha) {
        this._context = context, this._alpha = alpha;
      }
      CatmullRomClosed.prototype = {
        areaStart: noop,
        areaEnd: noop,
        lineStart: function() {
          this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
        },
        lineEnd: function() {
          switch (this._point) {
            case 1: {
              this._context.moveTo(this._x3, this._y3), this._context.closePath();
              break;
            }
            case 2: {
              this._context.lineTo(this._x3, this._y3), this._context.closePath();
              break;
            }
            case 3: {
              this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
              break;
            }
          }
        },
        point: function(x2, y2) {
          if (x2 = +x2, y2 = +y2, this._point) {
            var x23 = this._x2 - x2, y23 = this._y2 - y2;
            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
          }
          switch (this._point) {
            case 0:
              this._point = 1, this._x3 = x2, this._y3 = y2;
              break;
            case 1:
              this._point = 2, this._context.moveTo(this._x4 = x2, this._y4 = y2);
              break;
            case 2:
              this._point = 3, this._x5 = x2, this._y5 = y2;
              break;
            default:
              point$1(this, x2, y2);
              break;
          }
          this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
        }
      };
      var catmullRomClosed = function custom(alpha) {
        function catmullRom2(context) {
          return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
        }
        return catmullRom2.alpha = function(alpha2) {
          return custom(+alpha2);
        }, catmullRom2;
      }(0.5);
      function CatmullRomOpen(context, alpha) {
        this._context = context, this._alpha = alpha;
      }
      CatmullRomOpen.prototype = {
        areaStart: function() {
          this._line = 0;
        },
        areaEnd: function() {
          this._line = NaN;
        },
        lineStart: function() {
          this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
        },
        lineEnd: function() {
          (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
        },
        point: function(x2, y2) {
          if (x2 = +x2, y2 = +y2, this._point) {
            var x23 = this._x2 - x2, y23 = this._y2 - y2;
            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
          }
          switch (this._point) {
            case 0:
              this._point = 1;
              break;
            case 1:
              this._point = 2;
              break;
            case 2:
              this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
              break;
            case 3:
              this._point = 4;
            default:
              point$1(this, x2, y2);
              break;
          }
          this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
        }
      };
      var catmullRomOpen = function custom(alpha) {
        function catmullRom2(context) {
          return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
        }
        return catmullRom2.alpha = function(alpha2) {
          return custom(+alpha2);
        }, catmullRom2;
      }(0.5);
      function LinearClosed(context) {
        this._context = context;
      }
      LinearClosed.prototype = {
        areaStart: noop,
        areaEnd: noop,
        lineStart: function() {
          this._point = 0;
        },
        lineEnd: function() {
          this._point && this._context.closePath();
        },
        point: function(x2, y2) {
          x2 = +x2, y2 = +y2, this._point ? this._context.lineTo(x2, y2) : (this._point = 1, this._context.moveTo(x2, y2));
        }
      };
      function linearClosed(context) {
        return new LinearClosed(context);
      }
      function sign(x2) {
        return x2 < 0 ? -1 : 1;
      }
      function slope3(that, x2, y2) {
        var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
        return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
      }
      function slope2(that, t) {
        var h = that._x1 - that._x0;
        return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
      }
      function point(that, t0, t1) {
        var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
        that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
      }
      function MonotoneX(context) {
        this._context = context;
      }
      MonotoneX.prototype = {
        areaStart: function() {
          this._line = 0;
        },
        areaEnd: function() {
          this._line = NaN;
        },
        lineStart: function() {
          this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
        },
        lineEnd: function() {
          switch (this._point) {
            case 2:
              this._context.lineTo(this._x1, this._y1);
              break;
            case 3:
              point(this, this._t0, slope2(this, this._t0));
              break;
          }
          (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
        },
        point: function(x2, y2) {
          var t1 = NaN;
          if (x2 = +x2, y2 = +y2, !(x2 === this._x1 && y2 === this._y1)) {
            switch (this._point) {
              case 0:
                this._point = 1, this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
                break;
              case 1:
                this._point = 2;
                break;
              case 2:
                this._point = 3, point(this, slope2(this, t1 = slope3(this, x2, y2)), t1);
                break;
              default:
                point(this, this._t0, t1 = slope3(this, x2, y2));
                break;
            }
            this._x0 = this._x1, this._x1 = x2, this._y0 = this._y1, this._y1 = y2, this._t0 = t1;
          }
        }
      };
      function MonotoneY(context) {
        this._context = new ReflectContext(context);
      }
      (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
        MonotoneX.prototype.point.call(this, y2, x2);
      };
      function ReflectContext(context) {
        this._context = context;
      }
      ReflectContext.prototype = {
        moveTo: function(x2, y2) {
          this._context.moveTo(y2, x2);
        },
        closePath: function() {
          this._context.closePath();
        },
        lineTo: function(x2, y2) {
          this._context.lineTo(y2, x2);
        },
        bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
          this._context.bezierCurveTo(y1, x1, y2, x2, y3, x3);
        }
      };
      function monotoneX(context) {
        return new MonotoneX(context);
      }
      function monotoneY(context) {
        return new MonotoneY(context);
      }
      function Natural(context) {
        this._context = context;
      }
      Natural.prototype = {
        areaStart: function() {
          this._line = 0;
        },
        areaEnd: function() {
          this._line = NaN;
        },
        lineStart: function() {
          this._x = [], this._y = [];
        },
        lineEnd: function() {
          var x2 = this._x, y2 = this._y, n = x2.length;
          if (n)
            if (this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]), n === 2)
              this._context.lineTo(x2[1], y2[1]);
            else
              for (var px = controlPoints(x2), py = controlPoints(y2), i0 = 0, i1 = 1; i1 < n; ++i0, ++i1)
                this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
          (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
        },
        point: function(x2, y2) {
          this._x.push(+x2), this._y.push(+y2);
        }
      };
      function controlPoints(x2) {
        var i, n = x2.length - 1, m, a2 = new Array(n), b = new Array(n), r = new Array(n);
        for (a2[0] = 0, b[0] = 2, r[0] = x2[0] + 2 * x2[1], i = 1; i < n - 1; ++i)
          a2[i] = 1, b[i] = 4, r[i] = 4 * x2[i] + 2 * x2[i + 1];
        for (a2[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x2[n - 1] + x2[n], i = 1; i < n; ++i)
          m = a2[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
        for (a2[n - 1] = r[n - 1] / b[n - 1], i = n - 2; i >= 0; --i)
          a2[i] = (r[i] - a2[i + 1]) / b[i];
        for (b[n - 1] = (x2[n] + a2[n - 1]) / 2, i = 0; i < n - 1; ++i)
          b[i] = 2 * x2[i + 1] - a2[i + 1];
        return [a2, b];
      }
      function natural(context) {
        return new Natural(context);
      }
      function Step(context, t) {
        this._context = context, this._t = t;
      }
      Step.prototype = {
        areaStart: function() {
          this._line = 0;
        },
        areaEnd: function() {
          this._line = NaN;
        },
        lineStart: function() {
          this._x = this._y = NaN, this._point = 0;
        },
        lineEnd: function() {
          0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
        },
        point: function(x2, y2) {
          switch (x2 = +x2, y2 = +y2, this._point) {
            case 0:
              this._point = 1, this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
              break;
            case 1:
              this._point = 2;
            default: {
              if (this._t <= 0)
                this._context.lineTo(this._x, y2), this._context.lineTo(x2, y2);
              else {
                var x1 = this._x * (1 - this._t) + x2 * this._t;
                this._context.lineTo(x1, this._y), this._context.lineTo(x1, y2);
              }
              break;
            }
          }
          this._x = x2, this._y = y2;
        }
      };
      function step(context) {
        return new Step(context, 0.5);
      }
      function stepBefore(context) {
        return new Step(context, 0);
      }
      function stepAfter(context) {
        return new Step(context, 1);
      }
      function none$1(series, order) {
        if ((n = series.length) > 1)
          for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i)
            for (s0 = s1, s1 = series[order[i]], j = 0; j < m; ++j)
              s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
      }
      function none(series) {
        for (var n = series.length, o = new Array(n); --n >= 0; )
          o[n] = n;
        return o;
      }
      function stackValue(d, key) {
        return d[key];
      }
      function stackSeries(key) {
        let series = [];
        return series.key = key, series;
      }
      function stack() {
        var keys = constant([]), order = none, offset = none$1, value = stackValue;
        function stack2(data) {
          var sz = Array.from(keys.apply(this, arguments), stackSeries), i, n = sz.length, j = -1, oz;
          for (let d of data)
            for (i = 0, ++j; i < n; ++i)
              (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
          for (i = 0, oz = array(order(sz)); i < n; ++i)
            sz[oz[i]].index = i;
          return offset(sz, oz), sz;
        }
        return stack2.keys = function(_) {
          return arguments.length ? (keys = typeof _ == "function" ? _ : constant(Array.from(_)), stack2) : keys;
        }, stack2.value = function(_) {
          return arguments.length ? (value = typeof _ == "function" ? _ : constant(+_), stack2) : value;
        }, stack2.order = function(_) {
          return arguments.length ? (order = _ == null ? none : typeof _ == "function" ? _ : constant(Array.from(_)), stack2) : order;
        }, stack2.offset = function(_) {
          return arguments.length ? (offset = _ ?? none$1, stack2) : offset;
        }, stack2;
      }
      function expand(series, order) {
        if ((n = series.length) > 0) {
          for (var i, n, j = 0, m = series[0].length, y2; j < m; ++j) {
            for (y2 = i = 0; i < n; ++i)
              y2 += series[i][j][1] || 0;
            if (y2)
              for (i = 0; i < n; ++i)
                series[i][j][1] /= y2;
          }
          none$1(series, order);
        }
      }
      function diverging(series, order) {
        if ((n = series.length) > 0)
          for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j)
            for (yp = yn = 0, i = 0; i < n; ++i)
              (dy = (d = series[order[i]][j])[1] - d[0]) > 0 ? (d[0] = yp, d[1] = yp += dy) : dy < 0 ? (d[1] = yn, d[0] = yn += dy) : (d[0] = 0, d[1] = dy);
      }
      function silhouette(series, order) {
        if ((n = series.length) > 0) {
          for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
            for (var i = 0, y2 = 0; i < n; ++i)
              y2 += series[i][j][1] || 0;
            s0[j][1] += s0[j][0] = -y2 / 2;
          }
          none$1(series, order);
        }
      }
      function wiggle(series, order) {
        if (!(!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0))) {
          for (var y2 = 0, j = 1, s0, m, n; j < m; ++j) {
            for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
              for (var si = series[order[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2, k2 = 0; k2 < i; ++k2) {
                var sk = series[order[k2]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
                s3 += skj0 - skj1;
              }
              s1 += sij0, s2 += s3 * sij0;
            }
            s0[j - 1][1] += s0[j - 1][0] = y2, s1 && (y2 -= s2 / s1);
          }
          s0[j - 1][1] += s0[j - 1][0] = y2, none$1(series, order);
        }
      }
      function appearance(series) {
        var peaks = series.map(peak);
        return none(series).sort(function(a2, b) {
          return peaks[a2] - peaks[b];
        });
      }
      function peak(series) {
        for (var i = -1, j = 0, n = series.length, vi, vj = -1 / 0; ++i < n; )
          (vi = +series[i][1]) > vj && (vj = vi, j = i);
        return j;
      }
      function ascending(series) {
        var sums = series.map(sum);
        return none(series).sort(function(a2, b) {
          return sums[a2] - sums[b];
        });
      }
      function sum(series) {
        for (var s2 = 0, i = -1, n = series.length, v; ++i < n; )
          (v = +series[i][1]) && (s2 += v);
        return s2;
      }
      function descending(series) {
        return ascending(series).reverse();
      }
      function insideOut(series) {
        var n = series.length, i, j, sums = series.map(sum), order = appearance(series), top = 0, bottom = 0, tops = [], bottoms = [];
        for (i = 0; i < n; ++i)
          j = order[i], top < bottom ? (top += sums[j], tops.push(j)) : (bottom += sums[j], bottoms.push(j));
        return bottoms.reverse().concat(tops);
      }
      function reverse(series) {
        return none(series).reverse();
      }
      exports2.arc = arc, exports2.area = area, exports2.areaRadial = areaRadial, exports2.curveBasis = basis, exports2.curveBasisClosed = basisClosed, exports2.curveBasisOpen = basisOpen, exports2.curveBumpX = bumpX, exports2.curveBumpY = bumpY, exports2.curveBundle = bundle, exports2.curveCardinal = cardinal, exports2.curveCardinalClosed = cardinalClosed, exports2.curveCardinalOpen = cardinalOpen, exports2.curveCatmullRom = catmullRom, exports2.curveCatmullRomClosed = catmullRomClosed, exports2.curveCatmullRomOpen = catmullRomOpen, exports2.curveLinear = curveLinear, exports2.curveLinearClosed = linearClosed, exports2.curveMonotoneX = monotoneX, exports2.curveMonotoneY = monotoneY, exports2.curveNatural = natural, exports2.curveStep = step, exports2.curveStepAfter = stepAfter, exports2.curveStepBefore = stepBefore, exports2.line = line, exports2.lineRadial = lineRadial$1, exports2.linkHorizontal = linkHorizontal, exports2.linkRadial = linkRadial, exports2.linkVertical = linkVertical, exports2.pie = pie, exports2.pointRadial = pointRadial, exports2.radialArea = areaRadial, exports2.radialLine = lineRadial$1, exports2.stack = stack, exports2.stackOffsetDiverging = diverging, exports2.stackOffsetExpand = expand, exports2.stackOffsetNone = none$1, exports2.stackOffsetSilhouette = silhouette, exports2.stackOffsetWiggle = wiggle, exports2.stackOrderAppearance = appearance, exports2.stackOrderAscending = ascending, exports2.stackOrderDescending = descending, exports2.stackOrderInsideOut = insideOut, exports2.stackOrderNone = none, exports2.stackOrderReverse = reverse, exports2.symbol = symbol, exports2.symbolCircle = circle, exports2.symbolCross = cross, exports2.symbolDiamond = diamond, exports2.symbolSquare = square, exports2.symbolStar = star, exports2.symbolTriangle = triangle, exports2.symbolWye = wye, exports2.symbols = symbols, Object.defineProperty(exports2, "__esModule", { value: !0 });
    });
  }
});

// node_modules/recharts/lib/shape/Symbols.js
var require_Symbols = __commonJS({
  "node_modules/recharts/lib/shape/Symbols.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Symbols = void 0;
    var _upperFirst2 = _interopRequireDefault(require("lodash/upperFirst")), _react = _interopRequireWildcard(require("react")), _d3Shape = require_d3_shape(), _classnames = _interopRequireDefault(require("classnames")), _types = require_types();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var symbolFactories = {
      symbolCircle: _d3Shape.symbolCircle,
      symbolCross: _d3Shape.symbolCross,
      symbolDiamond: _d3Shape.symbolDiamond,
      symbolSquare: _d3Shape.symbolSquare,
      symbolStar: _d3Shape.symbolStar,
      symbolTriangle: _d3Shape.symbolTriangle,
      symbolWye: _d3Shape.symbolWye
    }, RADIAN = Math.PI / 180, getSymbolFactory = function(type) {
      var name = "symbol".concat((0, _upperFirst2.default)(type));
      return symbolFactories[name] || _d3Shape.symbolCircle;
    }, calculateAreaSize = function(size, sizeType, type) {
      if (sizeType === "area")
        return size;
      switch (type) {
        case "cross":
          return 5 * size * size / 9;
        case "diamond":
          return 0.5 * size * size / Math.sqrt(3);
        case "square":
          return size * size;
        case "star": {
          var angle = 18 * RADIAN;
          return 1.25 * size * size * (Math.tan(angle) - Math.tan(angle * 2) * Math.pow(Math.tan(angle), 2));
        }
        case "triangle":
          return Math.sqrt(3) * size * size / 4;
        case "wye":
          return (21 - 10 * Math.sqrt(3)) * size * size / 8;
        default:
          return Math.PI * size * size / 4;
      }
    }, Symbols = /* @__PURE__ */ function(_PureComponent) {
      _inherits(Symbols2, _PureComponent);
      var _super = _createSuper(Symbols2);
      function Symbols2() {
        return _classCallCheck(this, Symbols2), _super.apply(this, arguments);
      }
      return _createClass(Symbols2, [{
        key: "getPath",
        value: function() {
          var _this$props = this.props, size = _this$props.size, sizeType = _this$props.sizeType, type = _this$props.type, symbolFactory = getSymbolFactory(type), symbol = (0, _d3Shape.symbol)().type(symbolFactory).size(calculateAreaSize(size, sizeType, type));
          return symbol();
        }
      }, {
        key: "render",
        value: function() {
          var _this$props2 = this.props, className = _this$props2.className, cx = _this$props2.cx, cy = _this$props2.cy, size = _this$props2.size;
          return cx === +cx && cy === +cy && size === +size ? /* @__PURE__ */ _react.default.createElement("path", _extends({}, (0, _types.filterProps)(this.props, !0), {
            className: (0, _classnames.default)("recharts-symbols", className),
            transform: "translate(".concat(cx, ", ").concat(cy, ")"),
            d: this.getPath()
          })) : null;
        }
      }]), Symbols2;
    }(_react.PureComponent);
    exports.Symbols = Symbols;
    Symbols.defaultProps = {
      type: "circle",
      size: 64,
      sizeType: "area"
    };
    Symbols.registerSymbol = function(key, factory) {
      symbolFactories["symbol".concat((0, _upperFirst2.default)(key))] = factory;
    };
  }
});

// node_modules/recharts/lib/component/DefaultLegendContent.js
var require_DefaultLegendContent = __commonJS({
  "node_modules/recharts/lib/component/DefaultLegendContent.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.DefaultLegendContent = void 0;
    var _react = _interopRequireWildcard(require("react")), _classnames = _interopRequireDefault(require("classnames")), _Surface = require_Surface(), _Symbols = require_Symbols(), _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var SIZE = 32, DefaultLegendContent = /* @__PURE__ */ function(_PureComponent) {
      _inherits(DefaultLegendContent2, _PureComponent);
      var _super = _createSuper(DefaultLegendContent2);
      function DefaultLegendContent2() {
        return _classCallCheck(this, DefaultLegendContent2), _super.apply(this, arguments);
      }
      return _createClass(DefaultLegendContent2, [{
        key: "renderIcon",
        value: function(data) {
          var inactiveColor = this.props.inactiveColor, halfSize = SIZE / 2, sixthSize = SIZE / 6, thirdSize = SIZE / 3, color = data.inactive ? inactiveColor : data.color;
          if (data.type === "plainline")
            return /* @__PURE__ */ _react.default.createElement("line", {
              strokeWidth: 4,
              fill: "none",
              stroke: color,
              strokeDasharray: data.payload.strokeDasharray,
              x1: 0,
              y1: halfSize,
              x2: SIZE,
              y2: halfSize,
              className: "recharts-legend-icon"
            });
          if (data.type === "line")
            return /* @__PURE__ */ _react.default.createElement("path", {
              strokeWidth: 4,
              fill: "none",
              stroke: color,
              d: "M0,".concat(halfSize, "h").concat(thirdSize, `
            A`).concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(2 * thirdSize, ",").concat(halfSize, `
            H`).concat(SIZE, "M").concat(2 * thirdSize, ",").concat(halfSize, `
            A`).concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(thirdSize, ",").concat(halfSize),
              className: "recharts-legend-icon"
            });
          if (data.type === "rect")
            return /* @__PURE__ */ _react.default.createElement("path", {
              stroke: "none",
              fill: color,
              d: "M0,".concat(SIZE / 8, "h").concat(SIZE, "v").concat(SIZE * 3 / 4, "h").concat(-SIZE, "z"),
              className: "recharts-legend-icon"
            });
          if (/* @__PURE__ */ _react.default.isValidElement(data.legendIcon)) {
            var iconProps = _objectSpread3({}, data);
            return delete iconProps.legendIcon, /* @__PURE__ */ _react.default.cloneElement(data.legendIcon, iconProps);
          }
          return /* @__PURE__ */ _react.default.createElement(_Symbols.Symbols, {
            fill: color,
            cx: halfSize,
            cy: halfSize,
            size: SIZE,
            sizeType: "diameter",
            type: data.type
          });
        }
      }, {
        key: "renderItems",
        value: function() {
          var _this = this, _this$props = this.props, payload = _this$props.payload, iconSize = _this$props.iconSize, layout = _this$props.layout, formatter = _this$props.formatter, inactiveColor = _this$props.inactiveColor, viewBox = {
            x: 0,
            y: 0,
            width: SIZE,
            height: SIZE
          }, itemStyle = {
            display: layout === "horizontal" ? "inline-block" : "block",
            marginRight: 10
          }, svgStyle = {
            display: "inline-block",
            verticalAlign: "middle",
            marginRight: 4
          };
          return payload.map(function(entry2, i) {
            var _classNames, finalFormatter = entry2.formatter || formatter, className = (0, _classnames.default)((_classNames = {
              "recharts-legend-item": !0
            }, _defineProperty3(_classNames, "legend-item-".concat(i), !0), _defineProperty3(_classNames, "inactive", entry2.inactive), _classNames));
            if (entry2.type === "none")
              return null;
            var color = entry2.inactive ? inactiveColor : entry2.color;
            return /* @__PURE__ */ _react.default.createElement("li", _extends({
              className,
              style: itemStyle,
              key: "legend-item-".concat(i)
            }, (0, _types.adaptEventsOfChild)(_this.props, entry2, i)), /* @__PURE__ */ _react.default.createElement(_Surface.Surface, {
              width: iconSize,
              height: iconSize,
              viewBox,
              style: svgStyle
            }, _this.renderIcon(entry2)), /* @__PURE__ */ _react.default.createElement("span", {
              className: "recharts-legend-item-text",
              style: {
                color
              }
            }, finalFormatter ? finalFormatter(entry2.value, entry2, i) : entry2.value));
          });
        }
      }, {
        key: "render",
        value: function() {
          var _this$props2 = this.props, payload = _this$props2.payload, layout = _this$props2.layout, align = _this$props2.align;
          if (!payload || !payload.length)
            return null;
          var finalStyle = {
            padding: 0,
            margin: 0,
            textAlign: layout === "horizontal" ? align : "left"
          };
          return /* @__PURE__ */ _react.default.createElement("ul", {
            className: "recharts-default-legend",
            style: finalStyle
          }, this.renderItems());
        }
      }]), DefaultLegendContent2;
    }(_react.PureComponent);
    exports.DefaultLegendContent = DefaultLegendContent;
    DefaultLegendContent.displayName = "Legend";
    DefaultLegendContent.defaultProps = {
      iconSize: 14,
      layout: "horizontal",
      align: "center",
      verticalAlign: "middle",
      inactiveColor: "#ccc"
    };
  }
});

// node_modules/recharts/lib/util/DataUtils.js
var require_DataUtils = __commonJS({
  "node_modules/recharts/lib/util/DataUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.findEntryInArray = findEntryInArray;
    exports.getLinearRegression = exports.interpolateNumber = exports.hasDuplicate = exports.getAnyElementOfObject = exports.getPercentValue = exports.uniqueId = exports.isNumOrStr = exports.isNumber = exports.isPercent = exports.mathSign = void 0;
    var _get2 = _interopRequireDefault(require("lodash/get")), _isArray2 = _interopRequireDefault(require("lodash/isArray")), _isNaN2 = _interopRequireDefault(require("lodash/isNaN")), _isNumber2 = _interopRequireDefault(require("lodash/isNumber")), _isString2 = _interopRequireDefault(require("lodash/isString"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var mathSign = function(value) {
      return value === 0 ? 0 : value > 0 ? 1 : -1;
    };
    exports.mathSign = mathSign;
    var isPercent = function(value) {
      return (0, _isString2.default)(value) && value.indexOf("%") === value.length - 1;
    };
    exports.isPercent = isPercent;
    var isNumber = function(value) {
      return (0, _isNumber2.default)(value) && !(0, _isNaN2.default)(value);
    };
    exports.isNumber = isNumber;
    var isNumOrStr = function(value) {
      return isNumber(value) || (0, _isString2.default)(value);
    };
    exports.isNumOrStr = isNumOrStr;
    var idCounter3 = 0, uniqueId = function(prefix) {
      var id = ++idCounter3;
      return "".concat(prefix || "").concat(id);
    };
    exports.uniqueId = uniqueId;
    var getPercentValue = function(percent, totalValue) {
      var defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, validate = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
      if (!isNumber(percent) && !(0, _isString2.default)(percent))
        return defaultValue;
      var value;
      if (isPercent(percent)) {
        var index = percent.indexOf("%");
        value = totalValue * parseFloat(percent.slice(0, index)) / 100;
      } else
        value = +percent;
      return (0, _isNaN2.default)(value) && (value = defaultValue), validate && value > totalValue && (value = totalValue), value;
    };
    exports.getPercentValue = getPercentValue;
    var getAnyElementOfObject = function(obj) {
      if (!obj)
        return null;
      var keys = Object.keys(obj);
      return keys && keys.length ? obj[keys[0]] : null;
    };
    exports.getAnyElementOfObject = getAnyElementOfObject;
    var hasDuplicate = function(ary) {
      if (!(0, _isArray2.default)(ary))
        return !1;
      for (var len = ary.length, cache = {}, i = 0; i < len; i++)
        if (!cache[ary[i]])
          cache[ary[i]] = !0;
        else
          return !0;
      return !1;
    };
    exports.hasDuplicate = hasDuplicate;
    var interpolateNumber = function(numberA, numberB) {
      return isNumber(numberA) && isNumber(numberB) ? function(t) {
        return numberA + t * (numberB - numberA);
      } : function() {
        return numberB;
      };
    };
    exports.interpolateNumber = interpolateNumber;
    function findEntryInArray(ary, specifiedKey, specifiedValue) {
      return !ary || !ary.length ? null : ary.find(function(entry2) {
        return entry2 && (typeof specifiedKey == "function" ? specifiedKey(entry2) : (0, _get2.default)(entry2, specifiedKey)) === specifiedValue;
      });
    }
    var getLinearRegression = function(data) {
      if (!data || !data.length)
        return null;
      for (var len = data.length, xsum = 0, ysum = 0, xysum = 0, xxsum = 0, xmin = 1 / 0, xmax = -1 / 0, xcurrent = 0, ycurrent = 0, i = 0; i < len; i++)
        xcurrent = data[i].cx || 0, ycurrent = data[i].cy || 0, xsum += xcurrent, ysum += ycurrent, xysum += xcurrent * ycurrent, xxsum += xcurrent * xcurrent, xmin = Math.min(xmin, xcurrent), xmax = Math.max(xmax, xcurrent);
      var a = len * xxsum !== xsum * xsum ? (len * xysum - xsum * ysum) / (len * xxsum - xsum * xsum) : 0;
      return {
        xmin,
        xmax,
        a,
        b: (ysum - a * xsum) / len
      };
    };
    exports.getLinearRegression = getLinearRegression;
  }
});

// node_modules/recharts/lib/component/Legend.js
var require_Legend = __commonJS({
  "node_modules/recharts/lib/component/Legend.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Legend = void 0;
    var _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _uniqBy2 = _interopRequireDefault(require("lodash/uniqBy")), _react = _interopRequireWildcard(require("react")), _DefaultLegendContent = require_DefaultLegendContent(), _DataUtils = require_DataUtils();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose2(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source, key) || (target[key] = source[key]));
      }
      return target;
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    function defaultUniqBy(entry2) {
      return entry2.value;
    }
    function getUniqPayload(option, payload) {
      return option === !0 ? (0, _uniqBy2.default)(payload, defaultUniqBy) : (0, _isFunction2.default)(option) ? (0, _uniqBy2.default)(payload, option) : payload;
    }
    function renderContent(content, props) {
      if (/* @__PURE__ */ _react.default.isValidElement(content))
        return /* @__PURE__ */ _react.default.cloneElement(content, props);
      if ((0, _isFunction2.default)(content))
        return /* @__PURE__ */ _react.default.createElement(content, props);
      var ref = props.ref, otherProps = _objectWithoutProperties2(props, ["ref"]);
      return /* @__PURE__ */ _react.default.createElement(_DefaultLegendContent.DefaultLegendContent, otherProps);
    }
    var EPS = 1, Legend2 = /* @__PURE__ */ function(_PureComponent) {
      _inherits(Legend3, _PureComponent);
      var _super = _createSuper(Legend3);
      function Legend3() {
        var _this;
        _classCallCheck(this, Legend3);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        return _this = _super.call.apply(_super, [this].concat(args)), _this.wrapperNode = void 0, _this.state = {
          boxWidth: -1,
          boxHeight: -1
        }, _this;
      }
      return _createClass(Legend3, [{
        key: "componentDidMount",
        value: function() {
          this.updateBBox();
        }
      }, {
        key: "componentDidUpdate",
        value: function() {
          this.updateBBox();
        }
      }, {
        key: "getBBox",
        value: function() {
          return this.wrapperNode && this.wrapperNode.getBoundingClientRect ? this.wrapperNode.getBoundingClientRect() : null;
        }
      }, {
        key: "getBBoxSnapshot",
        value: function() {
          var _this$state = this.state, boxWidth = _this$state.boxWidth, boxHeight = _this$state.boxHeight;
          return boxWidth >= 0 && boxHeight >= 0 ? {
            width: boxWidth,
            height: boxHeight
          } : null;
        }
      }, {
        key: "getDefaultPosition",
        value: function(style) {
          var _this$props = this.props, layout = _this$props.layout, align = _this$props.align, verticalAlign = _this$props.verticalAlign, margin = _this$props.margin, chartWidth = _this$props.chartWidth, chartHeight = _this$props.chartHeight, hPos, vPos;
          if (!style || (style.left === void 0 || style.left === null) && (style.right === void 0 || style.right === null))
            if (align === "center" && layout === "vertical") {
              var _box = this.getBBoxSnapshot() || {
                width: 0
              };
              hPos = {
                left: ((chartWidth || 0) - _box.width) / 2
              };
            } else
              hPos = align === "right" ? {
                right: margin && margin.right || 0
              } : {
                left: margin && margin.left || 0
              };
          if (!style || (style.top === void 0 || style.top === null) && (style.bottom === void 0 || style.bottom === null))
            if (verticalAlign === "middle") {
              var _box2 = this.getBBoxSnapshot() || {
                height: 0
              };
              vPos = {
                top: ((chartHeight || 0) - _box2.height) / 2
              };
            } else
              vPos = verticalAlign === "bottom" ? {
                bottom: margin && margin.bottom || 0
              } : {
                top: margin && margin.top || 0
              };
          return _objectSpread3(_objectSpread3({}, hPos), vPos);
        }
      }, {
        key: "updateBBox",
        value: function() {
          var _this$state2 = this.state, boxWidth = _this$state2.boxWidth, boxHeight = _this$state2.boxHeight, onBBoxUpdate = this.props.onBBoxUpdate;
          if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
            var _box3 = this.wrapperNode.getBoundingClientRect();
            (Math.abs(_box3.width - boxWidth) > EPS || Math.abs(_box3.height - boxHeight) > EPS) && this.setState({
              boxWidth: _box3.width,
              boxHeight: _box3.height
            }, function() {
              onBBoxUpdate && onBBoxUpdate(_box3);
            });
          } else
            (boxWidth !== -1 || boxHeight !== -1) && this.setState({
              boxWidth: -1,
              boxHeight: -1
            }, function() {
              onBBoxUpdate && onBBoxUpdate(null);
            });
        }
      }, {
        key: "render",
        value: function() {
          var _this2 = this, _this$props2 = this.props, content = _this$props2.content, width = _this$props2.width, height = _this$props2.height, wrapperStyle = _this$props2.wrapperStyle, payloadUniqBy = _this$props2.payloadUniqBy, payload = _this$props2.payload, outerStyle = _objectSpread3(_objectSpread3({
            position: "absolute",
            width: width || "auto",
            height: height || "auto"
          }, this.getDefaultPosition(wrapperStyle)), wrapperStyle);
          return /* @__PURE__ */ _react.default.createElement("div", {
            className: "recharts-legend-wrapper",
            style: outerStyle,
            ref: function(node) {
              _this2.wrapperNode = node;
            }
          }, renderContent(content, _objectSpread3(_objectSpread3({}, this.props), {}, {
            payload: getUniqPayload(payloadUniqBy, payload)
          })));
        }
      }], [{
        key: "getWithHeight",
        value: function(item, chartWidth) {
          var layout = item.props.layout;
          return layout === "vertical" && (0, _DataUtils.isNumber)(item.props.height) ? {
            height: item.props.height
          } : layout === "horizontal" ? {
            width: item.props.width || chartWidth
          } : null;
        }
      }]), Legend3;
    }(_react.PureComponent);
    exports.Legend = Legend2;
    Legend2.displayName = "Legend";
    Legend2.defaultProps = {
      iconSize: 14,
      layout: "horizontal",
      align: "center",
      verticalAlign: "bottom"
    };
  }
});

// node_modules/recharts/lib/component/DefaultTooltipContent.js
var require_DefaultTooltipContent = __commonJS({
  "node_modules/recharts/lib/component/DefaultTooltipContent.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.DefaultTooltipContent = void 0;
    var _isNil2 = _interopRequireDefault(require("lodash/isNil")), _sortBy2 = _interopRequireDefault(require("lodash/sortBy")), _isArray2 = _interopRequireDefault(require("lodash/isArray")), _react = _interopRequireWildcard(require("react")), _classnames = _interopRequireDefault(require("classnames")), _DataUtils = require_DataUtils();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!!o) {
        if (typeof o == "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
    }
    function _arrayLikeToArray(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(arr)))) {
        var _arr = [], _n = !0, _d = !1, _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    function defaultFormatter(value) {
      return (0, _isArray2.default)(value) && (0, _DataUtils.isNumOrStr)(value[0]) && (0, _DataUtils.isNumOrStr)(value[1]) ? value.join(" ~ ") : value;
    }
    var DefaultTooltipContent = /* @__PURE__ */ function(_PureComponent) {
      _inherits(DefaultTooltipContent2, _PureComponent);
      var _super = _createSuper(DefaultTooltipContent2);
      function DefaultTooltipContent2() {
        return _classCallCheck(this, DefaultTooltipContent2), _super.apply(this, arguments);
      }
      return _createClass(DefaultTooltipContent2, [{
        key: "renderContent",
        value: function() {
          var _this$props = this.props, payload = _this$props.payload, separator = _this$props.separator, formatter = _this$props.formatter, itemStyle = _this$props.itemStyle, itemSorter = _this$props.itemSorter;
          if (payload && payload.length) {
            var listStyle = {
              padding: 0,
              margin: 0
            }, items = (itemSorter ? (0, _sortBy2.default)(payload, itemSorter) : payload).map(function(entry2, i) {
              if (entry2.type === "none")
                return null;
              var finalItemStyle = _objectSpread3({
                display: "block",
                paddingTop: 4,
                paddingBottom: 4,
                color: entry2.color || "#000"
              }, itemStyle), finalFormatter = entry2.formatter || formatter || defaultFormatter, value = entry2.value, name = entry2.name;
              if (finalFormatter && value != null && name != null) {
                var formatted = finalFormatter(value, name, entry2, i, payload);
                if (Array.isArray(formatted)) {
                  var _ref = formatted, _ref2 = _slicedToArray(_ref, 2);
                  value = _ref2[0], name = _ref2[1];
                } else
                  value = formatted;
              }
              return /* @__PURE__ */ _react.default.createElement("li", {
                className: "recharts-tooltip-item",
                key: "tooltip-item-".concat(i),
                style: finalItemStyle
              }, (0, _DataUtils.isNumOrStr)(name) ? /* @__PURE__ */ _react.default.createElement("span", {
                className: "recharts-tooltip-item-name"
              }, name) : null, (0, _DataUtils.isNumOrStr)(name) ? /* @__PURE__ */ _react.default.createElement("span", {
                className: "recharts-tooltip-item-separator"
              }, separator) : null, /* @__PURE__ */ _react.default.createElement("span", {
                className: "recharts-tooltip-item-value"
              }, value), /* @__PURE__ */ _react.default.createElement("span", {
                className: "recharts-tooltip-item-unit"
              }, entry2.unit || ""));
            });
            return /* @__PURE__ */ _react.default.createElement("ul", {
              className: "recharts-tooltip-item-list",
              style: listStyle
            }, items);
          }
          return null;
        }
      }, {
        key: "render",
        value: function() {
          var _this$props2 = this.props, wrapperClassName = _this$props2.wrapperClassName, contentStyle = _this$props2.contentStyle, labelClassName = _this$props2.labelClassName, labelStyle = _this$props2.labelStyle, label = _this$props2.label, labelFormatter = _this$props2.labelFormatter, payload = _this$props2.payload, finalStyle = _objectSpread3({
            margin: 0,
            padding: 10,
            backgroundColor: "#fff",
            border: "1px solid #ccc",
            whiteSpace: "nowrap"
          }, contentStyle), finalLabelStyle = _objectSpread3({
            margin: 0
          }, labelStyle), hasLabel = !(0, _isNil2.default)(label), finalLabel = hasLabel ? label : "", wrapperCN = (0, _classnames.default)("recharts-default-tooltip", wrapperClassName), labelCN = (0, _classnames.default)("recharts-tooltip-label", labelClassName);
          return hasLabel && labelFormatter && payload !== void 0 && payload !== null && (finalLabel = labelFormatter(label, payload)), /* @__PURE__ */ _react.default.createElement("div", {
            className: wrapperCN,
            style: finalStyle
          }, /* @__PURE__ */ _react.default.createElement("p", {
            className: labelCN,
            style: finalLabelStyle
          }, /* @__PURE__ */ _react.default.isValidElement(finalLabel) ? finalLabel : "".concat(finalLabel)), this.renderContent());
        }
      }]), DefaultTooltipContent2;
    }(_react.PureComponent);
    exports.DefaultTooltipContent = DefaultTooltipContent;
    DefaultTooltipContent.displayName = "DefaultTooltipContent";
    DefaultTooltipContent.defaultProps = {
      separator: " : ",
      contentStyle: {},
      itemStyle: {},
      labelStyle: {}
    };
  }
});

// node_modules/recharts/lib/util/Global.js
var require_Global = __commonJS({
  "node_modules/recharts/lib/util/Global.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Global = void 0;
    var parseIsSsrByDefault = function() {
      return !(typeof window < "u" && window.document && window.document.createElement && window.setTimeout);
    }, Global = {
      isSsr: parseIsSsrByDefault(),
      get: function(key) {
        return Global[key];
      },
      set: function(key, value) {
        if (typeof key == "string")
          Global[key] = value;
        else {
          var keys = Object.keys(key);
          keys && keys.length && keys.forEach(function(k) {
            Global[k] = key[k];
          });
        }
      }
    };
    exports.Global = Global;
  }
});

// node_modules/recharts/lib/component/Tooltip.js
var require_Tooltip = __commonJS({
  "node_modules/recharts/lib/component/Tooltip.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Tooltip = void 0;
    var _isNil2 = _interopRequireDefault(require("lodash/isNil")), _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _uniqBy2 = _interopRequireDefault(require("lodash/uniqBy")), _react = _interopRequireWildcard(require("react")), _reactSmooth = require("react-smooth"), _classnames = _interopRequireDefault(require("classnames")), _DefaultTooltipContent = require_DefaultTooltipContent(), _Global = require_Global(), _DataUtils = require_DataUtils();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var CLS_PREFIX = "recharts-tooltip-wrapper", EPS = 1;
    function defaultUniqBy(entry2) {
      return entry2.dataKey;
    }
    function getUniqPayload(option, payload) {
      return option === !0 ? (0, _uniqBy2.default)(payload, defaultUniqBy) : (0, _isFunction2.default)(option) ? (0, _uniqBy2.default)(payload, option) : payload;
    }
    function renderContent(content, props) {
      return /* @__PURE__ */ _react.default.isValidElement(content) ? /* @__PURE__ */ _react.default.cloneElement(content, props) : (0, _isFunction2.default)(content) ? /* @__PURE__ */ _react.default.createElement(content, props) : /* @__PURE__ */ _react.default.createElement(_DefaultTooltipContent.DefaultTooltipContent, props);
    }
    var Tooltip = /* @__PURE__ */ function(_PureComponent) {
      _inherits(Tooltip2, _PureComponent);
      var _super = _createSuper(Tooltip2);
      function Tooltip2() {
        var _this;
        _classCallCheck(this, Tooltip2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        return _this = _super.call.apply(_super, [this].concat(args)), _this.state = {
          boxWidth: -1,
          boxHeight: -1,
          dismissed: !1,
          dismissedAtCoordinate: {
            x: 0,
            y: 0
          }
        }, _this.wrapperNode = void 0, _this.getTranslate = function(_ref) {
          var key = _ref.key, tooltipDimension = _ref.tooltipDimension, viewBoxDimension = _ref.viewBoxDimension, _this$props = _this.props, allowEscapeViewBox = _this$props.allowEscapeViewBox, reverseDirection = _this$props.reverseDirection, coordinate = _this$props.coordinate, offset = _this$props.offset, position = _this$props.position, viewBox = _this$props.viewBox;
          if (position && (0, _DataUtils.isNumber)(position[key]))
            return position[key];
          var negative = coordinate[key] - tooltipDimension - offset, positive = coordinate[key] + offset;
          if (allowEscapeViewBox[key])
            return reverseDirection[key] ? negative : positive;
          if (reverseDirection[key]) {
            var tooltipBoundary = negative, viewBoxBoundary = viewBox[key];
            return tooltipBoundary < viewBoxBoundary ? Math.max(positive, viewBox[key]) : Math.max(negative, viewBox[key]);
          } else {
            var _tooltipBoundary = positive + tooltipDimension, _viewBoxBoundary = viewBox[key] + viewBoxDimension;
            return _tooltipBoundary > _viewBoxBoundary ? Math.max(negative, viewBox[key]) : Math.max(positive, viewBox[key]);
          }
        }, _this;
      }
      return _createClass(Tooltip2, [{
        key: "componentDidMount",
        value: function() {
          this.updateBBox();
        }
      }, {
        key: "componentDidUpdate",
        value: function() {
          this.updateBBox();
        }
      }, {
        key: "updateBBox",
        value: function() {
          var _this$state = this.state, boxWidth = _this$state.boxWidth, boxHeight = _this$state.boxHeight, dismissed = _this$state.dismissed;
          if (dismissed ? (this.wrapperNode.blur(), (this.props.coordinate.x !== this.state.dismissedAtCoordinate.x || this.props.coordinate.y !== this.state.dismissedAtCoordinate.y) && this.setState({
            dismissed: !1
          })) : this.wrapperNode.focus({
            preventScroll: !0
          }), this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
            var box = this.wrapperNode.getBoundingClientRect();
            (Math.abs(box.width - boxWidth) > EPS || Math.abs(box.height - boxHeight) > EPS) && this.setState({
              boxWidth: box.width,
              boxHeight: box.height
            });
          } else
            (boxWidth !== -1 || boxHeight !== -1) && this.setState({
              boxWidth: -1,
              boxHeight: -1
            });
        }
      }, {
        key: "render",
        value: function() {
          var _classNames, _this2 = this, _this$props2 = this.props, payload = _this$props2.payload, isAnimationActive = _this$props2.isAnimationActive, animationDuration = _this$props2.animationDuration, animationEasing = _this$props2.animationEasing, filterNull = _this$props2.filterNull, payloadUniqBy = _this$props2.payloadUniqBy, finalPayload = getUniqPayload(payloadUniqBy, filterNull && payload && payload.length ? payload.filter(function(entry2) {
            return !(0, _isNil2.default)(entry2.value);
          }) : payload), hasPayload = finalPayload && finalPayload.length, _this$props3 = this.props, content = _this$props3.content, viewBox = _this$props3.viewBox, coordinate = _this$props3.coordinate, position = _this$props3.position, active = _this$props3.active, wrapperStyle = _this$props3.wrapperStyle, outerStyle = _objectSpread3({
            pointerEvents: "none",
            visibility: !this.state.dismissed && active && hasPayload ? "visible" : "hidden",
            position: "absolute",
            top: 0,
            left: 0
          }, wrapperStyle), translateX, translateY;
          if (position && (0, _DataUtils.isNumber)(position.x) && (0, _DataUtils.isNumber)(position.y))
            translateX = position.x, translateY = position.y;
          else {
            var _this$state2 = this.state, boxWidth = _this$state2.boxWidth, boxHeight = _this$state2.boxHeight;
            boxWidth > 0 && boxHeight > 0 && coordinate ? (translateX = this.getTranslate({
              key: "x",
              tooltipDimension: boxWidth,
              viewBoxDimension: viewBox.width
            }), translateY = this.getTranslate({
              key: "y",
              tooltipDimension: boxHeight,
              viewBoxDimension: viewBox.height
            })) : outerStyle.visibility = "hidden";
          }
          outerStyle = _objectSpread3(_objectSpread3({}, (0, _reactSmooth.translateStyle)({
            transform: this.props.useTranslate3d ? "translate3d(".concat(translateX, "px, ").concat(translateY, "px, 0)") : "translate(".concat(translateX, "px, ").concat(translateY, "px)")
          })), outerStyle), isAnimationActive && active && (outerStyle = _objectSpread3(_objectSpread3({}, (0, _reactSmooth.translateStyle)({
            transition: "transform ".concat(animationDuration, "ms ").concat(animationEasing)
          })), outerStyle));
          var cls = (0, _classnames.default)(CLS_PREFIX, (_classNames = {}, _defineProperty3(_classNames, "".concat(CLS_PREFIX, "-right"), (0, _DataUtils.isNumber)(translateX) && coordinate && (0, _DataUtils.isNumber)(coordinate.x) && translateX >= coordinate.x), _defineProperty3(_classNames, "".concat(CLS_PREFIX, "-left"), (0, _DataUtils.isNumber)(translateX) && coordinate && (0, _DataUtils.isNumber)(coordinate.x) && translateX < coordinate.x), _defineProperty3(_classNames, "".concat(CLS_PREFIX, "-bottom"), (0, _DataUtils.isNumber)(translateY) && coordinate && (0, _DataUtils.isNumber)(coordinate.y) && translateY >= coordinate.y), _defineProperty3(_classNames, "".concat(CLS_PREFIX, "-top"), (0, _DataUtils.isNumber)(translateY) && coordinate && (0, _DataUtils.isNumber)(coordinate.y) && translateY < coordinate.y), _classNames));
          return /* @__PURE__ */ _react.default.createElement("div", {
            tabIndex: -1,
            role: "dialog",
            onKeyDown: function(event) {
              event.key === "Escape" && _this2.setState({
                dismissed: !0,
                dismissedAtCoordinate: _objectSpread3(_objectSpread3({}, _this2.state.dismissedAtCoordinate), {}, {
                  x: _this2.props.coordinate.x,
                  y: _this2.props.coordinate.y
                })
              });
            },
            className: cls,
            style: outerStyle,
            ref: function(node) {
              _this2.wrapperNode = node;
            }
          }, renderContent(content, _objectSpread3(_objectSpread3({}, this.props), {}, {
            payload: finalPayload
          })));
        }
      }]), Tooltip2;
    }(_react.PureComponent);
    exports.Tooltip = Tooltip;
    Tooltip.displayName = "Tooltip";
    Tooltip.defaultProps = {
      active: !1,
      allowEscapeViewBox: {
        x: !1,
        y: !1
      },
      reverseDirection: {
        x: !1,
        y: !1
      },
      offset: 10,
      viewBox: {
        x1: 0,
        x2: 0,
        y1: 0,
        y2: 0
      },
      coordinate: {
        x: 0,
        y: 0
      },
      cursorStyle: {},
      separator: " : ",
      wrapperStyle: {},
      contentStyle: {},
      itemStyle: {},
      labelStyle: {},
      cursor: !0,
      trigger: "hover",
      isAnimationActive: !_Global.Global.isSsr,
      animationEasing: "ease",
      animationDuration: 400,
      filterNull: !0,
      useTranslate3d: !1
    };
  }
});

// node_modules/recharts/lib/util/LogUtils.js
var require_LogUtils = __commonJS({
  "node_modules/recharts/lib/util/LogUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.warn = void 0;
    var isDev = !0, warn = function(condition, format) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++)
        args[_key - 2] = arguments[_key];
      if (isDev && typeof console < "u" && console.warn && (format === void 0 && console.warn("LogUtils requires an error message argument"), !condition))
        if (format === void 0)
          console.warn("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
        else {
          var argIndex = 0;
          console.warn(format.replace(/%s/g, function() {
            return args[argIndex++];
          }));
        }
    };
    exports.warn = warn;
  }
});

// node_modules/recharts/lib/component/ResponsiveContainer.js
var require_ResponsiveContainer = __commonJS({
  "node_modules/recharts/lib/component/ResponsiveContainer.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.ResponsiveContainer = void 0;
    var _debounce2 = _interopRequireDefault(require("lodash/debounce")), _classnames = _interopRequireDefault(require("classnames")), _react = _interopRequireWildcard(require("react")), _reactResizeDetector = _interopRequireDefault(require("react-resize-detector")), _DataUtils = require_DataUtils(), _LogUtils = require_LogUtils();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!!o) {
        if (typeof o == "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
    }
    function _arrayLikeToArray(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(arr)))) {
        var _arr = [], _n = !0, _d = !1, _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    var ResponsiveContainer2 = /* @__PURE__ */ (0, _react.forwardRef)(function(_ref, ref) {
      var aspect = _ref.aspect, _ref$width = _ref.width, width = _ref$width === void 0 ? "100%" : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? "100%" : _ref$height, minWidth = _ref.minWidth, minHeight = _ref.minHeight, maxHeight = _ref.maxHeight, children = _ref.children, _ref$debounce = _ref.debounce, debounce = _ref$debounce === void 0 ? 0 : _ref$debounce, id = _ref.id, className = _ref.className, _useState = (0, _react.useState)({
        containerWidth: -1,
        containerHeight: -1
      }), _useState2 = _slicedToArray(_useState, 2), sizes = _useState2[0], setSizes = _useState2[1], containerRef = (0, _react.useRef)(null);
      (0, _react.useImperativeHandle)(ref, function() {
        return containerRef;
      }, [containerRef]);
      var _useState3 = (0, _react.useState)(!1), _useState4 = _slicedToArray(_useState3, 2), mounted = _useState4[0], setMounted = _useState4[1], getContainerSize = function() {
        return containerRef.current ? {
          containerWidth: containerRef.current.clientWidth,
          containerHeight: containerRef.current.clientHeight
        } : null;
      }, updateDimensionsImmediate = function() {
        if (!!mounted) {
          var newSize = getContainerSize();
          if (newSize) {
            var oldWidth = sizes.containerWidth, oldHeight = sizes.containerHeight, containerWidth = newSize.containerWidth, containerHeight = newSize.containerHeight;
            (containerWidth !== oldWidth || containerHeight !== oldHeight) && setSizes({
              containerWidth,
              containerHeight
            });
          }
        }
      }, handleResize = debounce > 0 ? (0, _debounce2.default)(updateDimensionsImmediate, debounce) : updateDimensionsImmediate, renderChart = function() {
        var containerWidth = sizes.containerWidth, containerHeight = sizes.containerHeight;
        if (containerWidth < 0 || containerHeight < 0)
          return null;
        (0, _LogUtils.warn)((0, _DataUtils.isPercent)(width) || (0, _DataUtils.isPercent)(height), `The width(%s) and height(%s) are both fixed numbers,
       maybe you don't need to use a ResponsiveContainer.`, width, height), (0, _LogUtils.warn)(!aspect || aspect > 0, "The aspect(%s) must be greater than zero.", aspect);
        var calculatedWidth = (0, _DataUtils.isPercent)(width) ? containerWidth : width, calculatedHeight = (0, _DataUtils.isPercent)(height) ? containerHeight : height;
        return aspect && aspect > 0 && (calculatedWidth ? calculatedHeight = calculatedWidth / aspect : calculatedHeight && (calculatedWidth = calculatedHeight * aspect), maxHeight && calculatedHeight > maxHeight && (calculatedHeight = maxHeight)), (0, _LogUtils.warn)(calculatedWidth > 0 || calculatedHeight > 0, `The width(%s) and height(%s) of chart should be greater than 0,
       please check the style of container, or the props width(%s) and height(%s),
       or add a minWidth(%s) or minHeight(%s) or use aspect(%s) to control the
       height and width.`, calculatedWidth, calculatedHeight, width, height, minWidth, minHeight, aspect), /* @__PURE__ */ (0, _react.cloneElement)(children, {
          width: calculatedWidth,
          height: calculatedHeight
        });
      };
      (0, _react.useEffect)(function() {
        if (mounted) {
          var size = getContainerSize();
          size && setSizes(size);
        }
      }, [mounted]), (0, _react.useEffect)(function() {
        setMounted(!0);
      }, []);
      var style = {
        width,
        height,
        minWidth,
        minHeight,
        maxHeight
      };
      return /* @__PURE__ */ _react.default.createElement(_reactResizeDetector.default, {
        handleWidth: !0,
        handleHeight: !0,
        onResize: handleResize,
        targetRef: containerRef
      }, /* @__PURE__ */ _react.default.createElement("div", _extends({}, id != null ? {
        id: "".concat(id)
      } : {}, {
        className: (0, _classnames.default)("recharts-responsive-container", className),
        style,
        ref: containerRef
      }), renderChart()));
    });
    exports.ResponsiveContainer = ResponsiveContainer2;
  }
});

// node_modules/recharts/lib/component/Cell.js
var require_Cell = __commonJS({
  "node_modules/recharts/lib/component/Cell.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Cell = void 0;
    var Cell = function(_props) {
      return null;
    };
    exports.Cell = Cell;
    Cell.displayName = "Cell";
  }
});

// node_modules/recharts/lib/util/DOMUtils.js
var require_DOMUtils = __commonJS({
  "node_modules/recharts/lib/util/DOMUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.calculateChartCoordinate = exports.getOffset = exports.getStringSize = exports.getStyleString = void 0;
    var _Global = require_Global();
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!!o) {
        if (typeof o == "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
    }
    function _iterableToArray(iter) {
      if (typeof Symbol < "u" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    var stringCache = {
      widthCache: {},
      cacheCount: 0
    }, MAX_CACHE_NUM = 2e3, SPAN_STYLE = {
      position: "absolute",
      top: "-20000px",
      left: 0,
      padding: 0,
      margin: 0,
      border: "none",
      whiteSpace: "pre"
    }, STYLE_LIST = ["minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height", "top", "left", "fontSize", "lineHeight", "padding", "margin", "paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom"], MEASUREMENT_SPAN_ID = "recharts_measurement_span";
    function autoCompleteStyle(name, value) {
      return STYLE_LIST.indexOf(name) >= 0 && value === +value ? "".concat(value, "px") : value;
    }
    function camelToMiddleLine(text) {
      var strs = text.split(""), formatStrs = strs.reduce(function(result, entry2) {
        return entry2 === entry2.toUpperCase() ? [].concat(_toConsumableArray(result), ["-", entry2.toLowerCase()]) : [].concat(_toConsumableArray(result), [entry2]);
      }, []);
      return formatStrs.join("");
    }
    var getStyleString = function(style) {
      return Object.keys(style).reduce(function(result, s) {
        return "".concat(result).concat(camelToMiddleLine(s), ":").concat(autoCompleteStyle(s, style[s]), ";");
      }, "");
    };
    exports.getStyleString = getStyleString;
    var getStringSize = function(text) {
      var style = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (text == null || _Global.Global.isSsr)
        return {
          width: 0,
          height: 0
        };
      var str = "".concat(text), styleString = getStyleString(style), cacheKey = "".concat(str, "-").concat(styleString);
      if (stringCache.widthCache[cacheKey])
        return stringCache.widthCache[cacheKey];
      try {
        var measurementSpan = document.getElementById(MEASUREMENT_SPAN_ID);
        measurementSpan || (measurementSpan = document.createElement("span"), measurementSpan.setAttribute("id", MEASUREMENT_SPAN_ID), measurementSpan.setAttribute("aria-hidden", "true"), document.body.appendChild(measurementSpan));
        var measurementSpanStyle = _objectSpread3(_objectSpread3({}, SPAN_STYLE), style);
        Object.keys(measurementSpanStyle).map(function(styleKey) {
          return measurementSpan.style[styleKey] = measurementSpanStyle[styleKey], styleKey;
        }), measurementSpan.textContent = str;
        var rect = measurementSpan.getBoundingClientRect(), result = {
          width: rect.width,
          height: rect.height
        };
        return stringCache.widthCache[cacheKey] = result, ++stringCache.cacheCount > MAX_CACHE_NUM && (stringCache.cacheCount = 0, stringCache.widthCache = {}), result;
      } catch {
        return {
          width: 0,
          height: 0
        };
      }
    };
    exports.getStringSize = getStringSize;
    var getOffset = function(el) {
      var html = el.ownerDocument.documentElement, box = {
        top: 0,
        left: 0
      };
      return typeof el.getBoundingClientRect < "u" && (box = el.getBoundingClientRect()), {
        top: box.top + window.pageYOffset - html.clientTop,
        left: box.left + window.pageXOffset - html.clientLeft
      };
    };
    exports.getOffset = getOffset;
    var calculateChartCoordinate = function(event, offset) {
      return {
        chartX: Math.round(event.pageX - offset.left),
        chartY: Math.round(event.pageY - offset.top)
      };
    };
    exports.calculateChartCoordinate = calculateChartCoordinate;
  }
});

// node_modules/recharts/lib/component/Text.js
var require_Text = __commonJS({
  "node_modules/recharts/lib/component/Text.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Text = void 0;
    var _isNil2 = _interopRequireDefault(require("lodash/isNil")), _react = _interopRequireWildcard(require("react")), _reduceCssCalc = _interopRequireDefault(require("reduce-css-calc")), _classnames = _interopRequireDefault(require("classnames")), _DataUtils = require_DataUtils(), _Global = require_Global(), _types = require_types(), _DOMUtils = require_DOMUtils();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose2(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source, key) || (target[key] = source[key]));
      }
      return target;
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!!o) {
        if (typeof o == "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
    }
    function _arrayLikeToArray(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(arr)))) {
        var _arr = [], _n = !0, _d = !1, _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    var BREAKING_SPACES = /[ \f\n\r\t\v\u2028\u2029]+/, calculateWordWidths = function(props) {
      try {
        var words = [];
        (0, _isNil2.default)(props.children) || (props.breakAll ? words = props.children.toString().split("") : words = props.children.toString().split(BREAKING_SPACES));
        var wordsWithComputedWidth = words.map(function(word) {
          return {
            word,
            width: (0, _DOMUtils.getStringSize)(word, props.style).width
          };
        }), spaceWidth = props.breakAll ? 0 : (0, _DOMUtils.getStringSize)("\xA0", props.style).width;
        return {
          wordsWithComputedWidth,
          spaceWidth
        };
      } catch {
        return null;
      }
    }, calculateWordsByLines = function(props, initialWordsWithComputedWith, spaceWidth, lineWidth, scaleToFit) {
      var shouldLimitLines = (0, _DataUtils.isNumber)(props.maxLines), text = props.children, calculate = function() {
        var words = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        return words.reduce(function(result2, _ref) {
          var word = _ref.word, width = _ref.width, currentLine = result2[result2.length - 1];
          if (currentLine && (lineWidth == null || scaleToFit || currentLine.width + width + spaceWidth < lineWidth))
            currentLine.words.push(word), currentLine.width += width + spaceWidth;
          else {
            var newLine = {
              words: [word],
              width
            };
            result2.push(newLine);
          }
          return result2;
        }, []);
      }, originalResult = calculate(initialWordsWithComputedWith), findLongestLine = function(words) {
        return words.reduce(function(a, b) {
          return a.width > b.width ? a : b;
        });
      };
      if (!shouldLimitLines)
        return originalResult;
      for (var suffix = "\u2026", checkOverflow = function(index) {
        var tempText = text.slice(0, index), words = calculateWordWidths(_objectSpread3(_objectSpread3({}, props), {}, {
          children: tempText + suffix
        })).wordsWithComputedWidth, result2 = calculate(words), doesOverflow = result2.length > props.maxLines || findLongestLine(result2).width > lineWidth;
        return [doesOverflow, result2];
      }, start = 0, end = text.length - 1, iterations = 0, trimmedResult; start <= end && iterations <= text.length - 1; ) {
        var middle = Math.floor((start + end) / 2), prev = middle - 1, _checkOverflow = checkOverflow(prev), _checkOverflow2 = _slicedToArray(_checkOverflow, 2), doesPrevOverflow = _checkOverflow2[0], result = _checkOverflow2[1], _checkOverflow3 = checkOverflow(middle), _checkOverflow4 = _slicedToArray(_checkOverflow3, 1), doesMiddleOverflow = _checkOverflow4[0];
        if (!doesPrevOverflow && !doesMiddleOverflow && (start = middle + 1), doesPrevOverflow && doesMiddleOverflow && (end = middle - 1), !doesPrevOverflow && doesMiddleOverflow) {
          trimmedResult = result;
          break;
        }
        iterations++;
      }
      return trimmedResult || originalResult;
    }, getWordsWithoutCalculate = function(children) {
      var words = (0, _isNil2.default)(children) ? [] : children.toString().split(BREAKING_SPACES);
      return [{
        words
      }];
    }, getWordsByLines = function(props, needCalculate) {
      if ((props.width || props.scaleToFit) && !_Global.Global.isSsr) {
        var wordsWithComputedWidth, spaceWidth;
        if (needCalculate) {
          var wordWidths = calculateWordWidths(props);
          if (wordWidths) {
            var wcw = wordWidths.wordsWithComputedWidth, sw = wordWidths.spaceWidth;
            wordsWithComputedWidth = wcw, spaceWidth = sw;
          } else
            return getWordsWithoutCalculate(props.children);
          return calculateWordsByLines(props, wordsWithComputedWidth, spaceWidth, props.width, props.scaleToFit);
        }
      }
      return getWordsWithoutCalculate(props.children);
    }, Text2 = /* @__PURE__ */ function(_Component) {
      _inherits(Text3, _Component);
      var _super = _createSuper(Text3);
      function Text3() {
        var _this;
        _classCallCheck(this, Text3);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        return _this = _super.call.apply(_super, [this].concat(args)), _this.state = {}, _this;
      }
      return _createClass(Text3, [{
        key: "render",
        value: function() {
          var _this$props = this.props, dx = _this$props.dx, dy = _this$props.dy, textAnchor = _this$props.textAnchor, verticalAnchor = _this$props.verticalAnchor, scaleToFit = _this$props.scaleToFit, angle = _this$props.angle, lineHeight = _this$props.lineHeight, capHeight = _this$props.capHeight, className = _this$props.className, breakAll = _this$props.breakAll, textProps = _objectWithoutProperties2(_this$props, ["dx", "dy", "textAnchor", "verticalAnchor", "scaleToFit", "angle", "lineHeight", "capHeight", "className", "breakAll"]), wordsByLines = this.state.wordsByLines;
          if (!(0, _DataUtils.isNumOrStr)(textProps.x) || !(0, _DataUtils.isNumOrStr)(textProps.y))
            return null;
          var x = textProps.x + ((0, _DataUtils.isNumber)(dx) ? dx : 0), y = textProps.y + ((0, _DataUtils.isNumber)(dy) ? dy : 0), startDy;
          switch (verticalAnchor) {
            case "start":
              startDy = (0, _reduceCssCalc.default)("calc(".concat(capHeight, ")"));
              break;
            case "middle":
              startDy = (0, _reduceCssCalc.default)("calc(".concat((wordsByLines.length - 1) / 2, " * -").concat(lineHeight, " + (").concat(capHeight, " / 2))"));
              break;
            default:
              startDy = (0, _reduceCssCalc.default)("calc(".concat(wordsByLines.length - 1, " * -").concat(lineHeight, ")"));
              break;
          }
          var transforms = [];
          if (scaleToFit) {
            var lineWidth = wordsByLines[0].width, width = this.props.width;
            transforms.push("scale(".concat(((0, _DataUtils.isNumber)(width) ? width / lineWidth : 1) / lineWidth, ")"));
          }
          return angle && transforms.push("rotate(".concat(angle, ", ").concat(x, ", ").concat(y, ")")), transforms.length && (textProps.transform = transforms.join(" ")), /* @__PURE__ */ _react.default.createElement("text", _extends({}, (0, _types.filterProps)(textProps, !0), {
            x,
            y,
            className: (0, _classnames.default)("recharts-text", className),
            textAnchor,
            fill: textProps.fill.includes("url") ? Text3.defaultProps.fill : textProps.fill
          }), wordsByLines.map(function(line, index) {
            return /* @__PURE__ */ _react.default.createElement("tspan", {
              x,
              dy: index === 0 ? startDy : lineHeight,
              key: index
            }, line.words.join(breakAll ? "" : " "));
          }));
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function(nextProps, prevState) {
          if (nextProps.width !== prevState.prevWidth || nextProps.scaleToFit !== prevState.prevScaleToFit || nextProps.children !== prevState.prevChildren || nextProps.style !== prevState.prevStyle || nextProps.breakAll !== prevState.prevBreakAll) {
            var needCalculate = nextProps.children !== prevState.prevChildren || nextProps.style !== prevState.prevStyle || nextProps.breakAll !== prevState.prevBreakAll;
            return {
              prevWidth: nextProps.width,
              prevScaleToFit: nextProps.scaleToFit,
              prevChildren: nextProps.children,
              prevStyle: nextProps.style,
              wordsByLines: getWordsByLines(nextProps, needCalculate)
            };
          }
          return null;
        }
      }]), Text3;
    }(_react.Component);
    exports.Text = Text2;
    Text2.defaultProps = {
      x: 0,
      y: 0,
      lineHeight: "1em",
      capHeight: "0.71em",
      scaleToFit: !1,
      textAnchor: "start",
      verticalAnchor: "end",
      fill: "#808080"
    };
  }
});

// node_modules/recharts/lib/util/ShallowEqual.js
var require_ShallowEqual = __commonJS({
  "node_modules/recharts/lib/util/ShallowEqual.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.shallowEqual = shallowEqual;
    function shallowEqual(a, b) {
      for (var key in a)
        if ({}.hasOwnProperty.call(a, key) && (!{}.hasOwnProperty.call(b, key) || a[key] !== b[key]))
          return !1;
      for (var _key in b)
        if ({}.hasOwnProperty.call(b, _key) && !{}.hasOwnProperty.call(a, _key))
          return !1;
      return !0;
    }
  }
});

// node_modules/recharts/lib/util/ReactUtils.js
var require_ReactUtils = __commonJS({
  "node_modules/recharts/lib/util/ReactUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.parseChildIndex = exports.getReactEventByType = exports.renderByOrder = exports.isSingleChildEqual = exports.isChildrenEqual = exports.filterSvgElements = exports.validateWidthHeight = exports.withoutType = exports.findChildByType = exports.findAllByType = exports.toArray = exports.getDisplayName = exports.TOOLTIP_TYPES = exports.LEGEND_TYPES = exports.SCALE_TYPES = void 0;
    var _isString2 = _interopRequireDefault(require("lodash/isString")), _get2 = _interopRequireDefault(require("lodash/get")), _isNil2 = _interopRequireDefault(require("lodash/isNil")), _isArray2 = _interopRequireDefault(require("lodash/isArray")), _react = require("react"), _reactIs = require("react-is"), _DataUtils = require_DataUtils(), _ShallowEqual = require_ShallowEqual();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose2(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source, key) || (target[key] = source[key]));
      }
      return target;
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    var REACT_BROWSER_EVENT_MAP = {
      click: "onClick",
      mousedown: "onMouseDown",
      mouseup: "onMouseUp",
      mouseover: "onMouseOver",
      mousemove: "onMouseMove",
      mouseout: "onMouseOut",
      mouseenter: "onMouseEnter",
      mouseleave: "onMouseLeave",
      touchcancel: "onTouchCancel",
      touchend: "onTouchEnd",
      touchmove: "onTouchMove",
      touchstart: "onTouchStart"
    }, SCALE_TYPES = ["auto", "linear", "pow", "sqrt", "log", "identity", "time", "band", "point", "ordinal", "quantile", "quantize", "utc", "sequential", "threshold"];
    exports.SCALE_TYPES = SCALE_TYPES;
    var LEGEND_TYPES = ["plainline", "line", "square", "rect", "circle", "cross", "diamond", "star", "triangle", "wye", "none"];
    exports.LEGEND_TYPES = LEGEND_TYPES;
    var TOOLTIP_TYPES = ["none"];
    exports.TOOLTIP_TYPES = TOOLTIP_TYPES;
    var getDisplayName = function(Comp) {
      return typeof Comp == "string" ? Comp : Comp ? Comp.displayName || Comp.name || "Component" : "";
    };
    exports.getDisplayName = getDisplayName;
    var lastChildren = null, lastResult = null, toArray = function toArray2(children) {
      if (children === lastChildren && (0, _isArray2.default)(lastResult))
        return lastResult;
      var result = [];
      return _react.Children.forEach(children, function(child) {
        (0, _isNil2.default)(child) || ((0, _reactIs.isFragment)(child) ? result = result.concat(toArray2(child.props.children)) : result.push(child));
      }), lastResult = result, lastChildren = children, result;
    };
    exports.toArray = toArray;
    var findAllByType = function(children, type) {
      var result = [], types = [];
      return (0, _isArray2.default)(type) ? types = type.map(function(t) {
        return getDisplayName(t);
      }) : types = [getDisplayName(type)], toArray(children).forEach(function(child) {
        var childType = (0, _get2.default)(child, "type.displayName") || (0, _get2.default)(child, "type.name");
        types.indexOf(childType) !== -1 && result.push(child);
      }), result;
    };
    exports.findAllByType = findAllByType;
    var findChildByType = function(children, type) {
      var result = findAllByType(children, type);
      return result && result[0];
    };
    exports.findChildByType = findChildByType;
    var withoutType = function(children, type) {
      var newChildren = [], types;
      return (0, _isArray2.default)(type) ? types = type.map(function(t) {
        return getDisplayName(t);
      }) : types = [getDisplayName(type)], toArray(children).forEach(function(child) {
        var displayName = (0, _get2.default)(child, "type.displayName");
        displayName && types.indexOf(displayName) !== -1 || newChildren.push(child);
      }), newChildren;
    };
    exports.withoutType = withoutType;
    var validateWidthHeight = function(el) {
      if (!el || !el.props)
        return !1;
      var _el$props = el.props, width = _el$props.width, height = _el$props.height;
      return !(!(0, _DataUtils.isNumber)(width) || width <= 0 || !(0, _DataUtils.isNumber)(height) || height <= 0);
    };
    exports.validateWidthHeight = validateWidthHeight;
    var SVG_TAGS = ["a", "altGlyph", "altGlyphDef", "altGlyphItem", "animate", "animateColor", "animateMotion", "animateTransform", "circle", "clipPath", "color-profile", "cursor", "defs", "desc", "ellipse", "feBlend", "feColormatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "font", "font-face", "font-face-format", "font-face-name", "font-face-url", "foreignObject", "g", "glyph", "glyphRef", "hkern", "image", "line", "lineGradient", "marker", "mask", "metadata", "missing-glyph", "mpath", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "script", "set", "stop", "style", "svg", "switch", "symbol", "text", "textPath", "title", "tref", "tspan", "use", "view", "vkern"], isSvgElement = function(child) {
      return child && child.type && (0, _isString2.default)(child.type) && SVG_TAGS.indexOf(child.type) >= 0;
    }, filterSvgElements = function(children) {
      var svgElements = [];
      return toArray(children).forEach(function(entry2) {
        isSvgElement(entry2) && svgElements.push(entry2);
      }), svgElements;
    };
    exports.filterSvgElements = filterSvgElements;
    var isChildrenEqual = function isChildrenEqual2(nextChildren, prevChildren) {
      if (nextChildren === prevChildren)
        return !0;
      var count = _react.Children.count(nextChildren);
      if (count !== _react.Children.count(prevChildren))
        return !1;
      if (count === 0)
        return !0;
      if (count === 1)
        return isSingleChildEqual((0, _isArray2.default)(nextChildren) ? nextChildren[0] : nextChildren, (0, _isArray2.default)(prevChildren) ? prevChildren[0] : prevChildren);
      for (var i = 0; i < count; i++) {
        var nextChild = nextChildren[i], prevChild = prevChildren[i];
        if ((0, _isArray2.default)(nextChild) || (0, _isArray2.default)(prevChild)) {
          if (!isChildrenEqual2(nextChild, prevChild))
            return !1;
        } else if (!isSingleChildEqual(nextChild, prevChild))
          return !1;
      }
      return !0;
    };
    exports.isChildrenEqual = isChildrenEqual;
    var isSingleChildEqual = function(nextChild, prevChild) {
      if ((0, _isNil2.default)(nextChild) && (0, _isNil2.default)(prevChild))
        return !0;
      if (!(0, _isNil2.default)(nextChild) && !(0, _isNil2.default)(prevChild)) {
        var _ref = nextChild.props || {}, nextChildren = _ref.children, nextProps = _objectWithoutProperties2(_ref, ["children"]), _ref2 = prevChild.props || {}, prevChildren = _ref2.children, prevProps = _objectWithoutProperties2(_ref2, ["children"]);
        return nextChildren && prevChildren ? (0, _ShallowEqual.shallowEqual)(nextProps, prevProps) && isChildrenEqual(nextChildren, prevChildren) : !nextChildren && !prevChildren ? (0, _ShallowEqual.shallowEqual)(nextProps, prevProps) : !1;
      }
      return !1;
    };
    exports.isSingleChildEqual = isSingleChildEqual;
    var renderByOrder = function(children, renderMap) {
      var elements = [], record = {};
      return toArray(children).forEach(function(child, index) {
        if (isSvgElement(child))
          elements.push(child);
        else if (child) {
          var displayName = getDisplayName(child.type), _ref3 = renderMap[displayName] || {}, handler = _ref3.handler, once = _ref3.once;
          if (handler && (!once || !record[displayName])) {
            var results = handler(child, displayName, index);
            elements.push(results), record[displayName] = !0;
          }
        }
      }), elements;
    };
    exports.renderByOrder = renderByOrder;
    var getReactEventByType = function(e) {
      var type = e && e.type;
      return type && REACT_BROWSER_EVENT_MAP[type] ? REACT_BROWSER_EVENT_MAP[type] : null;
    };
    exports.getReactEventByType = getReactEventByType;
    var parseChildIndex = function(child, children) {
      return toArray(children).indexOf(child);
    };
    exports.parseChildIndex = parseChildIndex;
  }
});

// node_modules/recharts/lib/util/ChartUtils.js
var require_ChartUtils = __commonJS({
  "node_modules/recharts/lib/util/ChartUtils.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.getValueByDataKey = getValueByDataKey;
    exports.getDomainOfDataByKey = getDomainOfDataByKey;
    exports.getTooltipItem = exports.parseDomainOfCategoryAxis = exports.getBandSizeOfAxis = exports.parseSpecifiedDomain = exports.MAX_VALUE_REG = exports.MIN_VALUE_REG = exports.getDomainOfStackGroups = exports.getStackedDataOfItem = exports.getBaseValueOfBar = exports.getCateCoordinateOfBar = exports.getCateCoordinateOfLine = exports.getTicksOfScale = exports.calculateDomainOfTicks = exports.getStackGroupsByAxisId = exports.getStackedData = exports.offsetPositive = exports.offsetSign = exports.truncateByDomain = exports.findPositionOfBar = exports.checkDomainOfScale = exports.parseScale = exports.combineEventHandlers = exports.getTicksOfAxis = exports.getCoordinatesOfGrid = exports.isCategoricalAxis = exports.getDomainOfItemsWithSameAxis = exports.parseErrorBarsOfAxis = exports.getDomainOfErrorBars = exports.appendOffsetOfLegend = exports.getBarPosition = exports.getBarSizeList = exports.getLegendProps = exports.getMainColorOfGraphicItem = exports.calculateActiveTickIndex = void 0;
    var _isEqual2 = _interopRequireDefault(require("lodash/isEqual")), _sortBy2 = _interopRequireDefault(require("lodash/sortBy")), _isNaN2 = _interopRequireDefault(require("lodash/isNaN")), _upperFirst2 = _interopRequireDefault(require("lodash/upperFirst")), _isString2 = _interopRequireDefault(require("lodash/isString")), _isArray2 = _interopRequireDefault(require("lodash/isArray")), _max2 = _interopRequireDefault(require("lodash/max")), _min2 = _interopRequireDefault(require("lodash/min")), _flatMap2 = _interopRequireDefault(require("lodash/flatMap")), _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _get2 = _interopRequireDefault(require("lodash/get")), _isNil2 = _interopRequireDefault(require("lodash/isNil")), _rechartsScale = require("recharts-scale"), d3Scales = _interopRequireWildcard(require("d3-scale")), _d3Shape = require_d3_shape(), _DataUtils = require_DataUtils(), _Legend = require_Legend(), _ReactUtils = require_ReactUtils(), _types = require_types();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!!o) {
        if (typeof o == "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
    }
    function _iterableToArray(iter) {
      if (typeof Symbol < "u" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function getValueByDataKey(obj, dataKey, defaultValue) {
      return (0, _isNil2.default)(obj) || (0, _isNil2.default)(dataKey) ? defaultValue : (0, _DataUtils.isNumOrStr)(dataKey) ? (0, _get2.default)(obj, dataKey, defaultValue) : (0, _isFunction2.default)(dataKey) ? dataKey(obj) : defaultValue;
    }
    function getDomainOfDataByKey(data, key, type, filterNil) {
      var flattenData = (0, _flatMap2.default)(data, function(entry2) {
        return getValueByDataKey(entry2, key);
      });
      if (type === "number") {
        var domain = flattenData.filter(function(entry2) {
          return (0, _DataUtils.isNumber)(entry2) || parseFloat(entry2);
        });
        return domain.length ? [(0, _min2.default)(domain), (0, _max2.default)(domain)] : [1 / 0, -1 / 0];
      }
      var validateData = filterNil ? flattenData.filter(function(entry2) {
        return !(0, _isNil2.default)(entry2);
      }) : flattenData;
      return validateData.map(function(entry2) {
        return (0, _DataUtils.isNumOrStr)(entry2) || entry2 instanceof Date ? entry2 : "";
      });
    }
    var calculateActiveTickIndex = function(coordinate) {
      var _ticks$length, ticks = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], unsortedTicks = arguments.length > 2 ? arguments[2] : void 0, axis = arguments.length > 3 ? arguments[3] : void 0, index = -1, len = (_ticks$length = ticks == null ? void 0 : ticks.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0;
      if (len > 1) {
        if (axis && axis.axisType === "angleAxis" && Math.abs(Math.abs(axis.range[1] - axis.range[0]) - 360) <= 1e-6)
          for (var range = axis.range, i = 0; i < len; i++) {
            var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate, cur = unsortedTicks[i].coordinate, after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate, sameDirectionCoord = void 0;
            if ((0, _DataUtils.mathSign)(cur - before) !== (0, _DataUtils.mathSign)(after - cur)) {
              var diffInterval = [];
              if ((0, _DataUtils.mathSign)(after - cur) === (0, _DataUtils.mathSign)(range[1] - range[0])) {
                sameDirectionCoord = after;
                var curInRange = cur + range[1] - range[0];
                diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2), diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);
              } else {
                sameDirectionCoord = before;
                var afterInRange = after + range[1] - range[0];
                diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2), diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);
              }
              var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];
              if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {
                index = unsortedTicks[i].index;
                break;
              }
            } else {
              var min = Math.min(before, after), max = Math.max(before, after);
              if (coordinate > (min + cur) / 2 && coordinate <= (max + cur) / 2) {
                index = unsortedTicks[i].index;
                break;
              }
            }
          }
        else
          for (var _i = 0; _i < len; _i++)
            if (_i === 0 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2) {
              index = ticks[_i].index;
              break;
            }
      } else
        index = 0;
      return index;
    };
    exports.calculateActiveTickIndex = calculateActiveTickIndex;
    var getMainColorOfGraphicItem = function(item) {
      var _ref = item, displayName = _ref.type.displayName, _item$props = item.props, stroke = _item$props.stroke, fill = _item$props.fill, result;
      switch (displayName) {
        case "Line":
          result = stroke;
          break;
        case "Area":
        case "Radar":
          result = stroke && stroke !== "none" ? stroke : fill;
          break;
        default:
          result = fill;
          break;
      }
      return result;
    };
    exports.getMainColorOfGraphicItem = getMainColorOfGraphicItem;
    var getLegendProps = function(_ref2) {
      var children = _ref2.children, formattedGraphicalItems = _ref2.formattedGraphicalItems, legendWidth = _ref2.legendWidth, legendContent = _ref2.legendContent, legendItem = (0, _ReactUtils.findChildByType)(children, _Legend.Legend.displayName);
      if (!legendItem)
        return null;
      var legendData;
      return legendItem.props && legendItem.props.payload ? legendData = legendItem.props && legendItem.props.payload : legendContent === "children" ? legendData = (formattedGraphicalItems || []).reduce(function(result, _ref3) {
        var item = _ref3.item, props = _ref3.props, data = props.sectors || props.data || [];
        return result.concat(data.map(function(entry2) {
          return {
            type: legendItem.props.iconType || item.props.legendType,
            value: entry2.name,
            color: entry2.fill,
            payload: entry2
          };
        }));
      }, []) : legendData = (formattedGraphicalItems || []).map(function(_ref4) {
        var item = _ref4.item, _item$props2 = item.props, dataKey = _item$props2.dataKey, name = _item$props2.name, legendType = _item$props2.legendType, hide = _item$props2.hide;
        return {
          inactive: hide,
          dataKey,
          type: legendItem.props.iconType || legendType || "square",
          color: getMainColorOfGraphicItem(item),
          value: name || dataKey,
          payload: item.props
        };
      }), _objectSpread3(_objectSpread3(_objectSpread3({}, legendItem.props), _Legend.Legend.getWithHeight(legendItem, legendWidth)), {}, {
        payload: legendData,
        item: legendItem
      });
    };
    exports.getLegendProps = getLegendProps;
    var getBarSizeList = function(_ref5) {
      var globalSize = _ref5.barSize, _ref5$stackGroups = _ref5.stackGroups, stackGroups = _ref5$stackGroups === void 0 ? {} : _ref5$stackGroups;
      if (!stackGroups)
        return {};
      for (var result = {}, numericAxisIds = Object.keys(stackGroups), i = 0, len = numericAxisIds.length; i < len; i++)
        for (var sgs = stackGroups[numericAxisIds[i]].stackGroups, stackIds = Object.keys(sgs), j = 0, sLen = stackIds.length; j < sLen; j++) {
          var _sgs$stackIds$j = sgs[stackIds[j]], items = _sgs$stackIds$j.items, cateAxisId = _sgs$stackIds$j.cateAxisId, barItems = items.filter(function(item) {
            return (0, _ReactUtils.getDisplayName)(item.type).indexOf("Bar") >= 0;
          });
          if (barItems && barItems.length) {
            var selfSize = barItems[0].props.barSize, cateId = barItems[0].props[cateAxisId];
            result[cateId] || (result[cateId] = []), result[cateId].push({
              item: barItems[0],
              stackList: barItems.slice(1),
              barSize: (0, _isNil2.default)(selfSize) ? globalSize : selfSize
            });
          }
        }
      return result;
    };
    exports.getBarSizeList = getBarSizeList;
    var getBarPosition = function(_ref6) {
      var barGap = _ref6.barGap, barCategoryGap = _ref6.barCategoryGap, bandSize = _ref6.bandSize, _ref6$sizeList = _ref6.sizeList, sizeList = _ref6$sizeList === void 0 ? [] : _ref6$sizeList, maxBarSize = _ref6.maxBarSize, len = sizeList.length;
      if (len < 1)
        return null;
      var realBarGap = (0, _DataUtils.getPercentValue)(barGap, bandSize, 0, !0), result;
      if (sizeList[0].barSize === +sizeList[0].barSize) {
        var useFull = !1, fullBarSize = bandSize / len, sum = sizeList.reduce(function(res, entry2) {
          return res + entry2.barSize || 0;
        }, 0);
        sum += (len - 1) * realBarGap, sum >= bandSize && (sum -= (len - 1) * realBarGap, realBarGap = 0), sum >= bandSize && fullBarSize > 0 && (useFull = !0, fullBarSize *= 0.9, sum = len * fullBarSize);
        var offset = (bandSize - sum) / 2 >> 0, prev = {
          offset: offset - realBarGap,
          size: 0
        };
        result = sizeList.reduce(function(res, entry2) {
          var newRes = [].concat(_toConsumableArray(res), [{
            item: entry2.item,
            position: {
              offset: prev.offset + prev.size + realBarGap,
              size: useFull ? fullBarSize : entry2.barSize
            }
          }]);
          return prev = newRes[newRes.length - 1].position, entry2.stackList && entry2.stackList.length && entry2.stackList.forEach(function(item) {
            newRes.push({
              item,
              position: prev
            });
          }), newRes;
        }, []);
      } else {
        var _offset = (0, _DataUtils.getPercentValue)(barCategoryGap, bandSize, 0, !0);
        bandSize - 2 * _offset - (len - 1) * realBarGap <= 0 && (realBarGap = 0);
        var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;
        originalSize > 1 && (originalSize >>= 0);
        var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;
        result = sizeList.reduce(function(res, entry2, i) {
          var newRes = [].concat(_toConsumableArray(res), [{
            item: entry2.item,
            position: {
              offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,
              size
            }
          }]);
          return entry2.stackList && entry2.stackList.length && entry2.stackList.forEach(function(item) {
            newRes.push({
              item,
              position: newRes[newRes.length - 1].position
            });
          }), newRes;
        }, []);
      }
      return result;
    };
    exports.getBarPosition = getBarPosition;
    var appendOffsetOfLegend = function(offset, items, props, legendBox) {
      var children = props.children, width = props.width, margin = props.margin, legendWidth = width - (margin.left || 0) - (margin.right || 0), legendProps = getLegendProps({
        children,
        legendWidth
      }), newOffset = offset;
      if (legendProps) {
        var box = legendBox || {}, align = legendProps.align, verticalAlign = legendProps.verticalAlign, layout = legendProps.layout;
        (layout === "vertical" || layout === "horizontal" && verticalAlign === "center") && (0, _DataUtils.isNumber)(offset[align]) && (newOffset = _objectSpread3(_objectSpread3({}, offset), {}, _defineProperty3({}, align, newOffset[align] + (box.width || 0)))), (layout === "horizontal" || layout === "vertical" && align === "center") && (0, _DataUtils.isNumber)(offset[verticalAlign]) && (newOffset = _objectSpread3(_objectSpread3({}, offset), {}, _defineProperty3({}, verticalAlign, newOffset[verticalAlign] + (box.height || 0))));
      }
      return newOffset;
    };
    exports.appendOffsetOfLegend = appendOffsetOfLegend;
    var isErrorBarRelevantForAxis = function(layout, axisType, direction) {
      return (0, _isNil2.default)(axisType) ? !0 : layout === "horizontal" ? axisType === "yAxis" : layout === "vertical" || direction === "x" ? axisType === "xAxis" : direction === "y" ? axisType === "yAxis" : !0;
    }, getDomainOfErrorBars = function(data, item, dataKey, layout, axisType) {
      var children = item.props.children, errorBars = (0, _ReactUtils.findAllByType)(children, "ErrorBar").filter(function(errorBarChild) {
        return isErrorBarRelevantForAxis(layout, axisType, errorBarChild.props.direction);
      });
      if (errorBars && errorBars.length) {
        var keys = errorBars.map(function(errorBarChild) {
          return errorBarChild.props.dataKey;
        });
        return data.reduce(function(result, entry2) {
          var entryValue = getValueByDataKey(entry2, dataKey, 0), mainValue = (0, _isArray2.default)(entryValue) ? [(0, _min2.default)(entryValue), (0, _max2.default)(entryValue)] : [entryValue, entryValue], errorDomain = keys.reduce(function(prevErrorArr, k) {
            var errorValue = getValueByDataKey(entry2, k, 0), lowerValue = mainValue[0] - Math.abs((0, _isArray2.default)(errorValue) ? errorValue[0] : errorValue), upperValue = mainValue[1] + Math.abs((0, _isArray2.default)(errorValue) ? errorValue[1] : errorValue);
            return [Math.min(lowerValue, prevErrorArr[0]), Math.max(upperValue, prevErrorArr[1])];
          }, [1 / 0, -1 / 0]);
          return [Math.min(errorDomain[0], result[0]), Math.max(errorDomain[1], result[1])];
        }, [1 / 0, -1 / 0]);
      }
      return null;
    };
    exports.getDomainOfErrorBars = getDomainOfErrorBars;
    var parseErrorBarsOfAxis = function(data, items, dataKey, axisType, layout) {
      var domains = items.map(function(item) {
        return getDomainOfErrorBars(data, item, dataKey, layout, axisType);
      }).filter(function(entry2) {
        return !(0, _isNil2.default)(entry2);
      });
      return domains && domains.length ? domains.reduce(function(result, entry2) {
        return [Math.min(result[0], entry2[0]), Math.max(result[1], entry2[1])];
      }, [1 / 0, -1 / 0]) : null;
    };
    exports.parseErrorBarsOfAxis = parseErrorBarsOfAxis;
    var getDomainOfItemsWithSameAxis = function(data, items, type, layout, filterNil) {
      var domains = items.map(function(item) {
        var dataKey = item.props.dataKey;
        return type === "number" && dataKey && getDomainOfErrorBars(data, item, dataKey, layout) || getDomainOfDataByKey(data, dataKey, type, filterNil);
      });
      if (type === "number")
        return domains.reduce(function(result, entry2) {
          return [Math.min(result[0], entry2[0]), Math.max(result[1], entry2[1])];
        }, [1 / 0, -1 / 0]);
      var tag = {};
      return domains.reduce(function(result, entry2) {
        for (var i = 0, len = entry2.length; i < len; i++)
          tag[entry2[i]] || (tag[entry2[i]] = !0, result.push(entry2[i]));
        return result;
      }, []);
    };
    exports.getDomainOfItemsWithSameAxis = getDomainOfItemsWithSameAxis;
    var isCategoricalAxis = function(layout, axisType) {
      return layout === "horizontal" && axisType === "xAxis" || layout === "vertical" && axisType === "yAxis" || layout === "centric" && axisType === "angleAxis" || layout === "radial" && axisType === "radiusAxis";
    };
    exports.isCategoricalAxis = isCategoricalAxis;
    var getCoordinatesOfGrid = function(ticks, min, max) {
      var hasMin, hasMax, values = ticks.map(function(entry2) {
        return entry2.coordinate === min && (hasMin = !0), entry2.coordinate === max && (hasMax = !0), entry2.coordinate;
      });
      return hasMin || values.push(min), hasMax || values.push(max), values;
    };
    exports.getCoordinatesOfGrid = getCoordinatesOfGrid;
    var getTicksOfAxis = function(axis, isGrid, isAll) {
      if (!axis)
        return null;
      var scale = axis.scale, duplicateDomain = axis.duplicateDomain, type = axis.type, range = axis.range, offsetForBand = axis.realScaleType === "scaleBand" ? scale.bandwidth() / 2 : 2, offset = (isGrid || isAll) && type === "category" && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;
      return offset = axis.axisType === "angleAxis" ? (0, _DataUtils.mathSign)(range[0] - range[1]) * 2 * offset : offset, isGrid && (axis.ticks || axis.niceTicks) ? (axis.ticks || axis.niceTicks).map(function(entry2) {
        var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry2) : entry2;
        return {
          coordinate: scale(scaleContent) + offset,
          value: entry2,
          offset
        };
      }) : axis.isCategorical && axis.categoricalDomain ? axis.categoricalDomain.map(function(entry2, index) {
        return {
          coordinate: scale(entry2) + offset,
          value: entry2,
          index,
          offset
        };
      }) : scale.ticks && !isAll ? scale.ticks(axis.tickCount).map(function(entry2) {
        return {
          coordinate: scale(entry2) + offset,
          value: entry2,
          offset
        };
      }) : scale.domain().map(function(entry2, index) {
        return {
          coordinate: scale(entry2) + offset,
          value: duplicateDomain ? duplicateDomain[entry2] : entry2,
          index,
          offset
        };
      });
    };
    exports.getTicksOfAxis = getTicksOfAxis;
    var combineEventHandlers = function(defaultHandler, parentHandler, childHandler) {
      var customizedHandler;
      return (0, _isFunction2.default)(childHandler) ? customizedHandler = childHandler : (0, _isFunction2.default)(parentHandler) && (customizedHandler = parentHandler), (0, _isFunction2.default)(defaultHandler) || customizedHandler ? function(arg1, arg2, arg3, arg4) {
        (0, _isFunction2.default)(defaultHandler) && defaultHandler(arg1, arg2, arg3, arg4), (0, _isFunction2.default)(customizedHandler) && customizedHandler(arg1, arg2, arg3, arg4);
      } : null;
    };
    exports.combineEventHandlers = combineEventHandlers;
    var parseScale = function(axis, chartType, hasBar) {
      var scale = axis.scale, type = axis.type, layout = axis.layout, axisType = axis.axisType;
      if (scale === "auto")
        return layout === "radial" && axisType === "radiusAxis" ? {
          scale: d3Scales.scaleBand(),
          realScaleType: "band"
        } : layout === "radial" && axisType === "angleAxis" ? {
          scale: d3Scales.scaleLinear(),
          realScaleType: "linear"
        } : type === "category" && chartType && (chartType.indexOf("LineChart") >= 0 || chartType.indexOf("AreaChart") >= 0 || chartType.indexOf("ComposedChart") >= 0 && !hasBar) ? {
          scale: d3Scales.scalePoint(),
          realScaleType: "point"
        } : type === "category" ? {
          scale: d3Scales.scaleBand(),
          realScaleType: "band"
        } : {
          scale: d3Scales.scaleLinear(),
          realScaleType: "linear"
        };
      if ((0, _isString2.default)(scale)) {
        var name = "scale".concat((0, _upperFirst2.default)(scale));
        return {
          scale: (d3Scales[name] || d3Scales.scalePoint)(),
          realScaleType: d3Scales[name] ? name : "point"
        };
      }
      return (0, _isFunction2.default)(scale) ? {
        scale
      } : {
        scale: d3Scales.scalePoint(),
        realScaleType: "point"
      };
    };
    exports.parseScale = parseScale;
    var EPS = 1e-4, checkDomainOfScale = function(scale) {
      var domain = scale.domain();
      if (!(!domain || domain.length <= 2)) {
        var len = domain.length, range = scale.range(), min = Math.min(range[0], range[1]) - EPS, max = Math.max(range[0], range[1]) + EPS, first = scale(domain[0]), last = scale(domain[len - 1]);
        (first < min || first > max || last < min || last > max) && scale.domain([domain[0], domain[len - 1]]);
      }
    };
    exports.checkDomainOfScale = checkDomainOfScale;
    var findPositionOfBar = function(barPosition, child) {
      if (!barPosition)
        return null;
      for (var i = 0, len = barPosition.length; i < len; i++)
        if (barPosition[i].item === child)
          return barPosition[i].position;
      return null;
    };
    exports.findPositionOfBar = findPositionOfBar;
    var truncateByDomain = function(value, domain) {
      if (!domain || domain.length !== 2 || !(0, _DataUtils.isNumber)(domain[0]) || !(0, _DataUtils.isNumber)(domain[1]))
        return value;
      var min = Math.min(domain[0], domain[1]), max = Math.max(domain[0], domain[1]), result = [value[0], value[1]];
      return (!(0, _DataUtils.isNumber)(value[0]) || value[0] < min) && (result[0] = min), (!(0, _DataUtils.isNumber)(value[1]) || value[1] > max) && (result[1] = max), result[0] > max && (result[0] = max), result[1] < min && (result[1] = min), result;
    };
    exports.truncateByDomain = truncateByDomain;
    var offsetSign = function(series) {
      var n = series.length;
      if (!(n <= 0))
        for (var j = 0, m = series[0].length; j < m; ++j)
          for (var positive = 0, negative = 0, i = 0; i < n; ++i) {
            var value = (0, _isNaN2.default)(series[i][j][1]) ? series[i][j][0] : series[i][j][1];
            value >= 0 ? (series[i][j][0] = positive, series[i][j][1] = positive + value, positive = series[i][j][1]) : (series[i][j][0] = negative, series[i][j][1] = negative + value, negative = series[i][j][1]);
          }
    };
    exports.offsetSign = offsetSign;
    var offsetPositive = function(series) {
      var n = series.length;
      if (!(n <= 0))
        for (var j = 0, m = series[0].length; j < m; ++j)
          for (var positive = 0, i = 0; i < n; ++i) {
            var value = (0, _isNaN2.default)(series[i][j][1]) ? series[i][j][0] : series[i][j][1];
            value >= 0 ? (series[i][j][0] = positive, series[i][j][1] = positive + value, positive = series[i][j][1]) : (series[i][j][0] = 0, series[i][j][1] = 0);
          }
    };
    exports.offsetPositive = offsetPositive;
    var STACK_OFFSET_MAP = {
      sign: offsetSign,
      expand: _d3Shape.stackOffsetExpand,
      none: _d3Shape.stackOffsetNone,
      silhouette: _d3Shape.stackOffsetSilhouette,
      wiggle: _d3Shape.stackOffsetWiggle,
      positive: offsetPositive
    }, getStackedData = function(data, stackItems, offsetType) {
      var dataKeys = stackItems.map(function(item) {
        return item.props.dataKey;
      }), stack = (0, _d3Shape.stack)().keys(dataKeys).value(function(d, key) {
        return +getValueByDataKey(d, key, 0);
      }).order(_d3Shape.stackOrderNone).offset(STACK_OFFSET_MAP[offsetType]);
      return stack(data);
    };
    exports.getStackedData = getStackedData;
    var getStackGroupsByAxisId = function(data, _items, numericAxisId, cateAxisId, offsetType, reverseStackOrder) {
      if (!data)
        return null;
      var items = reverseStackOrder ? _items.reverse() : _items, stackGroups = items.reduce(function(result, item) {
        var _item$props3 = item.props, stackId = _item$props3.stackId, hide = _item$props3.hide;
        if (hide)
          return result;
        var axisId = item.props[numericAxisId], parentGroup = result[axisId] || {
          hasStack: !1,
          stackGroups: {}
        };
        if ((0, _DataUtils.isNumOrStr)(stackId)) {
          var childGroup = parentGroup.stackGroups[stackId] || {
            numericAxisId,
            cateAxisId,
            items: []
          };
          childGroup.items.push(item), parentGroup.hasStack = !0, parentGroup.stackGroups[stackId] = childGroup;
        } else
          parentGroup.stackGroups[(0, _DataUtils.uniqueId)("_stackId_")] = {
            numericAxisId,
            cateAxisId,
            items: [item]
          };
        return _objectSpread3(_objectSpread3({}, result), {}, _defineProperty3({}, axisId, parentGroup));
      }, {});
      return Object.keys(stackGroups).reduce(function(result, axisId) {
        var group = stackGroups[axisId];
        return group.hasStack && (group.stackGroups = Object.keys(group.stackGroups).reduce(function(res, stackId) {
          var g = group.stackGroups[stackId];
          return _objectSpread3(_objectSpread3({}, res), {}, _defineProperty3({}, stackId, {
            numericAxisId,
            cateAxisId,
            items: g.items,
            stackedData: getStackedData(data, g.items, offsetType)
          }));
        }, {})), _objectSpread3(_objectSpread3({}, result), {}, _defineProperty3({}, axisId, group));
      }, {});
    };
    exports.getStackGroupsByAxisId = getStackGroupsByAxisId;
    var calculateDomainOfTicks = function(ticks, type) {
      return type === "number" ? [(0, _min2.default)(ticks), (0, _max2.default)(ticks)] : ticks;
    };
    exports.calculateDomainOfTicks = calculateDomainOfTicks;
    var getTicksOfScale = function(scale, opts) {
      var realScaleType = opts.realScaleType, type = opts.type, tickCount = opts.tickCount, originalDomain = opts.originalDomain, allowDecimals = opts.allowDecimals, scaleType = realScaleType || opts.scale;
      if (scaleType !== "auto" && scaleType !== "linear")
        return null;
      if (tickCount && type === "number" && originalDomain && (originalDomain[0] === "auto" || originalDomain[1] === "auto")) {
        var domain = scale.domain();
        if (!domain.length)
          return null;
        var tickValues = (0, _rechartsScale.getNiceTickValues)(domain, tickCount, allowDecimals);
        return scale.domain(calculateDomainOfTicks(tickValues, type)), {
          niceTicks: tickValues
        };
      }
      if (tickCount && type === "number") {
        var _domain = scale.domain(), _tickValues = (0, _rechartsScale.getTickValuesFixedDomain)(_domain, tickCount, allowDecimals);
        return {
          niceTicks: _tickValues
        };
      }
      return null;
    };
    exports.getTicksOfScale = getTicksOfScale;
    var getCateCoordinateOfLine = function(_ref7) {
      var axis = _ref7.axis, ticks = _ref7.ticks, bandSize = _ref7.bandSize, entry2 = _ref7.entry, index = _ref7.index, dataKey = _ref7.dataKey;
      if (axis.type === "category") {
        if (!axis.allowDuplicatedCategory && axis.dataKey && !(0, _isNil2.default)(entry2[axis.dataKey])) {
          var matchedTick = (0, _DataUtils.findEntryInArray)(ticks, "value", entry2[axis.dataKey]);
          if (matchedTick)
            return matchedTick.coordinate + bandSize / 2;
        }
        return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;
      }
      var value = getValueByDataKey(entry2, (0, _isNil2.default)(dataKey) ? axis.dataKey : dataKey);
      return (0, _isNil2.default)(value) ? null : axis.scale(value);
    };
    exports.getCateCoordinateOfLine = getCateCoordinateOfLine;
    var getCateCoordinateOfBar = function(_ref8) {
      var axis = _ref8.axis, ticks = _ref8.ticks, offset = _ref8.offset, bandSize = _ref8.bandSize, entry2 = _ref8.entry, index = _ref8.index;
      if (axis.type === "category")
        return ticks[index] ? ticks[index].coordinate + offset : null;
      var value = getValueByDataKey(entry2, axis.dataKey, axis.domain[index]);
      return (0, _isNil2.default)(value) ? null : axis.scale(value) - bandSize / 2 + offset;
    };
    exports.getCateCoordinateOfBar = getCateCoordinateOfBar;
    var getBaseValueOfBar = function(_ref9) {
      var numericAxis = _ref9.numericAxis, domain = numericAxis.scale.domain();
      if (numericAxis.type === "number") {
        var min = Math.min(domain[0], domain[1]), max = Math.max(domain[0], domain[1]);
        return min <= 0 && max >= 0 ? 0 : max < 0 ? max : min;
      }
      return domain[0];
    };
    exports.getBaseValueOfBar = getBaseValueOfBar;
    var getStackedDataOfItem = function(item, stackGroups) {
      var stackId = item.props.stackId;
      if ((0, _DataUtils.isNumOrStr)(stackId)) {
        var group = stackGroups[stackId];
        if (group && group.items.length) {
          for (var itemIndex = -1, i = 0, len = group.items.length; i < len; i++)
            if (group.items[i] === item) {
              itemIndex = i;
              break;
            }
          return itemIndex >= 0 ? group.stackedData[itemIndex] : null;
        }
      }
      return null;
    };
    exports.getStackedDataOfItem = getStackedDataOfItem;
    var getDomainOfSingle = function(data) {
      return data.reduce(function(result, entry2) {
        return [(0, _min2.default)(entry2.concat([result[0]]).filter(_DataUtils.isNumber)), (0, _max2.default)(entry2.concat([result[1]]).filter(_DataUtils.isNumber))];
      }, [1 / 0, -1 / 0]);
    }, getDomainOfStackGroups = function(stackGroups, startIndex, endIndex) {
      return Object.keys(stackGroups).reduce(function(result, stackId) {
        var group = stackGroups[stackId], stackedData = group.stackedData, domain = stackedData.reduce(function(res, entry2) {
          var s = getDomainOfSingle(entry2.slice(startIndex, endIndex + 1));
          return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];
        }, [1 / 0, -1 / 0]);
        return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];
      }, [1 / 0, -1 / 0]).map(function(result) {
        return result === 1 / 0 || result === -1 / 0 ? 0 : result;
      });
    };
    exports.getDomainOfStackGroups = getDomainOfStackGroups;
    var MIN_VALUE_REG = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
    exports.MIN_VALUE_REG = MIN_VALUE_REG;
    var MAX_VALUE_REG = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
    exports.MAX_VALUE_REG = MAX_VALUE_REG;
    var parseSpecifiedDomain = function(specifiedDomain, dataDomain, allowDataOverflow) {
      if ((0, _isFunction2.default)(specifiedDomain))
        return specifiedDomain(dataDomain, allowDataOverflow);
      if (!(0, _isArray2.default)(specifiedDomain))
        return dataDomain;
      var domain = [];
      if ((0, _DataUtils.isNumber)(specifiedDomain[0]))
        domain[0] = allowDataOverflow ? specifiedDomain[0] : Math.min(specifiedDomain[0], dataDomain[0]);
      else if (MIN_VALUE_REG.test(specifiedDomain[0])) {
        var value = +MIN_VALUE_REG.exec(specifiedDomain[0])[1];
        domain[0] = dataDomain[0] - value;
      } else
        (0, _isFunction2.default)(specifiedDomain[0]) ? domain[0] = specifiedDomain[0](dataDomain[0]) : domain[0] = dataDomain[0];
      if ((0, _DataUtils.isNumber)(specifiedDomain[1]))
        domain[1] = allowDataOverflow ? specifiedDomain[1] : Math.max(specifiedDomain[1], dataDomain[1]);
      else if (MAX_VALUE_REG.test(specifiedDomain[1])) {
        var _value = +MAX_VALUE_REG.exec(specifiedDomain[1])[1];
        domain[1] = dataDomain[1] + _value;
      } else
        (0, _isFunction2.default)(specifiedDomain[1]) ? domain[1] = specifiedDomain[1](dataDomain[1]) : domain[1] = dataDomain[1];
      return domain;
    };
    exports.parseSpecifiedDomain = parseSpecifiedDomain;
    var getBandSizeOfAxis = function(axis, ticks, isBar) {
      if (axis && axis.scale && axis.scale.bandwidth) {
        var bandWidth = axis.scale.bandwidth();
        if (!isBar || bandWidth > 0)
          return bandWidth;
      }
      if (axis && ticks && ticks.length >= 2) {
        for (var orderedTicks = (0, _sortBy2.default)(ticks, function(o) {
          return o.coordinate;
        }), bandSize = 1 / 0, i = 1, len = orderedTicks.length; i < len; i++) {
          var cur = orderedTicks[i], prev = orderedTicks[i - 1];
          bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);
        }
        return bandSize === 1 / 0 ? 0 : bandSize;
      }
      return isBar ? void 0 : 0;
    };
    exports.getBandSizeOfAxis = getBandSizeOfAxis;
    var parseDomainOfCategoryAxis = function(specifiedDomain, calculatedDomain, axisChild) {
      return !specifiedDomain || !specifiedDomain.length || (0, _isEqual2.default)(specifiedDomain, (0, _get2.default)(axisChild, "type.defaultProps.domain")) ? calculatedDomain : specifiedDomain;
    };
    exports.parseDomainOfCategoryAxis = parseDomainOfCategoryAxis;
    var getTooltipItem = function(graphicalItem, payload) {
      var _graphicalItem$props = graphicalItem.props, dataKey = _graphicalItem$props.dataKey, name = _graphicalItem$props.name, unit = _graphicalItem$props.unit, formatter = _graphicalItem$props.formatter, tooltipType = _graphicalItem$props.tooltipType, chartType = _graphicalItem$props.chartType;
      return _objectSpread3(_objectSpread3({}, (0, _types.filterProps)(graphicalItem)), {}, {
        dataKey,
        unit,
        formatter,
        name: name || dataKey,
        color: getMainColorOfGraphicItem(graphicalItem),
        value: getValueByDataKey(payload, dataKey),
        type: tooltipType,
        payload,
        chartType
      });
    };
    exports.getTooltipItem = getTooltipItem;
  }
});

// node_modules/recharts/lib/util/PolarUtils.js
var require_PolarUtils = __commonJS({
  "node_modules/recharts/lib/util/PolarUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.inRangeOfSector = exports.formatAngleOfSector = exports.getAngleOfPoint = exports.distanceBetweenPoints = exports.formatAxisMap = exports.getMaxRadius = exports.polarToCartesian = exports.radianToDegree = exports.degreeToRadian = exports.RADIAN = void 0;
    var _isNil2 = _interopRequireDefault(require("lodash/isNil")), _DataUtils = require_DataUtils(), _ChartUtils = require_ChartUtils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!!o) {
        if (typeof o == "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
    }
    function _arrayLikeToArray(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(arr)))) {
        var _arr = [], _n = !0, _d = !1, _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    var RADIAN = Math.PI / 180;
    exports.RADIAN = RADIAN;
    var degreeToRadian = function(angle) {
      return angle * Math.PI / 180;
    };
    exports.degreeToRadian = degreeToRadian;
    var radianToDegree = function(angleInRadian) {
      return angleInRadian * 180 / Math.PI;
    };
    exports.radianToDegree = radianToDegree;
    var polarToCartesian = function(cx, cy, radius, angle) {
      return {
        x: cx + Math.cos(-RADIAN * angle) * radius,
        y: cy + Math.sin(-RADIAN * angle) * radius
      };
    };
    exports.polarToCartesian = polarToCartesian;
    var getMaxRadius = function(width, height) {
      var offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
      return Math.min(Math.abs(width - (offset.left || 0) - (offset.right || 0)), Math.abs(height - (offset.top || 0) - (offset.bottom || 0))) / 2;
    };
    exports.getMaxRadius = getMaxRadius;
    var formatAxisMap = function(props, axisMap, offset, axisType, chartName) {
      var width = props.width, height = props.height, startAngle = props.startAngle, endAngle = props.endAngle, cx = (0, _DataUtils.getPercentValue)(props.cx, width, width / 2), cy = (0, _DataUtils.getPercentValue)(props.cy, height, height / 2), maxRadius = getMaxRadius(width, height, offset), innerRadius = (0, _DataUtils.getPercentValue)(props.innerRadius, maxRadius, 0), outerRadius = (0, _DataUtils.getPercentValue)(props.outerRadius, maxRadius, maxRadius * 0.8), ids = Object.keys(axisMap);
      return ids.reduce(function(result, id) {
        var axis = axisMap[id], domain = axis.domain, reversed = axis.reversed, range;
        if ((0, _isNil2.default)(axis.range))
          axisType === "angleAxis" ? range = [startAngle, endAngle] : axisType === "radiusAxis" && (range = [innerRadius, outerRadius]), reversed && (range = [range[1], range[0]]);
        else {
          range = axis.range;
          var _range = range, _range2 = _slicedToArray(_range, 2);
          startAngle = _range2[0], endAngle = _range2[1];
        }
        var _parseScale = (0, _ChartUtils.parseScale)(axis, chartName), realScaleType = _parseScale.realScaleType, scale = _parseScale.scale;
        scale.domain(domain).range(range), (0, _ChartUtils.checkDomainOfScale)(scale);
        var ticks = (0, _ChartUtils.getTicksOfScale)(scale, _objectSpread3(_objectSpread3({}, axis), {}, {
          realScaleType
        })), finalAxis = _objectSpread3(_objectSpread3(_objectSpread3({}, axis), ticks), {}, {
          range,
          radius: outerRadius,
          realScaleType,
          scale,
          cx,
          cy,
          innerRadius,
          outerRadius,
          startAngle,
          endAngle
        });
        return _objectSpread3(_objectSpread3({}, result), {}, _defineProperty3({}, id, finalAxis));
      }, {});
    };
    exports.formatAxisMap = formatAxisMap;
    var distanceBetweenPoints = function(point, anotherPoint) {
      var x1 = point.x, y1 = point.y, x2 = anotherPoint.x, y2 = anotherPoint.y;
      return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    };
    exports.distanceBetweenPoints = distanceBetweenPoints;
    var getAngleOfPoint = function(_ref, _ref2) {
      var x = _ref.x, y = _ref.y, cx = _ref2.cx, cy = _ref2.cy, radius = distanceBetweenPoints({
        x,
        y
      }, {
        x: cx,
        y: cy
      });
      if (radius <= 0)
        return {
          radius
        };
      var cos = (x - cx) / radius, angleInRadian = Math.acos(cos);
      return y > cy && (angleInRadian = 2 * Math.PI - angleInRadian), {
        radius,
        angle: radianToDegree(angleInRadian),
        angleInRadian
      };
    };
    exports.getAngleOfPoint = getAngleOfPoint;
    var formatAngleOfSector = function(_ref3) {
      var startAngle = _ref3.startAngle, endAngle = _ref3.endAngle, startCnt = Math.floor(startAngle / 360), endCnt = Math.floor(endAngle / 360), min = Math.min(startCnt, endCnt);
      return {
        startAngle: startAngle - min * 360,
        endAngle: endAngle - min * 360
      };
    };
    exports.formatAngleOfSector = formatAngleOfSector;
    var reverseFormatAngleOfSetor = function(angle, _ref4) {
      var startAngle = _ref4.startAngle, endAngle = _ref4.endAngle, startCnt = Math.floor(startAngle / 360), endCnt = Math.floor(endAngle / 360), min = Math.min(startCnt, endCnt);
      return angle + min * 360;
    }, inRangeOfSector = function(_ref5, sector) {
      var x = _ref5.x, y = _ref5.y, _getAngleOfPoint = getAngleOfPoint({
        x,
        y
      }, sector), radius = _getAngleOfPoint.radius, angle = _getAngleOfPoint.angle, innerRadius = sector.innerRadius, outerRadius = sector.outerRadius;
      if (radius < innerRadius || radius > outerRadius)
        return !1;
      if (radius === 0)
        return !0;
      var _formatAngleOfSector = formatAngleOfSector(sector), startAngle = _formatAngleOfSector.startAngle, endAngle = _formatAngleOfSector.endAngle, formatAngle = angle, inRange;
      if (startAngle <= endAngle) {
        for (; formatAngle > endAngle; )
          formatAngle -= 360;
        for (; formatAngle < startAngle; )
          formatAngle += 360;
        inRange = formatAngle >= startAngle && formatAngle <= endAngle;
      } else {
        for (; formatAngle > startAngle; )
          formatAngle -= 360;
        for (; formatAngle < endAngle; )
          formatAngle += 360;
        inRange = formatAngle >= endAngle && formatAngle <= startAngle;
      }
      return inRange ? _objectSpread3(_objectSpread3({}, sector), {}, {
        radius,
        angle: reverseFormatAngleOfSetor(formatAngle, sector)
      }) : null;
    };
    exports.inRangeOfSector = inRangeOfSector;
  }
});

// node_modules/recharts/lib/component/Label.js
var require_Label = __commonJS({
  "node_modules/recharts/lib/component/Label.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Label = Label2;
    var _isObject2 = _interopRequireDefault(require("lodash/isObject")), _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _isNil2 = _interopRequireDefault(require("lodash/isNil")), _react = _interopRequireWildcard(require("react")), _classnames = _interopRequireDefault(require("classnames")), _Text = require_Text(), _ReactUtils = require_ReactUtils(), _DataUtils = require_DataUtils(), _PolarUtils = require_PolarUtils(), _types = require_types();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!!o) {
        if (typeof o == "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
    }
    function _iterableToArray(iter) {
      if (typeof Symbol < "u" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    var getLabel = function(props) {
      var value = props.value, formatter = props.formatter, label = (0, _isNil2.default)(props.children) ? value : props.children;
      return (0, _isFunction2.default)(formatter) ? formatter(label) : label;
    }, getDeltaAngle = function(startAngle, endAngle) {
      var sign = (0, _DataUtils.mathSign)(endAngle - startAngle), deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);
      return sign * deltaAngle;
    }, renderRadialLabel = function(labelProps, label, attrs) {
      var position = labelProps.position, viewBox = labelProps.viewBox, offset = labelProps.offset, className = labelProps.className, _ref = viewBox, cx = _ref.cx, cy = _ref.cy, innerRadius = _ref.innerRadius, outerRadius = _ref.outerRadius, startAngle = _ref.startAngle, endAngle = _ref.endAngle, clockWise = _ref.clockWise, radius = (innerRadius + outerRadius) / 2, deltaAngle = getDeltaAngle(startAngle, endAngle), sign = deltaAngle >= 0 ? 1 : -1, labelAngle, direction;
      position === "insideStart" ? (labelAngle = startAngle + sign * offset, direction = clockWise) : position === "insideEnd" ? (labelAngle = endAngle - sign * offset, direction = !clockWise) : position === "end" && (labelAngle = endAngle + sign * offset, direction = clockWise), direction = deltaAngle <= 0 ? direction : !direction;
      var startPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, radius, labelAngle), endPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, radius, labelAngle + (direction ? 1 : -1) * 359), path = "M".concat(startPoint.x, ",").concat(startPoint.y, `
    A`).concat(radius, ",").concat(radius, ",0,1,").concat(direction ? 0 : 1, `,
    `).concat(endPoint.x, ",").concat(endPoint.y), id = (0, _isNil2.default)(labelProps.id) ? (0, _DataUtils.uniqueId)("recharts-radial-line-") : labelProps.id;
      return /* @__PURE__ */ _react.default.createElement("text", _extends({}, attrs, {
        dominantBaseline: "central",
        className: (0, _classnames.default)("recharts-radial-bar-label", className)
      }), /* @__PURE__ */ _react.default.createElement("defs", null, /* @__PURE__ */ _react.default.createElement("path", {
        id,
        d: path
      })), /* @__PURE__ */ _react.default.createElement("textPath", {
        xlinkHref: "#".concat(id)
      }, label));
    }, getAttrsOfPolarLabel = function(props) {
      var viewBox = props.viewBox, offset = props.offset, position = props.position, _ref2 = viewBox, cx = _ref2.cx, cy = _ref2.cy, innerRadius = _ref2.innerRadius, outerRadius = _ref2.outerRadius, startAngle = _ref2.startAngle, endAngle = _ref2.endAngle, midAngle = (startAngle + endAngle) / 2;
      if (position === "outside") {
        var _polarToCartesian = (0, _PolarUtils.polarToCartesian)(cx, cy, outerRadius + offset, midAngle), _x = _polarToCartesian.x, _y = _polarToCartesian.y;
        return {
          x: _x,
          y: _y,
          textAnchor: _x >= cx ? "start" : "end",
          verticalAnchor: "middle"
        };
      }
      if (position === "center")
        return {
          x: cx,
          y: cy,
          textAnchor: "middle",
          verticalAnchor: "middle"
        };
      if (position === "centerTop")
        return {
          x: cx,
          y: cy,
          textAnchor: "middle",
          verticalAnchor: "start"
        };
      if (position === "centerBottom")
        return {
          x: cx,
          y: cy,
          textAnchor: "middle",
          verticalAnchor: "end"
        };
      var r = (innerRadius + outerRadius) / 2, _polarToCartesian2 = (0, _PolarUtils.polarToCartesian)(cx, cy, r, midAngle), x = _polarToCartesian2.x, y = _polarToCartesian2.y;
      return {
        x,
        y,
        textAnchor: "middle",
        verticalAnchor: "middle"
      };
    }, getAttrsOfCartesianLabel = function(props) {
      var viewBox = props.viewBox, parentViewBox = props.parentViewBox, offset = props.offset, position = props.position, _ref3 = viewBox, x = _ref3.x, y = _ref3.y, width = _ref3.width, height = _ref3.height, verticalSign = height >= 0 ? 1 : -1, verticalOffset = verticalSign * offset, verticalEnd = verticalSign > 0 ? "end" : "start", verticalStart = verticalSign > 0 ? "start" : "end", horizontalSign = width >= 0 ? 1 : -1, horizontalOffset = horizontalSign * offset, horizontalEnd = horizontalSign > 0 ? "end" : "start", horizontalStart = horizontalSign > 0 ? "start" : "end";
      if (position === "top") {
        var attrs = {
          x: x + width / 2,
          y: y - verticalSign * offset,
          textAnchor: "middle",
          verticalAnchor: verticalEnd
        };
        return _objectSpread3(_objectSpread3({}, attrs), parentViewBox ? {
          height: Math.max(y - parentViewBox.y, 0),
          width
        } : {});
      }
      if (position === "bottom") {
        var _attrs = {
          x: x + width / 2,
          y: y + height + verticalOffset,
          textAnchor: "middle",
          verticalAnchor: verticalStart
        };
        return _objectSpread3(_objectSpread3({}, _attrs), parentViewBox ? {
          height: Math.max(parentViewBox.y + parentViewBox.height - (y + height), 0),
          width
        } : {});
      }
      if (position === "left") {
        var _attrs2 = {
          x: x - horizontalOffset,
          y: y + height / 2,
          textAnchor: horizontalEnd,
          verticalAnchor: "middle"
        };
        return _objectSpread3(_objectSpread3({}, _attrs2), parentViewBox ? {
          width: Math.max(_attrs2.x - parentViewBox.x, 0),
          height
        } : {});
      }
      if (position === "right") {
        var _attrs3 = {
          x: x + width + horizontalOffset,
          y: y + height / 2,
          textAnchor: horizontalStart,
          verticalAnchor: "middle"
        };
        return _objectSpread3(_objectSpread3({}, _attrs3), parentViewBox ? {
          width: Math.max(parentViewBox.x + parentViewBox.width - _attrs3.x, 0),
          height
        } : {});
      }
      var sizeAttrs = parentViewBox ? {
        width,
        height
      } : {};
      return position === "insideLeft" ? _objectSpread3({
        x: x + horizontalOffset,
        y: y + height / 2,
        textAnchor: horizontalStart,
        verticalAnchor: "middle"
      }, sizeAttrs) : position === "insideRight" ? _objectSpread3({
        x: x + width - horizontalOffset,
        y: y + height / 2,
        textAnchor: horizontalEnd,
        verticalAnchor: "middle"
      }, sizeAttrs) : position === "insideTop" ? _objectSpread3({
        x: x + width / 2,
        y: y + verticalOffset,
        textAnchor: "middle",
        verticalAnchor: verticalStart
      }, sizeAttrs) : position === "insideBottom" ? _objectSpread3({
        x: x + width / 2,
        y: y + height - verticalOffset,
        textAnchor: "middle",
        verticalAnchor: verticalEnd
      }, sizeAttrs) : position === "insideTopLeft" ? _objectSpread3({
        x: x + horizontalOffset,
        y: y + verticalOffset,
        textAnchor: horizontalStart,
        verticalAnchor: verticalStart
      }, sizeAttrs) : position === "insideTopRight" ? _objectSpread3({
        x: x + width - horizontalOffset,
        y: y + verticalOffset,
        textAnchor: horizontalEnd,
        verticalAnchor: verticalStart
      }, sizeAttrs) : position === "insideBottomLeft" ? _objectSpread3({
        x: x + horizontalOffset,
        y: y + height - verticalOffset,
        textAnchor: horizontalStart,
        verticalAnchor: verticalEnd
      }, sizeAttrs) : position === "insideBottomRight" ? _objectSpread3({
        x: x + width - horizontalOffset,
        y: y + height - verticalOffset,
        textAnchor: horizontalEnd,
        verticalAnchor: verticalEnd
      }, sizeAttrs) : (0, _isObject2.default)(position) && ((0, _DataUtils.isNumber)(position.x) || (0, _DataUtils.isPercent)(position.x)) && ((0, _DataUtils.isNumber)(position.y) || (0, _DataUtils.isPercent)(position.y)) ? _objectSpread3({
        x: x + (0, _DataUtils.getPercentValue)(position.x, width),
        y: y + (0, _DataUtils.getPercentValue)(position.y, height),
        textAnchor: "end",
        verticalAnchor: "end"
      }, sizeAttrs) : _objectSpread3({
        x: x + width / 2,
        y: y + height / 2,
        textAnchor: "middle",
        verticalAnchor: "middle"
      }, sizeAttrs);
    }, isPolar = function(viewBox) {
      return (0, _DataUtils.isNumber)(viewBox.cx);
    };
    function Label2(props) {
      var viewBox = props.viewBox, position = props.position, value = props.value, children = props.children, content = props.content, _props$className = props.className, className = _props$className === void 0 ? "" : _props$className, textBreakAll = props.textBreakAll;
      if (!viewBox || (0, _isNil2.default)(value) && (0, _isNil2.default)(children) && !/* @__PURE__ */ (0, _react.isValidElement)(content) && !(0, _isFunction2.default)(content))
        return null;
      if (/* @__PURE__ */ (0, _react.isValidElement)(content))
        return /* @__PURE__ */ (0, _react.cloneElement)(content, props);
      var label;
      if ((0, _isFunction2.default)(content)) {
        if (label = /* @__PURE__ */ (0, _react.createElement)(content, props), /* @__PURE__ */ (0, _react.isValidElement)(label))
          return label;
      } else
        label = getLabel(props);
      var isPolarLabel = isPolar(viewBox), attrs = (0, _types.filterProps)(props, !0);
      if (isPolarLabel && (position === "insideStart" || position === "insideEnd" || position === "end"))
        return renderRadialLabel(props, label, attrs);
      var positionAttrs = isPolarLabel ? getAttrsOfPolarLabel(props) : getAttrsOfCartesianLabel(props);
      return /* @__PURE__ */ _react.default.createElement(_Text.Text, _extends({
        className: (0, _classnames.default)("recharts-label", className)
      }, attrs, positionAttrs, {
        breakAll: textBreakAll
      }), label);
    }
    Label2.displayName = "Label";
    Label2.defaultProps = {
      offset: 5
    };
    var parseViewBox = function(props) {
      var cx = props.cx, cy = props.cy, angle = props.angle, startAngle = props.startAngle, endAngle = props.endAngle, r = props.r, radius = props.radius, innerRadius = props.innerRadius, outerRadius = props.outerRadius, x = props.x, y = props.y, top = props.top, left = props.left, width = props.width, height = props.height, clockWise = props.clockWise, labelViewBox = props.labelViewBox;
      if (labelViewBox)
        return labelViewBox;
      if ((0, _DataUtils.isNumber)(width) && (0, _DataUtils.isNumber)(height)) {
        if ((0, _DataUtils.isNumber)(x) && (0, _DataUtils.isNumber)(y))
          return {
            x,
            y,
            width,
            height
          };
        if ((0, _DataUtils.isNumber)(top) && (0, _DataUtils.isNumber)(left))
          return {
            x: top,
            y: left,
            width,
            height
          };
      }
      return (0, _DataUtils.isNumber)(x) && (0, _DataUtils.isNumber)(y) ? {
        x,
        y,
        width: 0,
        height: 0
      } : (0, _DataUtils.isNumber)(cx) && (0, _DataUtils.isNumber)(cy) ? {
        cx,
        cy,
        startAngle: startAngle || angle || 0,
        endAngle: endAngle || angle || 0,
        innerRadius: innerRadius || 0,
        outerRadius: outerRadius || radius || r || 0,
        clockWise
      } : props.viewBox ? props.viewBox : {};
    }, parseLabel = function(label, viewBox) {
      return label ? label === !0 ? /* @__PURE__ */ _react.default.createElement(Label2, {
        key: "label-implicit",
        viewBox
      }) : (0, _DataUtils.isNumOrStr)(label) ? /* @__PURE__ */ _react.default.createElement(Label2, {
        key: "label-implicit",
        viewBox,
        value: label
      }) : /* @__PURE__ */ (0, _react.isValidElement)(label) ? label.type === Label2 ? /* @__PURE__ */ (0, _react.cloneElement)(label, {
        key: "label-implicit",
        viewBox
      }) : /* @__PURE__ */ _react.default.createElement(Label2, {
        key: "label-implicit",
        content: label,
        viewBox
      }) : (0, _isFunction2.default)(label) ? /* @__PURE__ */ _react.default.createElement(Label2, {
        key: "label-implicit",
        content: label,
        viewBox
      }) : (0, _isObject2.default)(label) ? /* @__PURE__ */ _react.default.createElement(Label2, _extends({
        viewBox
      }, label, {
        key: "label-implicit"
      })) : null : null;
    }, renderCallByParent = function(parentProps, viewBox) {
      var checkPropsLabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
      if (!parentProps || !parentProps.children && checkPropsLabel && !parentProps.label)
        return null;
      var children = parentProps.children, parentViewBox = parseViewBox(parentProps), explicitChildren = (0, _ReactUtils.findAllByType)(children, Label2.displayName).map(function(child, index) {
        return /* @__PURE__ */ (0, _react.cloneElement)(child, {
          viewBox: viewBox || parentViewBox,
          key: "label-".concat(index)
        });
      });
      if (!checkPropsLabel)
        return explicitChildren;
      var implicitLabel = parseLabel(parentProps.label, viewBox || parentViewBox);
      return [implicitLabel].concat(_toConsumableArray(explicitChildren));
    };
    Label2.parseViewBox = parseViewBox;
    Label2.renderCallByParent = renderCallByParent;
  }
});

// node_modules/recharts/lib/component/LabelList.js
var require_LabelList = __commonJS({
  "node_modules/recharts/lib/component/LabelList.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.LabelList = LabelList2;
    var _isObject2 = _interopRequireDefault(require("lodash/isObject")), _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _isNil2 = _interopRequireDefault(require("lodash/isNil")), _last2 = _interopRequireDefault(require("lodash/last")), _isArray2 = _interopRequireDefault(require("lodash/isArray")), _react = _interopRequireWildcard(require("react")), _Label = require_Label(), _Layer = require_Layer(), _ReactUtils = require_ReactUtils(), _ChartUtils = require_ChartUtils(), _types = require_types();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!!o) {
        if (typeof o == "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
    }
    function _iterableToArray(iter) {
      if (typeof Symbol < "u" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose2(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source, key) || (target[key] = source[key]));
      }
      return target;
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    var defaultProps = {
      valueAccessor: function(entry2) {
        return (0, _isArray2.default)(entry2.value) ? (0, _last2.default)(entry2.value) : entry2.value;
      }
    };
    function LabelList2(props) {
      var data = props.data, valueAccessor = props.valueAccessor, dataKey = props.dataKey, clockWise = props.clockWise, id = props.id, textBreakAll = props.textBreakAll, others = _objectWithoutProperties2(props, ["data", "valueAccessor", "dataKey", "clockWise", "id", "textBreakAll"]);
      return !data || !data.length ? null : /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
        className: "recharts-label-list"
      }, data.map(function(entry2, index) {
        var value = (0, _isNil2.default)(dataKey) ? valueAccessor(entry2, index) : (0, _ChartUtils.getValueByDataKey)(entry2 && entry2.payload, dataKey), idProps = (0, _isNil2.default)(id) ? {} : {
          id: "".concat(id, "-").concat(index)
        };
        return /* @__PURE__ */ _react.default.createElement(_Label.Label, _extends({}, (0, _types.filterProps)(entry2, !0), others, idProps, {
          parentViewBox: entry2.parentViewBox,
          index,
          value,
          textBreakAll,
          viewBox: _Label.Label.parseViewBox((0, _isNil2.default)(clockWise) ? entry2 : _objectSpread3(_objectSpread3({}, entry2), {}, {
            clockWise
          })),
          key: "label-".concat(index)
        }));
      }));
    }
    LabelList2.displayName = "LabelList";
    function parseLabelList(label, data) {
      return label ? label === !0 ? /* @__PURE__ */ _react.default.createElement(LabelList2, {
        key: "labelList-implicit",
        data
      }) : /* @__PURE__ */ _react.default.isValidElement(label) || (0, _isFunction2.default)(label) ? /* @__PURE__ */ _react.default.createElement(LabelList2, {
        key: "labelList-implicit",
        data,
        content: label
      }) : (0, _isObject2.default)(label) ? /* @__PURE__ */ _react.default.createElement(LabelList2, _extends({
        data
      }, label, {
        key: "labelList-implicit"
      })) : null : null;
    }
    function renderCallByParent(parentProps, data) {
      var ckeckPropsLabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
      if (!parentProps || !parentProps.children && ckeckPropsLabel && !parentProps.label)
        return null;
      var children = parentProps.children, explicitChilren = (0, _ReactUtils.findAllByType)(children, LabelList2.displayName).map(function(child, index) {
        return /* @__PURE__ */ (0, _react.cloneElement)(child, {
          data,
          key: "labelList-".concat(index)
        });
      });
      if (!ckeckPropsLabel)
        return explicitChilren;
      var implicitLabelList = parseLabelList(parentProps.label, data);
      return [implicitLabelList].concat(_toConsumableArray(explicitChilren));
    }
    LabelList2.renderCallByParent = renderCallByParent;
    LabelList2.defaultProps = defaultProps;
  }
});

// node_modules/recharts/lib/component/Customized.js
var require_Customized = __commonJS({
  "node_modules/recharts/lib/component/Customized.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Customized = Customized;
    var _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _react = _interopRequireWildcard(require("react")), _Layer = require_Layer(), _LogUtils = require_LogUtils();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose2(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source, key) || (target[key] = source[key]));
      }
      return target;
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    function Customized(_ref) {
      var component = _ref.component, props = _objectWithoutProperties2(_ref, ["component"]), child;
      return /* @__PURE__ */ (0, _react.isValidElement)(component) ? child = /* @__PURE__ */ (0, _react.cloneElement)(component, props) : (0, _isFunction2.default)(component) ? child = /* @__PURE__ */ (0, _react.createElement)(component, props) : (0, _LogUtils.warn)(!1, "Customized's props `component` must be React.element or Function, but got %s.", _typeof2(component)), /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
        className: "recharts-customized-wrapper"
      }, child);
    }
    Customized.displayName = "Customized";
  }
});

// node_modules/recharts/lib/shape/Sector.js
var require_Sector = __commonJS({
  "node_modules/recharts/lib/shape/Sector.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Sector = void 0;
    var _react = _interopRequireWildcard(require("react")), _classnames = _interopRequireDefault(require("classnames")), _types = require_types(), _PolarUtils = require_PolarUtils(), _DataUtils = require_DataUtils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var getDeltaAngle = function(startAngle, endAngle) {
      var sign = (0, _DataUtils.mathSign)(endAngle - startAngle), deltaAngle = Math.min(Math.abs(endAngle - startAngle), 359.999);
      return sign * deltaAngle;
    }, getTangentCircle = function(_ref) {
      var cx = _ref.cx, cy = _ref.cy, radius = _ref.radius, angle = _ref.angle, sign = _ref.sign, isExternal = _ref.isExternal, cornerRadius = _ref.cornerRadius, cornerIsExternal = _ref.cornerIsExternal, centerRadius = cornerRadius * (isExternal ? 1 : -1) + radius, theta = Math.asin(cornerRadius / centerRadius) / _PolarUtils.RADIAN, centerAngle = cornerIsExternal ? angle : angle + sign * theta, center = (0, _PolarUtils.polarToCartesian)(cx, cy, centerRadius, centerAngle), circleTangency = (0, _PolarUtils.polarToCartesian)(cx, cy, radius, centerAngle), lineTangencyAngle = cornerIsExternal ? angle - sign * theta : angle, lineTangency = (0, _PolarUtils.polarToCartesian)(cx, cy, centerRadius * Math.cos(theta * _PolarUtils.RADIAN), lineTangencyAngle);
      return {
        center,
        circleTangency,
        lineTangency,
        theta
      };
    }, getSectorPath = function(_ref2) {
      var cx = _ref2.cx, cy = _ref2.cy, innerRadius = _ref2.innerRadius, outerRadius = _ref2.outerRadius, startAngle = _ref2.startAngle, endAngle = _ref2.endAngle, angle = getDeltaAngle(startAngle, endAngle), tempEndAngle = startAngle + angle, outerStartPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, outerRadius, startAngle), outerEndPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, outerRadius, tempEndAngle), path = "M ".concat(outerStartPoint.x, ",").concat(outerStartPoint.y, `
    A `).concat(outerRadius, ",").concat(outerRadius, `,0,
    `).concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle > tempEndAngle), `,
    `).concat(outerEndPoint.x, ",").concat(outerEndPoint.y, `
  `);
      if (innerRadius > 0) {
        var innerStartPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, innerRadius, startAngle), innerEndPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, innerRadius, tempEndAngle);
        path += "L ".concat(innerEndPoint.x, ",").concat(innerEndPoint.y, `
            A `).concat(innerRadius, ",").concat(innerRadius, `,0,
            `).concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle <= tempEndAngle), `,
            `).concat(innerStartPoint.x, ",").concat(innerStartPoint.y, " Z");
      } else
        path += "L ".concat(cx, ",").concat(cy, " Z");
      return path;
    }, getSectorWithCorner = function(_ref3) {
      var cx = _ref3.cx, cy = _ref3.cy, innerRadius = _ref3.innerRadius, outerRadius = _ref3.outerRadius, cornerRadius = _ref3.cornerRadius, forceCornerRadius = _ref3.forceCornerRadius, cornerIsExternal = _ref3.cornerIsExternal, startAngle = _ref3.startAngle, endAngle = _ref3.endAngle, sign = (0, _DataUtils.mathSign)(endAngle - startAngle), _getTangentCircle = getTangentCircle({
        cx,
        cy,
        radius: outerRadius,
        angle: startAngle,
        sign,
        cornerRadius,
        cornerIsExternal
      }), soct = _getTangentCircle.circleTangency, solt = _getTangentCircle.lineTangency, sot = _getTangentCircle.theta, _getTangentCircle2 = getTangentCircle({
        cx,
        cy,
        radius: outerRadius,
        angle: endAngle,
        sign: -sign,
        cornerRadius,
        cornerIsExternal
      }), eoct = _getTangentCircle2.circleTangency, eolt = _getTangentCircle2.lineTangency, eot = _getTangentCircle2.theta, outerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sot - eot;
      if (outerArcAngle < 0)
        return forceCornerRadius ? "M ".concat(solt.x, ",").concat(solt.y, `
        a`).concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(cornerRadius * 2, `,0
        a`).concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(-cornerRadius * 2, `,0
      `) : getSectorPath({
          cx,
          cy,
          innerRadius,
          outerRadius,
          startAngle,
          endAngle
        });
      var path = "M ".concat(solt.x, ",").concat(solt.y, `
    A`).concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign < 0), ",").concat(soct.x, ",").concat(soct.y, `
    A`).concat(outerRadius, ",").concat(outerRadius, ",0,").concat(+(outerArcAngle > 180), ",").concat(+(sign < 0), ",").concat(eoct.x, ",").concat(eoct.y, `
    A`).concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign < 0), ",").concat(eolt.x, ",").concat(eolt.y, `
  `);
      if (innerRadius > 0) {
        var _getTangentCircle3 = getTangentCircle({
          cx,
          cy,
          radius: innerRadius,
          angle: startAngle,
          sign,
          isExternal: !0,
          cornerRadius,
          cornerIsExternal
        }), sict = _getTangentCircle3.circleTangency, silt = _getTangentCircle3.lineTangency, sit = _getTangentCircle3.theta, _getTangentCircle4 = getTangentCircle({
          cx,
          cy,
          radius: innerRadius,
          angle: endAngle,
          sign: -sign,
          isExternal: !0,
          cornerRadius,
          cornerIsExternal
        }), eict = _getTangentCircle4.circleTangency, eilt = _getTangentCircle4.lineTangency, eit = _getTangentCircle4.theta, innerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sit - eit;
        if (innerArcAngle < 0 && cornerRadius === 0)
          return "".concat(path, "L").concat(cx, ",").concat(cy, "Z");
        path += "L".concat(eilt.x, ",").concat(eilt.y, `
      A`).concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign < 0), ",").concat(eict.x, ",").concat(eict.y, `
      A`).concat(innerRadius, ",").concat(innerRadius, ",0,").concat(+(innerArcAngle > 180), ",").concat(+(sign > 0), ",").concat(sict.x, ",").concat(sict.y, `
      A`).concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign < 0), ",").concat(silt.x, ",").concat(silt.y, "Z");
      } else
        path += "L".concat(cx, ",").concat(cy, "Z");
      return path;
    }, Sector = /* @__PURE__ */ function(_PureComponent) {
      _inherits(Sector2, _PureComponent);
      var _super = _createSuper(Sector2);
      function Sector2() {
        return _classCallCheck(this, Sector2), _super.apply(this, arguments);
      }
      return _createClass(Sector2, [{
        key: "render",
        value: function() {
          var _this$props = this.props, cx = _this$props.cx, cy = _this$props.cy, innerRadius = _this$props.innerRadius, outerRadius = _this$props.outerRadius, cornerRadius = _this$props.cornerRadius, forceCornerRadius = _this$props.forceCornerRadius, cornerIsExternal = _this$props.cornerIsExternal, startAngle = _this$props.startAngle, endAngle = _this$props.endAngle, className = _this$props.className;
          if (outerRadius < innerRadius || startAngle === endAngle)
            return null;
          var layerClass = (0, _classnames.default)("recharts-sector", className), deltaRadius = outerRadius - innerRadius, cr = (0, _DataUtils.getPercentValue)(cornerRadius, deltaRadius, 0, !0), path;
          return cr > 0 && Math.abs(startAngle - endAngle) < 360 ? path = getSectorWithCorner({
            cx,
            cy,
            innerRadius,
            outerRadius,
            cornerRadius: Math.min(cr, deltaRadius / 2),
            forceCornerRadius,
            cornerIsExternal,
            startAngle,
            endAngle
          }) : path = getSectorPath({
            cx,
            cy,
            innerRadius,
            outerRadius,
            startAngle,
            endAngle
          }), /* @__PURE__ */ _react.default.createElement("path", _extends({}, (0, _types.filterProps)(this.props, !0), {
            className: layerClass,
            d: path,
            role: "img"
          }));
        }
      }]), Sector2;
    }(_react.PureComponent);
    exports.Sector = Sector;
    Sector.defaultProps = {
      cx: 0,
      cy: 0,
      innerRadius: 0,
      outerRadius: 0,
      startAngle: 0,
      endAngle: 0,
      cornerRadius: 0,
      forceCornerRadius: !1,
      cornerIsExternal: !1
    };
  }
});

// node_modules/recharts/lib/shape/Curve.js
var require_Curve = __commonJS({
  "node_modules/recharts/lib/shape/Curve.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Curve = void 0;
    var _isArray2 = _interopRequireDefault(require("lodash/isArray")), _upperFirst2 = _interopRequireDefault(require("lodash/upperFirst")), _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _react = _interopRequireWildcard(require("react")), _d3Shape = require_d3_shape(), _classnames = _interopRequireDefault(require("classnames")), _types = require_types(), _DataUtils = require_DataUtils();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var CURVE_FACTORIES = {
      curveBasisClosed: _d3Shape.curveBasisClosed,
      curveBasisOpen: _d3Shape.curveBasisOpen,
      curveBasis: _d3Shape.curveBasis,
      curveLinearClosed: _d3Shape.curveLinearClosed,
      curveLinear: _d3Shape.curveLinear,
      curveMonotoneX: _d3Shape.curveMonotoneX,
      curveMonotoneY: _d3Shape.curveMonotoneY,
      curveNatural: _d3Shape.curveNatural,
      curveStep: _d3Shape.curveStep,
      curveStepAfter: _d3Shape.curveStepAfter,
      curveStepBefore: _d3Shape.curveStepBefore
    }, defined = function(p) {
      return p.x === +p.x && p.y === +p.y;
    }, getX = function(p) {
      return p.x;
    }, getY = function(p) {
      return p.y;
    }, getCurveFactory = function(type, layout) {
      if ((0, _isFunction2.default)(type))
        return type;
      var name = "curve".concat((0, _upperFirst2.default)(type));
      return name === "curveMonotone" && layout ? CURVE_FACTORIES["".concat(name).concat(layout === "vertical" ? "Y" : "X")] : CURVE_FACTORIES[name] || _d3Shape.curveLinear;
    }, Curve = /* @__PURE__ */ function(_PureComponent) {
      _inherits(Curve2, _PureComponent);
      var _super = _createSuper(Curve2);
      function Curve2() {
        return _classCallCheck(this, Curve2), _super.apply(this, arguments);
      }
      return _createClass(Curve2, [{
        key: "getPath",
        value: function() {
          var _this$props = this.props, type = _this$props.type, points = _this$props.points, baseLine = _this$props.baseLine, layout = _this$props.layout, connectNulls = _this$props.connectNulls, curveFactory = getCurveFactory(type, layout), formatPoints = connectNulls ? points.filter(function(entry2) {
            return defined(entry2);
          }) : points, lineFunction;
          if ((0, _isArray2.default)(baseLine)) {
            var formatBaseLine = connectNulls ? baseLine.filter(function(base) {
              return defined(base);
            }) : baseLine, areaPoints = formatPoints.map(function(entry2, index) {
              return _objectSpread3(_objectSpread3({}, entry2), {}, {
                base: formatBaseLine[index]
              });
            });
            return layout === "vertical" ? lineFunction = (0, _d3Shape.area)().y(getY).x1(getX).x0(function(d) {
              return d.base.x;
            }) : lineFunction = (0, _d3Shape.area)().x(getX).y1(getY).y0(function(d) {
              return d.base.y;
            }), lineFunction.defined(defined).curve(curveFactory), lineFunction(areaPoints);
          }
          return layout === "vertical" && (0, _DataUtils.isNumber)(baseLine) ? lineFunction = (0, _d3Shape.area)().y(getY).x1(getX).x0(baseLine) : (0, _DataUtils.isNumber)(baseLine) ? lineFunction = (0, _d3Shape.area)().x(getX).y1(getY).y0(baseLine) : lineFunction = (0, _d3Shape.line)().x(getX).y(getY), lineFunction.defined(defined).curve(curveFactory), lineFunction(formatPoints);
        }
      }, {
        key: "render",
        value: function() {
          var _this$props2 = this.props, className = _this$props2.className, points = _this$props2.points, path = _this$props2.path, pathRef = _this$props2.pathRef;
          if ((!points || !points.length) && !path)
            return null;
          var realPath = points && points.length ? this.getPath() : path;
          return /* @__PURE__ */ _react.default.createElement("path", _extends({}, (0, _types.filterProps)(this.props), (0, _types.adaptEventHandlers)(this.props), {
            className: (0, _classnames.default)("recharts-curve", className),
            d: realPath,
            ref: pathRef
          }));
        }
      }]), Curve2;
    }(_react.PureComponent);
    exports.Curve = Curve;
    Curve.defaultProps = {
      type: "linear",
      points: [],
      connectNulls: !1
    };
  }
});

// node_modules/recharts/lib/shape/Rectangle.js
var require_Rectangle = __commonJS({
  "node_modules/recharts/lib/shape/Rectangle.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Rectangle = exports.isInRectangle = void 0;
    var _react = _interopRequireWildcard(require("react")), _classnames = _interopRequireDefault(require("classnames")), _reactSmooth = _interopRequireDefault(require("react-smooth")), _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var getRectanglePath = function(x, y, width, height, radius) {
      var maxRadius = Math.min(Math.abs(width) / 2, Math.abs(height) / 2), ySign = height >= 0 ? 1 : -1, xSign = width >= 0 ? 1 : -1, clockWise = height >= 0 && width >= 0 || height < 0 && width < 0 ? 1 : 0, path;
      if (maxRadius > 0 && radius instanceof Array) {
        for (var newRadius = [0, 0, 0, 0], i = 0, len = 4; i < len; i++)
          newRadius[i] = radius[i] > maxRadius ? maxRadius : radius[i];
        path = "M".concat(x, ",").concat(y + ySign * newRadius[0]), newRadius[0] > 0 && (path += "A ".concat(newRadius[0], ",").concat(newRadius[0], ",0,0,").concat(clockWise, ",").concat(x + xSign * newRadius[0], ",").concat(y)), path += "L ".concat(x + width - xSign * newRadius[1], ",").concat(y), newRadius[1] > 0 && (path += "A ".concat(newRadius[1], ",").concat(newRadius[1], ",0,0,").concat(clockWise, `,
        `).concat(x + width, ",").concat(y + ySign * newRadius[1])), path += "L ".concat(x + width, ",").concat(y + height - ySign * newRadius[2]), newRadius[2] > 0 && (path += "A ".concat(newRadius[2], ",").concat(newRadius[2], ",0,0,").concat(clockWise, `,
        `).concat(x + width - xSign * newRadius[2], ",").concat(y + height)), path += "L ".concat(x + xSign * newRadius[3], ",").concat(y + height), newRadius[3] > 0 && (path += "A ".concat(newRadius[3], ",").concat(newRadius[3], ",0,0,").concat(clockWise, `,
        `).concat(x, ",").concat(y + height - ySign * newRadius[3])), path += "Z";
      } else if (maxRadius > 0 && radius === +radius && radius > 0) {
        var _newRadius = Math.min(maxRadius, radius);
        path = "M ".concat(x, ",").concat(y + ySign * _newRadius, `
            A `).concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x + xSign * _newRadius, ",").concat(y, `
            L `).concat(x + width - xSign * _newRadius, ",").concat(y, `
            A `).concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x + width, ",").concat(y + ySign * _newRadius, `
            L `).concat(x + width, ",").concat(y + height - ySign * _newRadius, `
            A `).concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x + width - xSign * _newRadius, ",").concat(y + height, `
            L `).concat(x + xSign * _newRadius, ",").concat(y + height, `
            A `).concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x, ",").concat(y + height - ySign * _newRadius, " Z");
      } else
        path = "M ".concat(x, ",").concat(y, " h ").concat(width, " v ").concat(height, " h ").concat(-width, " Z");
      return path;
    }, isInRectangle = function(point, rect) {
      if (!point || !rect)
        return !1;
      var px = point.x, py = point.y, x = rect.x, y = rect.y, width = rect.width, height = rect.height;
      if (Math.abs(width) > 0 && Math.abs(height) > 0) {
        var minX = Math.min(x, x + width), maxX = Math.max(x, x + width), minY = Math.min(y, y + height), maxY = Math.max(y, y + height);
        return px >= minX && px <= maxX && py >= minY && py <= maxY;
      }
      return !1;
    };
    exports.isInRectangle = isInRectangle;
    var Rectangle = /* @__PURE__ */ function(_PureComponent) {
      _inherits(Rectangle2, _PureComponent);
      var _super = _createSuper(Rectangle2);
      function Rectangle2() {
        var _this;
        _classCallCheck(this, Rectangle2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        return _this = _super.call.apply(_super, [this].concat(args)), _this.state = {
          totalLength: -1
        }, _this.node = void 0, _this;
      }
      return _createClass(Rectangle2, [{
        key: "componentDidMount",
        value: function() {
          if (this.node && this.node.getTotalLength)
            try {
              var totalLength = this.node.getTotalLength();
              totalLength && this.setState({
                totalLength
              });
            } catch {
            }
        }
      }, {
        key: "render",
        value: function() {
          var _this2 = this, _this$props = this.props, x = _this$props.x, y = _this$props.y, width = _this$props.width, height = _this$props.height, radius = _this$props.radius, className = _this$props.className, totalLength = this.state.totalLength, _this$props2 = this.props, animationEasing = _this$props2.animationEasing, animationDuration = _this$props2.animationDuration, animationBegin = _this$props2.animationBegin, isAnimationActive = _this$props2.isAnimationActive, isUpdateAnimationActive = _this$props2.isUpdateAnimationActive;
          if (x !== +x || y !== +y || width !== +width || height !== +height || width === 0 || height === 0)
            return null;
          var layerClass = (0, _classnames.default)("recharts-rectangle", className);
          return isUpdateAnimationActive ? /* @__PURE__ */ _react.default.createElement(_reactSmooth.default, {
            canBegin: totalLength > 0,
            from: {
              width,
              height,
              x,
              y
            },
            to: {
              width,
              height,
              x,
              y
            },
            duration: animationDuration,
            animationEasing,
            isActive: isUpdateAnimationActive
          }, function(_ref) {
            var currWidth = _ref.width, currHeight = _ref.height, currX = _ref.x, currY = _ref.y;
            return /* @__PURE__ */ _react.default.createElement(_reactSmooth.default, {
              canBegin: totalLength > 0,
              from: "0px ".concat(totalLength === -1 ? 1 : totalLength, "px"),
              to: "".concat(totalLength, "px 0px"),
              attributeName: "strokeDasharray",
              begin: animationBegin,
              duration: animationDuration,
              isActive: isAnimationActive,
              easing: animationEasing
            }, /* @__PURE__ */ _react.default.createElement("path", _extends({}, (0, _types.filterProps)(_this2.props, !0), {
              className: layerClass,
              d: getRectanglePath(currX, currY, currWidth, currHeight, radius),
              ref: function(node) {
                _this2.node = node;
              }
            })));
          }) : /* @__PURE__ */ _react.default.createElement("path", _extends({}, (0, _types.filterProps)(this.props, !0), {
            className: layerClass,
            d: getRectanglePath(x, y, width, height, radius)
          }));
        }
      }]), Rectangle2;
    }(_react.PureComponent);
    exports.Rectangle = Rectangle;
    Rectangle.defaultProps = {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      radius: 0,
      isAnimationActive: !1,
      isUpdateAnimationActive: !1,
      animationBegin: 0,
      animationDuration: 1500,
      animationEasing: "ease"
    };
  }
});

// node_modules/recharts/lib/shape/Polygon.js
var require_Polygon = __commonJS({
  "node_modules/recharts/lib/shape/Polygon.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Polygon = void 0;
    var _react = _interopRequireWildcard(require("react")), _classnames = _interopRequireDefault(require("classnames")), _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose2(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source, key) || (target[key] = source[key]));
      }
      return target;
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!!o) {
        if (typeof o == "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
    }
    function _iterableToArray(iter) {
      if (typeof Symbol < "u" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    var isValidatePoint = function(point) {
      return point && point.x === +point.x && point.y === +point.y;
    }, getParsedPoints = function() {
      var points = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], segmentPoints = [[]];
      return points.forEach(function(entry2) {
        isValidatePoint(entry2) ? segmentPoints[segmentPoints.length - 1].push(entry2) : segmentPoints[segmentPoints.length - 1].length > 0 && segmentPoints.push([]);
      }), isValidatePoint(points[0]) && segmentPoints[segmentPoints.length - 1].push(points[0]), segmentPoints[segmentPoints.length - 1].length <= 0 && (segmentPoints = segmentPoints.slice(0, -1)), segmentPoints;
    }, getSinglePolygonPath = function(points, connectNulls) {
      var segmentPoints = getParsedPoints(points);
      connectNulls && (segmentPoints = [segmentPoints.reduce(function(res, segPoints) {
        return [].concat(_toConsumableArray(res), _toConsumableArray(segPoints));
      }, [])]);
      var polygonPath = segmentPoints.map(function(segPoints) {
        return segPoints.reduce(function(path, point, index) {
          return "".concat(path).concat(index === 0 ? "M" : "L").concat(point.x, ",").concat(point.y);
        }, "");
      }).join("");
      return segmentPoints.length === 1 ? "".concat(polygonPath, "Z") : polygonPath;
    }, getRanglePath = function(points, baseLinePoints, connectNulls) {
      var outerPath = getSinglePolygonPath(points, connectNulls);
      return "".concat(outerPath.slice(-1) === "Z" ? outerPath.slice(0, -1) : outerPath, "L").concat(getSinglePolygonPath(baseLinePoints.reverse(), connectNulls).slice(1));
    }, Polygon = /* @__PURE__ */ function(_PureComponent) {
      _inherits(Polygon2, _PureComponent);
      var _super = _createSuper(Polygon2);
      function Polygon2() {
        return _classCallCheck(this, Polygon2), _super.apply(this, arguments);
      }
      return _createClass(Polygon2, [{
        key: "render",
        value: function() {
          var _this$props = this.props, points = _this$props.points, className = _this$props.className, baseLinePoints = _this$props.baseLinePoints, connectNulls = _this$props.connectNulls, others = _objectWithoutProperties2(_this$props, ["points", "className", "baseLinePoints", "connectNulls"]);
          if (!points || !points.length)
            return null;
          var layerClass = (0, _classnames.default)("recharts-polygon", className);
          if (baseLinePoints && baseLinePoints.length) {
            var hasStroke = others.stroke && others.stroke !== "none", rangePath = getRanglePath(points, baseLinePoints, connectNulls);
            return /* @__PURE__ */ _react.default.createElement("g", {
              className: layerClass
            }, /* @__PURE__ */ _react.default.createElement("path", _extends({}, (0, _types.filterProps)(others, !0), {
              fill: rangePath.slice(-1) === "Z" ? others.fill : "none",
              stroke: "none",
              d: rangePath
            })), hasStroke ? /* @__PURE__ */ _react.default.createElement("path", _extends({}, (0, _types.filterProps)(others, !0), {
              fill: "none",
              d: getSinglePolygonPath(points, connectNulls)
            })) : null, hasStroke ? /* @__PURE__ */ _react.default.createElement("path", _extends({}, (0, _types.filterProps)(others, !0), {
              fill: "none",
              d: getSinglePolygonPath(baseLinePoints, connectNulls)
            })) : null);
          }
          var singlePath = getSinglePolygonPath(points, connectNulls);
          return /* @__PURE__ */ _react.default.createElement("path", _extends({}, (0, _types.filterProps)(others, !0), {
            fill: singlePath.slice(-1) === "Z" ? others.fill : "none",
            className: layerClass,
            d: singlePath
          }));
        }
      }]), Polygon2;
    }(_react.PureComponent);
    exports.Polygon = Polygon;
  }
});

// node_modules/recharts/lib/shape/Dot.js
var require_Dot = __commonJS({
  "node_modules/recharts/lib/shape/Dot.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Dot = void 0;
    var _react = _interopRequireWildcard(require("react")), _classnames = _interopRequireDefault(require("classnames")), _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var Dot = /* @__PURE__ */ function(_PureComponent) {
      _inherits(Dot2, _PureComponent);
      var _super = _createSuper(Dot2);
      function Dot2() {
        return _classCallCheck(this, Dot2), _super.apply(this, arguments);
      }
      return _createClass(Dot2, [{
        key: "render",
        value: function() {
          var _this$props = this.props, cx = _this$props.cx, cy = _this$props.cy, r = _this$props.r, className = _this$props.className, layerClass = (0, _classnames.default)("recharts-dot", className);
          return cx === +cx && cy === +cy && r === +r ? /* @__PURE__ */ _react.default.createElement("circle", _extends({}, (0, _types.filterProps)(this.props), (0, _types.adaptEventHandlers)(this.props), {
            className: layerClass,
            cx,
            cy,
            r
          })) : null;
        }
      }]), Dot2;
    }(_react.PureComponent);
    exports.Dot = Dot;
  }
});

// node_modules/recharts/lib/shape/Cross.js
var require_Cross = __commonJS({
  "node_modules/recharts/lib/shape/Cross.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Cross = void 0;
    var _react = _interopRequireWildcard(require("react")), _classnames = _interopRequireDefault(require("classnames")), _DataUtils = require_DataUtils(), _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var Cross = /* @__PURE__ */ function(_PureComponent) {
      _inherits(Cross2, _PureComponent);
      var _super = _createSuper(Cross2);
      function Cross2() {
        return _classCallCheck(this, Cross2), _super.apply(this, arguments);
      }
      return _createClass(Cross2, [{
        key: "render",
        value: function() {
          var _this$props = this.props, x = _this$props.x, y = _this$props.y, width = _this$props.width, height = _this$props.height, top = _this$props.top, left = _this$props.left, className = _this$props.className;
          return !(0, _DataUtils.isNumber)(x) || !(0, _DataUtils.isNumber)(y) || !(0, _DataUtils.isNumber)(width) || !(0, _DataUtils.isNumber)(height) || !(0, _DataUtils.isNumber)(top) || !(0, _DataUtils.isNumber)(left) ? null : /* @__PURE__ */ _react.default.createElement("path", _extends({}, (0, _types.filterProps)(this.props, !0), {
            className: (0, _classnames.default)("recharts-cross", className),
            d: Cross2.getPath(x, y, width, height, top, left)
          }));
        }
      }], [{
        key: "getPath",
        value: function(x, y, width, height, top, left) {
          return "M".concat(x, ",").concat(top, "v").concat(height, "M").concat(left, ",").concat(y, "h").concat(width);
        }
      }]), Cross2;
    }(_react.PureComponent);
    exports.Cross = Cross;
    Cross.defaultProps = {
      x: 0,
      y: 0,
      top: 0,
      left: 0,
      width: 0,
      height: 0
    };
  }
});

// node_modules/recharts/lib/polar/PolarGrid.js
var require_PolarGrid = __commonJS({
  "node_modules/recharts/lib/polar/PolarGrid.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.PolarGrid = void 0;
    var _react = _interopRequireWildcard(require("react")), _PolarUtils = require_PolarUtils(), _types = require_types();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var PolarGrid = /* @__PURE__ */ function(_PureComponent) {
      _inherits(PolarGrid2, _PureComponent);
      var _super = _createSuper(PolarGrid2);
      function PolarGrid2() {
        return _classCallCheck(this, PolarGrid2), _super.apply(this, arguments);
      }
      return _createClass(PolarGrid2, [{
        key: "getPolygonPath",
        value: function(radius) {
          var _this$props = this.props, cx = _this$props.cx, cy = _this$props.cy, polarAngles = _this$props.polarAngles, path = "";
          return polarAngles.forEach(function(angle, i) {
            var point = (0, _PolarUtils.polarToCartesian)(cx, cy, radius, angle);
            i ? path += "L ".concat(point.x, ",").concat(point.y) : path += "M ".concat(point.x, ",").concat(point.y);
          }), path += "Z", path;
        }
      }, {
        key: "renderPolarAngles",
        value: function() {
          var _this$props2 = this.props, cx = _this$props2.cx, cy = _this$props2.cy, innerRadius = _this$props2.innerRadius, outerRadius = _this$props2.outerRadius, polarAngles = _this$props2.polarAngles, radialLines = _this$props2.radialLines;
          if (!polarAngles || !polarAngles.length || !radialLines)
            return null;
          var props = _objectSpread3({
            stroke: "#ccc"
          }, (0, _types.filterProps)(this.props));
          return /* @__PURE__ */ _react.default.createElement("g", {
            className: "recharts-polar-grid-angle"
          }, polarAngles.map(function(entry2, i) {
            var start = (0, _PolarUtils.polarToCartesian)(cx, cy, innerRadius, entry2), end = (0, _PolarUtils.polarToCartesian)(cx, cy, outerRadius, entry2);
            return /* @__PURE__ */ _react.default.createElement("line", _extends({}, props, {
              key: "line-".concat(i),
              x1: start.x,
              y1: start.y,
              x2: end.x,
              y2: end.y
            }));
          }));
        }
      }, {
        key: "renderConcentricCircle",
        value: function(radius, index, extraProps) {
          var _this$props3 = this.props, cx = _this$props3.cx, cy = _this$props3.cy, props = _objectSpread3(_objectSpread3({
            stroke: "#ccc"
          }, (0, _types.filterProps)(this.props)), {}, {
            fill: "none"
          }, extraProps);
          return /* @__PURE__ */ _react.default.createElement("circle", _extends({}, props, {
            className: "recharts-polar-grid-concentric-circle",
            key: "circle-".concat(index),
            cx,
            cy,
            r: radius
          }));
        }
      }, {
        key: "renderConcentricPolygon",
        value: function(radius, index, extraProps) {
          var props = _objectSpread3(_objectSpread3({
            stroke: "#ccc"
          }, (0, _types.filterProps)(this.props)), {}, {
            fill: "none"
          }, extraProps);
          return /* @__PURE__ */ _react.default.createElement("path", _extends({}, props, {
            className: "recharts-polar-grid-concentric-polygon",
            key: "path-".concat(index),
            d: this.getPolygonPath(radius)
          }));
        }
      }, {
        key: "renderConcentricPath",
        value: function() {
          var _this = this, _this$props4 = this.props, polarRadius = _this$props4.polarRadius, gridType = _this$props4.gridType;
          return !polarRadius || !polarRadius.length ? null : /* @__PURE__ */ _react.default.createElement("g", {
            className: "recharts-polar-grid-concentric"
          }, polarRadius.map(function(entry2, i) {
            return gridType === "circle" ? _this.renderConcentricCircle(entry2, i) : _this.renderConcentricPolygon(entry2, i);
          }));
        }
      }, {
        key: "render",
        value: function() {
          var outerRadius = this.props.outerRadius;
          return outerRadius <= 0 ? null : /* @__PURE__ */ _react.default.createElement("g", {
            className: "recharts-polar-grid"
          }, this.renderPolarAngles(), this.renderConcentricPath());
        }
      }]), PolarGrid2;
    }(_react.PureComponent);
    exports.PolarGrid = PolarGrid;
    PolarGrid.displayName = "PolarGrid";
    PolarGrid.defaultProps = {
      cx: 0,
      cy: 0,
      innerRadius: 0,
      outerRadius: 0,
      gridType: "polygon",
      radialLines: !0
    };
  }
});

// node_modules/recharts/lib/polar/PolarRadiusAxis.js
var require_PolarRadiusAxis = __commonJS({
  "node_modules/recharts/lib/polar/PolarRadiusAxis.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.PolarRadiusAxis = void 0;
    var _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _minBy2 = _interopRequireDefault(require("lodash/minBy")), _maxBy2 = _interopRequireDefault(require("lodash/maxBy")), _react = _interopRequireWildcard(require("react")), _Text = require_Text(), _Label = require_Label(), _Layer = require_Layer(), _PolarUtils = require_PolarUtils(), _types = require_types();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose2(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source, key) || (target[key] = source[key]));
      }
      return target;
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var PolarRadiusAxis2 = /* @__PURE__ */ function(_PureComponent) {
      _inherits(PolarRadiusAxis3, _PureComponent);
      var _super = _createSuper(PolarRadiusAxis3);
      function PolarRadiusAxis3() {
        return _classCallCheck(this, PolarRadiusAxis3), _super.apply(this, arguments);
      }
      return _createClass(PolarRadiusAxis3, [{
        key: "getTickValueCoord",
        value: function(_ref) {
          var coordinate = _ref.coordinate, _this$props = this.props, angle = _this$props.angle, cx = _this$props.cx, cy = _this$props.cy;
          return (0, _PolarUtils.polarToCartesian)(cx, cy, coordinate, angle);
        }
      }, {
        key: "getTickTextAnchor",
        value: function() {
          var orientation = this.props.orientation, textAnchor;
          switch (orientation) {
            case "left":
              textAnchor = "end";
              break;
            case "right":
              textAnchor = "start";
              break;
            default:
              textAnchor = "middle";
              break;
          }
          return textAnchor;
        }
      }, {
        key: "getViewBox",
        value: function() {
          var _this$props2 = this.props, cx = _this$props2.cx, cy = _this$props2.cy, angle = _this$props2.angle, ticks = _this$props2.ticks, maxRadiusTick = (0, _maxBy2.default)(ticks, function(entry2) {
            return entry2.coordinate || 0;
          }), minRadiusTick = (0, _minBy2.default)(ticks, function(entry2) {
            return entry2.coordinate || 0;
          });
          return {
            cx,
            cy,
            startAngle: angle,
            endAngle: angle,
            innerRadius: minRadiusTick.coordinate || 0,
            outerRadius: maxRadiusTick.coordinate || 0
          };
        }
      }, {
        key: "renderAxisLine",
        value: function() {
          var _this$props3 = this.props, cx = _this$props3.cx, cy = _this$props3.cy, angle = _this$props3.angle, ticks = _this$props3.ticks, axisLine = _this$props3.axisLine, others = _objectWithoutProperties2(_this$props3, ["cx", "cy", "angle", "ticks", "axisLine"]), extent = ticks.reduce(function(result, entry2) {
            return [Math.min(result[0], entry2.coordinate), Math.max(result[1], entry2.coordinate)];
          }, [1 / 0, -1 / 0]), point0 = (0, _PolarUtils.polarToCartesian)(cx, cy, extent[0], angle), point1 = (0, _PolarUtils.polarToCartesian)(cx, cy, extent[1], angle), props = _objectSpread3(_objectSpread3(_objectSpread3({}, (0, _types.filterProps)(others)), {}, {
            fill: "none"
          }, (0, _types.filterProps)(axisLine)), {}, {
            x1: point0.x,
            y1: point0.y,
            x2: point1.x,
            y2: point1.y
          });
          return /* @__PURE__ */ _react.default.createElement("line", _extends({
            className: "recharts-polar-radius-axis-line"
          }, props));
        }
      }, {
        key: "renderTicks",
        value: function() {
          var _this = this, _this$props4 = this.props, ticks = _this$props4.ticks, tick = _this$props4.tick, angle = _this$props4.angle, tickFormatter = _this$props4.tickFormatter, stroke = _this$props4.stroke, others = _objectWithoutProperties2(_this$props4, ["ticks", "tick", "angle", "tickFormatter", "stroke"]), textAnchor = this.getTickTextAnchor(), axisProps = (0, _types.filterProps)(others), customTickProps = (0, _types.filterProps)(tick), items = ticks.map(function(entry2, i) {
            var coord = _this.getTickValueCoord(entry2), tickProps = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({
              textAnchor,
              transform: "rotate(".concat(90 - angle, ", ").concat(coord.x, ", ").concat(coord.y, ")")
            }, axisProps), {}, {
              stroke: "none",
              fill: stroke
            }, customTickProps), {}, {
              index: i
            }, coord), {}, {
              payload: entry2
            });
            return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, _extends({
              className: "recharts-polar-radius-axis-tick",
              key: "tick-".concat(i)
            }, (0, _types.adaptEventsOfChild)(_this.props, entry2, i)), PolarRadiusAxis3.renderTickItem(tick, tickProps, tickFormatter ? tickFormatter(entry2.value, i) : entry2.value));
          });
          return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: "recharts-polar-radius-axis-ticks"
          }, items);
        }
      }, {
        key: "render",
        value: function() {
          var _this$props5 = this.props, ticks = _this$props5.ticks, axisLine = _this$props5.axisLine, tick = _this$props5.tick;
          return !ticks || !ticks.length ? null : /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: "recharts-polar-radius-axis"
          }, axisLine && this.renderAxisLine(), tick && this.renderTicks(), _Label.Label.renderCallByParent(this.props, this.getViewBox()));
        }
      }], [{
        key: "renderTickItem",
        value: function(option, props, value) {
          var tickItem;
          return /* @__PURE__ */ _react.default.isValidElement(option) ? tickItem = /* @__PURE__ */ _react.default.cloneElement(option, props) : (0, _isFunction2.default)(option) ? tickItem = option(props) : tickItem = /* @__PURE__ */ _react.default.createElement(_Text.Text, _extends({}, props, {
            className: "recharts-polar-radius-axis-tick-value"
          }), value), tickItem;
        }
      }]), PolarRadiusAxis3;
    }(_react.PureComponent);
    exports.PolarRadiusAxis = PolarRadiusAxis2;
    PolarRadiusAxis2.displayName = "PolarRadiusAxis";
    PolarRadiusAxis2.axisType = "radiusAxis";
    PolarRadiusAxis2.defaultProps = {
      type: "number",
      radiusAxisId: 0,
      cx: 0,
      cy: 0,
      angle: 0,
      orientation: "right",
      stroke: "#ccc",
      axisLine: !0,
      tick: !0,
      tickCount: 5,
      domain: [0, "auto"],
      allowDataOverflow: !1,
      scale: "auto",
      allowDuplicatedCategory: !0
    };
  }
});

// node_modules/recharts/lib/polar/PolarAngleAxis.js
var require_PolarAngleAxis = __commonJS({
  "node_modules/recharts/lib/polar/PolarAngleAxis.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.PolarAngleAxis = void 0;
    var _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _react = _interopRequireWildcard(require("react")), _Layer = require_Layer(), _Dot = require_Dot(), _Polygon = require_Polygon(), _Text = require_Text(), _types = require_types(), _PolarUtils = require_PolarUtils();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var RADIAN = Math.PI / 180, eps = 1e-5, PolarAngleAxis2 = /* @__PURE__ */ function(_PureComponent) {
      _inherits(PolarAngleAxis3, _PureComponent);
      var _super = _createSuper(PolarAngleAxis3);
      function PolarAngleAxis3() {
        return _classCallCheck(this, PolarAngleAxis3), _super.apply(this, arguments);
      }
      return _createClass(PolarAngleAxis3, [{
        key: "getTickLineCoord",
        value: function(data) {
          var _this$props = this.props, cx = _this$props.cx, cy = _this$props.cy, radius = _this$props.radius, orientation = _this$props.orientation, tickSize = _this$props.tickSize, tickLineSize = tickSize || 8, p1 = (0, _PolarUtils.polarToCartesian)(cx, cy, radius, data.coordinate), p2 = (0, _PolarUtils.polarToCartesian)(cx, cy, radius + (orientation === "inner" ? -1 : 1) * tickLineSize, data.coordinate);
          return {
            x1: p1.x,
            y1: p1.y,
            x2: p2.x,
            y2: p2.y
          };
        }
      }, {
        key: "getTickTextAnchor",
        value: function(data) {
          var orientation = this.props.orientation, cos = Math.cos(-data.coordinate * RADIAN), textAnchor;
          return cos > eps ? textAnchor = orientation === "outer" ? "start" : "end" : cos < -eps ? textAnchor = orientation === "outer" ? "end" : "start" : textAnchor = "middle", textAnchor;
        }
      }, {
        key: "renderAxisLine",
        value: function() {
          var _this$props2 = this.props, cx = _this$props2.cx, cy = _this$props2.cy, radius = _this$props2.radius, axisLine = _this$props2.axisLine, axisLineType = _this$props2.axisLineType, props = _objectSpread3(_objectSpread3({}, (0, _types.filterProps)(this.props)), {}, {
            fill: "none"
          }, (0, _types.filterProps)(axisLine));
          if (axisLineType === "circle")
            return /* @__PURE__ */ _react.default.createElement(_Dot.Dot, _extends({
              className: "recharts-polar-angle-axis-line"
            }, props, {
              cx,
              cy,
              r: radius
            }));
          var ticks = this.props.ticks, points = ticks.map(function(entry2) {
            return (0, _PolarUtils.polarToCartesian)(cx, cy, radius, entry2.coordinate);
          });
          return /* @__PURE__ */ _react.default.createElement(_Polygon.Polygon, _extends({
            className: "recharts-polar-angle-axis-line"
          }, props, {
            points
          }));
        }
      }, {
        key: "renderTicks",
        value: function() {
          var _this = this, _this$props3 = this.props, ticks = _this$props3.ticks, tick = _this$props3.tick, tickLine = _this$props3.tickLine, tickFormatter = _this$props3.tickFormatter, stroke = _this$props3.stroke, axisProps = (0, _types.filterProps)(this.props), customTickProps = (0, _types.filterProps)(tick), tickLineProps = _objectSpread3(_objectSpread3({}, axisProps), {}, {
            fill: "none"
          }, (0, _types.filterProps)(tickLine)), items = ticks.map(function(entry2, i) {
            var lineCoord = _this.getTickLineCoord(entry2), textAnchor = _this.getTickTextAnchor(entry2), tickProps = _objectSpread3(_objectSpread3(_objectSpread3({
              textAnchor
            }, axisProps), {}, {
              stroke: "none",
              fill: stroke
            }, customTickProps), {}, {
              index: i,
              payload: entry2,
              x: lineCoord.x2,
              y: lineCoord.y2
            });
            return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, _extends({
              className: "recharts-polar-angle-axis-tick",
              key: "tick-".concat(i)
            }, (0, _types.adaptEventsOfChild)(_this.props, entry2, i)), tickLine && /* @__PURE__ */ _react.default.createElement("line", _extends({
              className: "recharts-polar-angle-axis-tick-line"
            }, tickLineProps, lineCoord)), tick && PolarAngleAxis3.renderTickItem(tick, tickProps, tickFormatter ? tickFormatter(entry2.value, i) : entry2.value));
          });
          return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: "recharts-polar-angle-axis-ticks"
          }, items);
        }
      }, {
        key: "render",
        value: function() {
          var _this$props4 = this.props, ticks = _this$props4.ticks, radius = _this$props4.radius, axisLine = _this$props4.axisLine;
          return radius <= 0 || !ticks || !ticks.length ? null : /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: "recharts-polar-angle-axis"
          }, axisLine && this.renderAxisLine(), this.renderTicks());
        }
      }], [{
        key: "renderTickItem",
        value: function(option, props, value) {
          var tickItem;
          return /* @__PURE__ */ _react.default.isValidElement(option) ? tickItem = /* @__PURE__ */ _react.default.cloneElement(option, props) : (0, _isFunction2.default)(option) ? tickItem = option(props) : tickItem = /* @__PURE__ */ _react.default.createElement(_Text.Text, _extends({}, props, {
            className: "recharts-polar-angle-axis-tick-value"
          }), value), tickItem;
        }
      }]), PolarAngleAxis3;
    }(_react.PureComponent);
    exports.PolarAngleAxis = PolarAngleAxis2;
    PolarAngleAxis2.displayName = "PolarAngleAxis";
    PolarAngleAxis2.axisType = "angleAxis";
    PolarAngleAxis2.defaultProps = {
      type: "category",
      angleAxisId: 0,
      scale: "auto",
      cx: 0,
      cy: 0,
      domain: [0, "auto"],
      orientation: "outer",
      axisLine: !0,
      tickLine: !0,
      tickSize: 8,
      tick: !0,
      hide: !1,
      allowDuplicatedCategory: !0
    };
  }
});

// node_modules/recharts/lib/polar/Pie.js
var require_Pie = __commonJS({
  "node_modules/recharts/lib/polar/Pie.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Pie = void 0;
    var _isEqual2 = _interopRequireDefault(require("lodash/isEqual")), _get2 = _interopRequireDefault(require("lodash/get")), _isPlainObject2 = _interopRequireDefault(require("lodash/isPlainObject")), _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _isNil2 = _interopRequireDefault(require("lodash/isNil")), _react = _interopRequireWildcard(require("react")), _reactSmooth = _interopRequireDefault(require("react-smooth")), _classnames = _interopRequireDefault(require("classnames")), _Layer = require_Layer(), _Sector = require_Sector(), _Curve = require_Curve(), _Text = require_Text(), _Label = require_Label(), _LabelList = require_LabelList(), _Cell = require_Cell(), _ReactUtils = require_ReactUtils(), _Global = require_Global(), _PolarUtils = require_PolarUtils(), _DataUtils = require_DataUtils(), _ChartUtils = require_ChartUtils(), _LogUtils = require_LogUtils(), _types = require_types();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var Pie = /* @__PURE__ */ function(_PureComponent) {
      _inherits(Pie2, _PureComponent);
      var _super = _createSuper(Pie2);
      function Pie2(props) {
        var _this;
        return _classCallCheck(this, Pie2), _this = _super.call(this, props), _this.pieRef = null, _this.sectorRefs = [], _this.state = void 0, _this.id = (0, _DataUtils.uniqueId)("recharts-pie-"), _this.handleAnimationEnd = function() {
          var onAnimationEnd = _this.props.onAnimationEnd;
          _this.setState({
            isAnimationFinished: !0
          }), (0, _isFunction2.default)(onAnimationEnd) && onAnimationEnd();
        }, _this.handleAnimationStart = function() {
          var onAnimationStart = _this.props.onAnimationStart;
          _this.setState({
            isAnimationFinished: !1
          }), (0, _isFunction2.default)(onAnimationStart) && onAnimationStart();
        }, _this.state = {
          isAnimationFinished: !props.isAnimationActive,
          prevIsAnimationActive: props.isAnimationActive,
          prevAnimationId: props.animationId,
          sectorToFocus: 0
        }, _this;
      }
      return _createClass(Pie2, [{
        key: "isActiveIndex",
        value: function(i) {
          var activeIndex = this.props.activeIndex;
          return Array.isArray(activeIndex) ? activeIndex.indexOf(i) !== -1 : i === activeIndex;
        }
      }, {
        key: "hasActiveIndex",
        value: function() {
          var activeIndex = this.props.activeIndex;
          return Array.isArray(activeIndex) ? activeIndex.length !== 0 : activeIndex || activeIndex === 0;
        }
      }, {
        key: "renderLabels",
        value: function(sectors) {
          var isAnimationActive = this.props.isAnimationActive;
          if (isAnimationActive && !this.state.isAnimationFinished)
            return null;
          var _this$props = this.props, label = _this$props.label, labelLine = _this$props.labelLine, dataKey = _this$props.dataKey, valueKey = _this$props.valueKey, pieProps = (0, _types.filterProps)(this.props), customLabelProps = (0, _types.filterProps)(label), customLabelLineProps = (0, _types.filterProps)(labelLine), offsetRadius = label && label.offsetRadius || 20, labels = sectors.map(function(entry2, i) {
            var midAngle = (entry2.startAngle + entry2.endAngle) / 2, endPoint = (0, _PolarUtils.polarToCartesian)(entry2.cx, entry2.cy, entry2.outerRadius + offsetRadius, midAngle), labelProps = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, pieProps), entry2), {}, {
              stroke: "none"
            }, customLabelProps), {}, {
              index: i,
              textAnchor: Pie2.getTextAnchor(endPoint.x, entry2.cx)
            }, endPoint), lineProps = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, pieProps), entry2), {}, {
              fill: "none",
              stroke: entry2.fill
            }, customLabelLineProps), {}, {
              index: i,
              points: [(0, _PolarUtils.polarToCartesian)(entry2.cx, entry2.cy, entry2.outerRadius, midAngle), endPoint],
              key: "line"
            }), realDataKey = dataKey;
            return (0, _isNil2.default)(dataKey) && (0, _isNil2.default)(valueKey) ? realDataKey = "value" : (0, _isNil2.default)(dataKey) && (realDataKey = valueKey), /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
              key: "label-".concat(i)
            }, labelLine && Pie2.renderLabelLineItem(labelLine, lineProps), Pie2.renderLabelItem(label, labelProps, (0, _ChartUtils.getValueByDataKey)(entry2, realDataKey)));
          });
          return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: "recharts-pie-labels"
          }, labels);
        }
      }, {
        key: "renderSectorsStatically",
        value: function(sectors) {
          var _this2 = this, _this$props2 = this.props, activeShape = _this$props2.activeShape, blendStroke = _this$props2.blendStroke, inactiveShapeProp = _this$props2.inactiveShape;
          return sectors.map(function(entry2, i) {
            var inactiveShape = inactiveShapeProp && _this2.hasActiveIndex() ? inactiveShapeProp : null, sectorOptions = _this2.isActiveIndex(i) ? activeShape : inactiveShape, sectorProps = _objectSpread3(_objectSpread3({}, entry2), {}, {
              stroke: blendStroke ? entry2.fill : entry2.stroke
            });
            return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, _extends({
              ref: function(_ref) {
                _ref && !_this2.sectorRefs.includes(_ref) && _this2.sectorRefs.push(_ref);
              },
              tabIndex: -1,
              className: "recharts-pie-sector"
            }, (0, _types.adaptEventsOfChild)(_this2.props, entry2, i), {
              key: "sector-".concat(i)
            }), Pie2.renderSectorItem(sectorOptions, sectorProps));
          });
        }
      }, {
        key: "renderSectorsWithAnimation",
        value: function() {
          var _this3 = this, _this$props3 = this.props, sectors = _this$props3.sectors, isAnimationActive = _this$props3.isAnimationActive, animationBegin = _this$props3.animationBegin, animationDuration = _this$props3.animationDuration, animationEasing = _this$props3.animationEasing, animationId = _this$props3.animationId, _this$state = this.state, prevSectors = _this$state.prevSectors, prevIsAnimationActive = _this$state.prevIsAnimationActive;
          return /* @__PURE__ */ _react.default.createElement(_reactSmooth.default, {
            begin: animationBegin,
            duration: animationDuration,
            isActive: isAnimationActive,
            easing: animationEasing,
            from: {
              t: 0
            },
            to: {
              t: 1
            },
            key: "pie-".concat(animationId, "-").concat(prevIsAnimationActive),
            onAnimationStart: this.handleAnimationStart,
            onAnimationEnd: this.handleAnimationEnd
          }, function(_ref2) {
            var t = _ref2.t, stepData = [], first = sectors && sectors[0], curAngle = first.startAngle;
            return sectors.forEach(function(entry2, index) {
              var prev = prevSectors && prevSectors[index], paddingAngle = index > 0 ? (0, _get2.default)(entry2, "paddingAngle", 0) : 0;
              if (prev) {
                var angleIp = (0, _DataUtils.interpolateNumber)(prev.endAngle - prev.startAngle, entry2.endAngle - entry2.startAngle), latest = _objectSpread3(_objectSpread3({}, entry2), {}, {
                  startAngle: curAngle + paddingAngle,
                  endAngle: curAngle + angleIp(t) + paddingAngle
                });
                stepData.push(latest), curAngle = latest.endAngle;
              } else {
                var endAngle = entry2.endAngle, startAngle = entry2.startAngle, interpolatorAngle = (0, _DataUtils.interpolateNumber)(0, endAngle - startAngle), deltaAngle = interpolatorAngle(t), _latest = _objectSpread3(_objectSpread3({}, entry2), {}, {
                  startAngle: curAngle + paddingAngle,
                  endAngle: curAngle + deltaAngle + paddingAngle
                });
                stepData.push(_latest), curAngle = _latest.endAngle;
              }
            }), /* @__PURE__ */ _react.default.createElement(_Layer.Layer, null, _this3.renderSectorsStatically(stepData));
          });
        }
      }, {
        key: "attachKeyboardHandlers",
        value: function(pieRef) {
          var _this4 = this;
          pieRef.onkeydown = function(e) {
            if (!e.altKey)
              switch (e.key) {
                case "ArrowLeft": {
                  var next = ++_this4.state.sectorToFocus % _this4.sectorRefs.length;
                  _this4.sectorRefs[next].focus(), _this4.setState({
                    sectorToFocus: next
                  });
                  break;
                }
                case "ArrowRight": {
                  var _next = --_this4.state.sectorToFocus < 0 ? _this4.sectorRefs.length - 1 : _this4.state.sectorToFocus % _this4.sectorRefs.length;
                  _this4.sectorRefs[_next].focus(), _this4.setState({
                    sectorToFocus: _next
                  });
                  break;
                }
                case "Escape": {
                  _this4.sectorRefs[_this4.state.sectorToFocus].blur(), _this4.setState({
                    sectorToFocus: 0
                  });
                  break;
                }
                default:
              }
          };
        }
      }, {
        key: "renderSectors",
        value: function() {
          var _this$props4 = this.props, sectors = _this$props4.sectors, isAnimationActive = _this$props4.isAnimationActive, prevSectors = this.state.prevSectors;
          return isAnimationActive && sectors && sectors.length && (!prevSectors || !(0, _isEqual2.default)(prevSectors, sectors)) ? this.renderSectorsWithAnimation() : this.renderSectorsStatically(sectors);
        }
      }, {
        key: "componentDidMount",
        value: function() {
          this.pieRef && this.attachKeyboardHandlers(this.pieRef);
        }
      }, {
        key: "render",
        value: function() {
          var _this5 = this, _this$props5 = this.props, hide = _this$props5.hide, sectors = _this$props5.sectors, className = _this$props5.className, label = _this$props5.label, cx = _this$props5.cx, cy = _this$props5.cy, innerRadius = _this$props5.innerRadius, outerRadius = _this$props5.outerRadius, isAnimationActive = _this$props5.isAnimationActive, isAnimationFinished = this.state.isAnimationFinished;
          if (hide || !sectors || !sectors.length || !(0, _DataUtils.isNumber)(cx) || !(0, _DataUtils.isNumber)(cy) || !(0, _DataUtils.isNumber)(innerRadius) || !(0, _DataUtils.isNumber)(outerRadius))
            return null;
          var layerClass = (0, _classnames.default)("recharts-pie", className);
          return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            tabIndex: 0,
            className: layerClass,
            ref: function(_ref3) {
              _this5.pieRef = _ref3;
            }
          }, this.renderSectors(), label && this.renderLabels(sectors), _Label.Label.renderCallByParent(this.props, null, !1), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(this.props, sectors, !1));
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function(nextProps, prevState) {
          return prevState.prevIsAnimationActive !== nextProps.isAnimationActive ? {
            prevIsAnimationActive: nextProps.isAnimationActive,
            prevAnimationId: nextProps.animationId,
            curSectors: nextProps.sectors,
            prevSectors: [],
            isAnimationFinished: !0
          } : nextProps.isAnimationActive && nextProps.animationId !== prevState.prevAnimationId ? {
            prevAnimationId: nextProps.animationId,
            curSectors: nextProps.sectors,
            prevSectors: prevState.curSectors,
            isAnimationFinished: !0
          } : nextProps.sectors !== prevState.curSectors ? {
            curSectors: nextProps.sectors,
            isAnimationFinished: !0
          } : null;
        }
      }, {
        key: "getTextAnchor",
        value: function(x, cx) {
          return x > cx ? "start" : x < cx ? "end" : "middle";
        }
      }, {
        key: "renderLabelLineItem",
        value: function(option, props) {
          return /* @__PURE__ */ _react.default.isValidElement(option) ? /* @__PURE__ */ _react.default.cloneElement(option, props) : (0, _isFunction2.default)(option) ? option(props) : /* @__PURE__ */ _react.default.createElement(_Curve.Curve, _extends({}, props, {
            type: "linear",
            className: "recharts-pie-label-line"
          }));
        }
      }, {
        key: "renderLabelItem",
        value: function(option, props, value) {
          if (/* @__PURE__ */ _react.default.isValidElement(option))
            return /* @__PURE__ */ _react.default.cloneElement(option, props);
          var label = value;
          return (0, _isFunction2.default)(option) && (label = option(props), /* @__PURE__ */ _react.default.isValidElement(label)) ? label : /* @__PURE__ */ _react.default.createElement(_Text.Text, _extends({}, props, {
            alignmentBaseline: "middle",
            className: "recharts-pie-label-text"
          }), label);
        }
      }, {
        key: "renderSectorItem",
        value: function(option, props) {
          return /* @__PURE__ */ _react.default.isValidElement(option) ? /* @__PURE__ */ _react.default.cloneElement(option, props) : (0, _isFunction2.default)(option) ? option(props) : (0, _isPlainObject2.default)(option) ? /* @__PURE__ */ _react.default.createElement(_Sector.Sector, _extends({
            tabIndex: -1
          }, props, option)) : /* @__PURE__ */ _react.default.createElement(_Sector.Sector, _extends({
            tabIndex: -1
          }, props));
        }
      }]), Pie2;
    }(_react.PureComponent);
    exports.Pie = Pie;
    Pie.displayName = "Pie";
    Pie.defaultProps = {
      stroke: "#fff",
      fill: "#808080",
      legendType: "rect",
      cx: "50%",
      cy: "50%",
      startAngle: 0,
      endAngle: 360,
      innerRadius: 0,
      outerRadius: "80%",
      paddingAngle: 0,
      labelLine: !0,
      hide: !1,
      minAngle: 0,
      isAnimationActive: !_Global.Global.isSsr,
      animationBegin: 400,
      animationDuration: 1500,
      animationEasing: "ease",
      nameKey: "name",
      blendStroke: !1
    };
    Pie.parseDeltaAngle = function(startAngle, endAngle) {
      var sign = (0, _DataUtils.mathSign)(endAngle - startAngle), deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);
      return sign * deltaAngle;
    };
    Pie.getRealPieData = function(item) {
      var _item$props = item.props, data = _item$props.data, children = _item$props.children, presentationProps = (0, _types.filterProps)(item.props), cells = (0, _ReactUtils.findAllByType)(children, _Cell.Cell.displayName);
      return data && data.length ? data.map(function(entry2, index) {
        return _objectSpread3(_objectSpread3(_objectSpread3({
          payload: entry2
        }, presentationProps), entry2), cells && cells[index] && cells[index].props);
      }) : cells && cells.length ? cells.map(function(cell) {
        return _objectSpread3(_objectSpread3({}, presentationProps), cell.props);
      }) : [];
    };
    Pie.parseCoordinateOfPie = function(item, offset) {
      var top = offset.top, left = offset.left, width = offset.width, height = offset.height, maxPieRadius = (0, _PolarUtils.getMaxRadius)(width, height), cx = left + (0, _DataUtils.getPercentValue)(item.props.cx, width, width / 2), cy = top + (0, _DataUtils.getPercentValue)(item.props.cy, height, height / 2), innerRadius = (0, _DataUtils.getPercentValue)(item.props.innerRadius, maxPieRadius, 0), outerRadius = (0, _DataUtils.getPercentValue)(item.props.outerRadius, maxPieRadius, maxPieRadius * 0.8), maxRadius = item.props.maxRadius || Math.sqrt(width * width + height * height) / 2;
      return {
        cx,
        cy,
        innerRadius,
        outerRadius,
        maxRadius
      };
    };
    Pie.getComposedData = function(_ref4) {
      var item = _ref4.item, offset = _ref4.offset, pieData = Pie.getRealPieData(item);
      if (!pieData || !pieData.length)
        return null;
      var _item$props2 = item.props, cornerRadius = _item$props2.cornerRadius, startAngle = _item$props2.startAngle, endAngle = _item$props2.endAngle, paddingAngle = _item$props2.paddingAngle, dataKey = _item$props2.dataKey, nameKey = _item$props2.nameKey, valueKey = _item$props2.valueKey, tooltipType = _item$props2.tooltipType, minAngle = Math.abs(item.props.minAngle), coordinate = Pie.parseCoordinateOfPie(item, offset), deltaAngle = Pie.parseDeltaAngle(startAngle, endAngle), absDeltaAngle = Math.abs(deltaAngle), realDataKey = dataKey;
      (0, _isNil2.default)(dataKey) && (0, _isNil2.default)(valueKey) ? ((0, _LogUtils.warn)(!1, `Use "dataKey" to specify the value of pie,
      the props "valueKey" will be deprecated in 1.1.0`), realDataKey = "value") : (0, _isNil2.default)(dataKey) && ((0, _LogUtils.warn)(!1, `Use "dataKey" to specify the value of pie,
      the props "valueKey" will be deprecated in 1.1.0`), realDataKey = valueKey);
      var notZeroItemCount = pieData.filter(function(entry2) {
        return (0, _ChartUtils.getValueByDataKey)(entry2, realDataKey, 0) !== 0;
      }).length, totalPadingAngle = (absDeltaAngle >= 360 ? notZeroItemCount : notZeroItemCount - 1) * paddingAngle, realTotalAngle = absDeltaAngle - notZeroItemCount * minAngle - totalPadingAngle, sum = pieData.reduce(function(result, entry2) {
        var val = (0, _ChartUtils.getValueByDataKey)(entry2, realDataKey, 0);
        return result + ((0, _DataUtils.isNumber)(val) ? val : 0);
      }, 0), sectors;
      if (sum > 0) {
        var prev;
        sectors = pieData.map(function(entry2, i) {
          var val = (0, _ChartUtils.getValueByDataKey)(entry2, realDataKey, 0), name = (0, _ChartUtils.getValueByDataKey)(entry2, nameKey, i), percent = ((0, _DataUtils.isNumber)(val) ? val : 0) / sum, tempStartAngle;
          i ? tempStartAngle = prev.endAngle + (0, _DataUtils.mathSign)(deltaAngle) * paddingAngle * (val !== 0 ? 1 : 0) : tempStartAngle = startAngle;
          var tempEndAngle = tempStartAngle + (0, _DataUtils.mathSign)(deltaAngle) * ((val !== 0 ? minAngle : 0) + percent * realTotalAngle), midAngle = (tempStartAngle + tempEndAngle) / 2, middleRadius = (coordinate.innerRadius + coordinate.outerRadius) / 2, tooltipPayload = [{
            name,
            value: val,
            payload: entry2,
            dataKey: realDataKey,
            type: tooltipType
          }], tooltipPosition = (0, _PolarUtils.polarToCartesian)(coordinate.cx, coordinate.cy, middleRadius, midAngle);
          return prev = _objectSpread3(_objectSpread3(_objectSpread3({
            percent,
            cornerRadius,
            name,
            tooltipPayload,
            midAngle,
            middleRadius,
            tooltipPosition
          }, entry2), coordinate), {}, {
            value: (0, _ChartUtils.getValueByDataKey)(entry2, realDataKey),
            startAngle: tempStartAngle,
            endAngle: tempEndAngle,
            payload: entry2,
            paddingAngle: (0, _DataUtils.mathSign)(deltaAngle) * paddingAngle
          }), prev;
        });
      }
      return _objectSpread3(_objectSpread3({}, coordinate), {}, {
        sectors,
        data: pieData
      });
    };
  }
});

// node_modules/recharts/lib/polar/Radar.js
var require_Radar = __commonJS({
  "node_modules/recharts/lib/polar/Radar.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Radar = void 0;
    var _isEqual2 = _interopRequireDefault(require("lodash/isEqual")), _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _first2 = _interopRequireDefault(require("lodash/first")), _isNil2 = _interopRequireDefault(require("lodash/isNil")), _last2 = _interopRequireDefault(require("lodash/last")), _isArray2 = _interopRequireDefault(require("lodash/isArray")), _react = _interopRequireWildcard(require("react")), _reactSmooth = _interopRequireDefault(require("react-smooth")), _classnames = _interopRequireDefault(require("classnames")), _DataUtils = require_DataUtils(), _Global = require_Global(), _PolarUtils = require_PolarUtils(), _ChartUtils = require_ChartUtils(), _Polygon = require_Polygon(), _Dot = require_Dot(), _Layer = require_Layer(), _LabelList = require_LabelList(), _types = require_types();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var Radar = /* @__PURE__ */ function(_PureComponent) {
      _inherits(Radar2, _PureComponent);
      var _super = _createSuper(Radar2);
      function Radar2() {
        var _this;
        _classCallCheck(this, Radar2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        return _this = _super.call.apply(_super, [this].concat(args)), _this.state = {
          isAnimationFinished: !1
        }, _this.handleAnimationEnd = function() {
          var onAnimationEnd = _this.props.onAnimationEnd;
          _this.setState({
            isAnimationFinished: !0
          }), (0, _isFunction2.default)(onAnimationEnd) && onAnimationEnd();
        }, _this.handleAnimationStart = function() {
          var onAnimationStart = _this.props.onAnimationStart;
          _this.setState({
            isAnimationFinished: !1
          }), (0, _isFunction2.default)(onAnimationStart) && onAnimationStart();
        }, _this.handleMouseEnter = function(e) {
          var onMouseEnter = _this.props.onMouseEnter;
          onMouseEnter && onMouseEnter(_this.props, e);
        }, _this.handleMouseLeave = function(e) {
          var onMouseLeave = _this.props.onMouseLeave;
          onMouseLeave && onMouseLeave(_this.props, e);
        }, _this;
      }
      return _createClass(Radar2, [{
        key: "renderDots",
        value: function(points) {
          var _this$props = this.props, dot = _this$props.dot, dataKey = _this$props.dataKey, baseProps = (0, _types.filterProps)(this.props), customDotProps = (0, _types.filterProps)(dot), dots = points.map(function(entry2, i) {
            var dotProps = _objectSpread3(_objectSpread3(_objectSpread3({
              key: "dot-".concat(i),
              r: 3
            }, baseProps), customDotProps), {}, {
              dataKey,
              cx: entry2.x,
              cy: entry2.y,
              index: i,
              payload: entry2
            });
            return Radar2.renderDotItem(dot, dotProps);
          });
          return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: "recharts-radar-dots"
          }, dots);
        }
      }, {
        key: "renderPolygonStatically",
        value: function(points) {
          var _this$props2 = this.props, shape = _this$props2.shape, dot = _this$props2.dot, isRange = _this$props2.isRange, baseLinePoints = _this$props2.baseLinePoints, connectNulls = _this$props2.connectNulls, radar;
          return /* @__PURE__ */ _react.default.isValidElement(shape) ? radar = /* @__PURE__ */ _react.default.cloneElement(shape, _objectSpread3(_objectSpread3({}, this.props), {}, {
            points
          })) : (0, _isFunction2.default)(shape) ? radar = shape(_objectSpread3(_objectSpread3({}, this.props), {}, {
            points
          })) : radar = /* @__PURE__ */ _react.default.createElement(_Polygon.Polygon, _extends({}, (0, _types.filterProps)(this.props, !0), {
            onMouseEnter: this.handleMouseEnter,
            onMouseLeave: this.handleMouseLeave,
            points,
            baseLinePoints: isRange ? baseLinePoints : null,
            connectNulls
          })), /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: "recharts-radar-polygon"
          }, radar, dot ? this.renderDots(points) : null);
        }
      }, {
        key: "renderPolygonWithAnimation",
        value: function() {
          var _this2 = this, _this$props3 = this.props, points = _this$props3.points, isAnimationActive = _this$props3.isAnimationActive, animationBegin = _this$props3.animationBegin, animationDuration = _this$props3.animationDuration, animationEasing = _this$props3.animationEasing, animationId = _this$props3.animationId, prevPoints = this.state.prevPoints;
          return /* @__PURE__ */ _react.default.createElement(_reactSmooth.default, {
            begin: animationBegin,
            duration: animationDuration,
            isActive: isAnimationActive,
            easing: animationEasing,
            from: {
              t: 0
            },
            to: {
              t: 1
            },
            key: "radar-".concat(animationId),
            onAnimationEnd: this.handleAnimationEnd,
            onAnimationStart: this.handleAnimationStart
          }, function(_ref) {
            var t = _ref.t, prevPointsDiffFactor = prevPoints && prevPoints.length / points.length, stepData = points.map(function(entry2, index) {
              var prev = prevPoints && prevPoints[Math.floor(index * prevPointsDiffFactor)];
              if (prev) {
                var _interpolatorX = (0, _DataUtils.interpolateNumber)(prev.x, entry2.x), _interpolatorY = (0, _DataUtils.interpolateNumber)(prev.y, entry2.y);
                return _objectSpread3(_objectSpread3({}, entry2), {}, {
                  x: _interpolatorX(t),
                  y: _interpolatorY(t)
                });
              }
              var interpolatorX = (0, _DataUtils.interpolateNumber)(entry2.cx, entry2.x), interpolatorY = (0, _DataUtils.interpolateNumber)(entry2.cy, entry2.y);
              return _objectSpread3(_objectSpread3({}, entry2), {}, {
                x: interpolatorX(t),
                y: interpolatorY(t)
              });
            });
            return _this2.renderPolygonStatically(stepData);
          });
        }
      }, {
        key: "renderPolygon",
        value: function() {
          var _this$props4 = this.props, points = _this$props4.points, isAnimationActive = _this$props4.isAnimationActive, isRange = _this$props4.isRange, prevPoints = this.state.prevPoints;
          return isAnimationActive && points && points.length && !isRange && (!prevPoints || !(0, _isEqual2.default)(prevPoints, points)) ? this.renderPolygonWithAnimation() : this.renderPolygonStatically(points);
        }
      }, {
        key: "render",
        value: function() {
          var _this$props5 = this.props, hide = _this$props5.hide, className = _this$props5.className, points = _this$props5.points, isAnimationActive = _this$props5.isAnimationActive;
          if (hide || !points || !points.length)
            return null;
          var isAnimationFinished = this.state.isAnimationFinished, layerClass = (0, _classnames.default)("recharts-radar", className);
          return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: layerClass
          }, this.renderPolygon(), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(this.props, points));
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function(nextProps, prevState) {
          return nextProps.animationId !== prevState.prevAnimationId ? {
            prevAnimationId: nextProps.animationId,
            curPoints: nextProps.points,
            prevPoints: prevState.curPoints
          } : nextProps.points !== prevState.curPoints ? {
            curPoints: nextProps.points
          } : null;
        }
      }, {
        key: "renderDotItem",
        value: function(option, props) {
          var dotItem;
          return /* @__PURE__ */ _react.default.isValidElement(option) ? dotItem = /* @__PURE__ */ _react.default.cloneElement(option, props) : (0, _isFunction2.default)(option) ? dotItem = option(props) : dotItem = /* @__PURE__ */ _react.default.createElement(_Dot.Dot, _extends({}, props, {
            className: "recharts-radar-dot"
          })), dotItem;
        }
      }]), Radar2;
    }(_react.PureComponent);
    exports.Radar = Radar;
    Radar.displayName = "Radar";
    Radar.defaultProps = {
      angleAxisId: 0,
      radiusAxisId: 0,
      hide: !1,
      activeDot: !0,
      dot: !1,
      legendType: "rect",
      isAnimationActive: !_Global.Global.isSsr,
      animationBegin: 0,
      animationDuration: 1500,
      animationEasing: "ease"
    };
    Radar.getComposedData = function(_ref2) {
      var radiusAxis = _ref2.radiusAxis, angleAxis = _ref2.angleAxis, displayedData = _ref2.displayedData, dataKey = _ref2.dataKey, bandSize = _ref2.bandSize, cx = angleAxis.cx, cy = angleAxis.cy, isRange = !1, points = [];
      displayedData.forEach(function(entry2, i) {
        var name = (0, _ChartUtils.getValueByDataKey)(entry2, angleAxis.dataKey, i), value = (0, _ChartUtils.getValueByDataKey)(entry2, dataKey), angle = angleAxis.scale(name) + (bandSize || 0), pointValue = (0, _isArray2.default)(value) ? (0, _last2.default)(value) : value, radius = (0, _isNil2.default)(pointValue) ? void 0 : radiusAxis.scale(pointValue);
        (0, _isArray2.default)(value) && value.length >= 2 && (isRange = !0), points.push(_objectSpread3(_objectSpread3({}, (0, _PolarUtils.polarToCartesian)(cx, cy, radius, angle)), {}, {
          name,
          value,
          cx,
          cy,
          radius,
          angle,
          payload: entry2
        }));
      });
      var baseLinePoints = [];
      return isRange && points.forEach(function(point) {
        if ((0, _isArray2.default)(point.value)) {
          var baseValue = (0, _first2.default)(point.value), radius = (0, _isNil2.default)(baseValue) ? void 0 : radiusAxis.scale(baseValue);
          baseLinePoints.push(_objectSpread3(_objectSpread3({}, point), {}, {
            radius
          }, (0, _PolarUtils.polarToCartesian)(cx, cy, radius, point.angle)));
        } else
          baseLinePoints.push(point);
      }), {
        points,
        isRange,
        baseLinePoints
      };
    };
  }
});

// node_modules/recharts/lib/polar/RadialBar.js
var require_RadialBar = __commonJS({
  "node_modules/recharts/lib/polar/RadialBar.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.RadialBar = void 0;
    var _isEqual2 = _interopRequireDefault(require("lodash/isEqual")), _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _isArray2 = _interopRequireDefault(require("lodash/isArray")), _react = _interopRequireWildcard(require("react")), _classnames = _interopRequireDefault(require("classnames")), _reactSmooth = _interopRequireDefault(require("react-smooth")), _Sector = require_Sector(), _Layer = require_Layer(), _ReactUtils = require_ReactUtils(), _Global = require_Global(), _LabelList = require_LabelList(), _Cell = require_Cell(), _DataUtils = require_DataUtils(), _ChartUtils = require_ChartUtils(), _types = require_types(), _PolarUtils = require_PolarUtils();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose2(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source, key) || (target[key] = source[key]));
      }
      return target;
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var RadialBar2 = /* @__PURE__ */ function(_PureComponent) {
      _inherits(RadialBar3, _PureComponent);
      var _super = _createSuper(RadialBar3);
      function RadialBar3() {
        var _this;
        _classCallCheck(this, RadialBar3);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        return _this = _super.call.apply(_super, [this].concat(args)), _this.state = {
          isAnimationFinished: !1
        }, _this.handleAnimationEnd = function() {
          var onAnimationEnd = _this.props.onAnimationEnd;
          _this.setState({
            isAnimationFinished: !0
          }), (0, _isFunction2.default)(onAnimationEnd) && onAnimationEnd();
        }, _this.handleAnimationStart = function() {
          var onAnimationStart = _this.props.onAnimationStart;
          _this.setState({
            isAnimationFinished: !1
          }), (0, _isFunction2.default)(onAnimationStart) && onAnimationStart();
        }, _this;
      }
      return _createClass(RadialBar3, [{
        key: "getDeltaAngle",
        value: function() {
          var _this$props = this.props, startAngle = _this$props.startAngle, endAngle = _this$props.endAngle, sign = (0, _DataUtils.mathSign)(endAngle - startAngle), deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);
          return sign * deltaAngle;
        }
      }, {
        key: "renderSectorsStatically",
        value: function(sectors) {
          var _this2 = this, _this$props2 = this.props, shape = _this$props2.shape, activeShape = _this$props2.activeShape, activeIndex = _this$props2.activeIndex, cornerRadius = _this$props2.cornerRadius, others = _objectWithoutProperties2(_this$props2, ["shape", "activeShape", "activeIndex", "cornerRadius"]), baseProps = (0, _types.filterProps)(others);
          return sectors.map(function(entry2, i) {
            var props = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, baseProps), {}, {
              cornerRadius
            }, entry2), (0, _types.adaptEventsOfChild)(_this2.props, entry2, i)), {}, {
              key: "sector-".concat(i),
              className: "recharts-radial-bar-sector",
              forceCornerRadius: others.forceCornerRadius,
              cornerIsExternal: others.cornerIsExternal
            });
            return RadialBar3.renderSectorShape(i === activeIndex ? activeShape : shape, props);
          });
        }
      }, {
        key: "renderSectorsWithAnimation",
        value: function() {
          var _this3 = this, _this$props3 = this.props, data = _this$props3.data, isAnimationActive = _this$props3.isAnimationActive, animationBegin = _this$props3.animationBegin, animationDuration = _this$props3.animationDuration, animationEasing = _this$props3.animationEasing, animationId = _this$props3.animationId, prevData = this.state.prevData;
          return /* @__PURE__ */ _react.default.createElement(_reactSmooth.default, {
            begin: animationBegin,
            duration: animationDuration,
            isActive: isAnimationActive,
            easing: animationEasing,
            from: {
              t: 0
            },
            to: {
              t: 1
            },
            key: "radialBar-".concat(animationId),
            onAnimationStart: this.handleAnimationStart,
            onAnimationEnd: this.handleAnimationEnd
          }, function(_ref) {
            var t = _ref.t, stepData = data.map(function(entry2, index) {
              var prev = prevData && prevData[index];
              if (prev) {
                var interpolatorStartAngle = (0, _DataUtils.interpolateNumber)(prev.startAngle, entry2.startAngle), interpolatorEndAngle = (0, _DataUtils.interpolateNumber)(prev.endAngle, entry2.endAngle);
                return _objectSpread3(_objectSpread3({}, entry2), {}, {
                  startAngle: interpolatorStartAngle(t),
                  endAngle: interpolatorEndAngle(t)
                });
              }
              var endAngle = entry2.endAngle, startAngle = entry2.startAngle, interpolator = (0, _DataUtils.interpolateNumber)(startAngle, endAngle);
              return _objectSpread3(_objectSpread3({}, entry2), {}, {
                endAngle: interpolator(t)
              });
            });
            return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, null, _this3.renderSectorsStatically(stepData));
          });
        }
      }, {
        key: "renderSectors",
        value: function() {
          var _this$props4 = this.props, data = _this$props4.data, isAnimationActive = _this$props4.isAnimationActive, prevData = this.state.prevData;
          return isAnimationActive && data && data.length && (!prevData || !(0, _isEqual2.default)(prevData, data)) ? this.renderSectorsWithAnimation() : this.renderSectorsStatically(data);
        }
      }, {
        key: "renderBackground",
        value: function(sectors) {
          var _this4 = this, cornerRadius = this.props.cornerRadius, backgroundProps = (0, _types.filterProps)(this.props.background);
          return sectors.map(function(entry2, i) {
            var value = entry2.value, background = entry2.background, rest = _objectWithoutProperties2(entry2, ["value", "background"]);
            if (!background)
              return null;
            var props = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({
              cornerRadius
            }, rest), {}, {
              fill: "#eee"
            }, background), backgroundProps), (0, _types.adaptEventsOfChild)(_this4.props, entry2, i)), {}, {
              index: i,
              key: "sector-".concat(i),
              className: "recharts-radial-bar-background-sector"
            });
            return RadialBar3.renderSectorShape(background, props);
          });
        }
      }, {
        key: "render",
        value: function() {
          var _this$props5 = this.props, hide = _this$props5.hide, data = _this$props5.data, className = _this$props5.className, background = _this$props5.background, isAnimationActive = _this$props5.isAnimationActive;
          if (hide || !data || !data.length)
            return null;
          var isAnimationFinished = this.state.isAnimationFinished, layerClass = (0, _classnames.default)("recharts-area", className);
          return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: layerClass
          }, background && /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: "recharts-radial-bar-background"
          }, this.renderBackground(data)), /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: "recharts-radial-bar-sectors"
          }, this.renderSectors()), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(_objectSpread3(_objectSpread3({}, this.props), {}, {
            clockWise: this.getDeltaAngle() < 0
          }), data));
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function(nextProps, prevState) {
          return nextProps.animationId !== prevState.prevAnimationId ? {
            prevAnimationId: nextProps.animationId,
            curData: nextProps.data,
            prevData: prevState.curData
          } : nextProps.data !== prevState.curData ? {
            curData: nextProps.data
          } : null;
        }
      }, {
        key: "renderSectorShape",
        value: function(shape, props) {
          var sectorShape;
          return /* @__PURE__ */ _react.default.isValidElement(shape) ? sectorShape = /* @__PURE__ */ _react.default.cloneElement(shape, props) : (0, _isFunction2.default)(shape) ? sectorShape = shape(props) : sectorShape = /* @__PURE__ */ _react.default.createElement(_Sector.Sector, props), sectorShape;
        }
      }]), RadialBar3;
    }(_react.PureComponent);
    exports.RadialBar = RadialBar2;
    RadialBar2.displayName = "RadialBar";
    RadialBar2.defaultProps = {
      angleAxisId: 0,
      radiusAxisId: 0,
      minPointSize: 0,
      hide: !1,
      legendType: "rect",
      data: [],
      isAnimationActive: !_Global.Global.isSsr,
      animationBegin: 0,
      animationDuration: 1500,
      animationEasing: "ease",
      forceCornerRadius: !1,
      cornerIsExternal: !1
    };
    RadialBar2.getComposedData = function(_ref2) {
      var item = _ref2.item, props = _ref2.props, radiusAxis = _ref2.radiusAxis, radiusAxisTicks = _ref2.radiusAxisTicks, angleAxis = _ref2.angleAxis, angleAxisTicks = _ref2.angleAxisTicks, displayedData = _ref2.displayedData, dataKey = _ref2.dataKey, stackedData = _ref2.stackedData, barPosition = _ref2.barPosition, bandSize = _ref2.bandSize, dataStartIndex = _ref2.dataStartIndex, pos = (0, _ChartUtils.findPositionOfBar)(barPosition, item);
      if (!pos)
        return null;
      var cx = angleAxis.cx, cy = angleAxis.cy, layout = props.layout, _item$props = item.props, children = _item$props.children, minPointSize = _item$props.minPointSize, numericAxis = layout === "radial" ? angleAxis : radiusAxis, stackedDomain = stackedData ? numericAxis.scale.domain() : null, baseValue = (0, _ChartUtils.getBaseValueOfBar)({
        numericAxis
      }), cells = (0, _ReactUtils.findAllByType)(children, _Cell.Cell.displayName), sectors = displayedData.map(function(entry2, index) {
        var value, innerRadius, outerRadius, startAngle, endAngle, backgroundSector;
        if (stackedData ? value = (0, _ChartUtils.truncateByDomain)(stackedData[dataStartIndex + index], stackedDomain) : (value = (0, _ChartUtils.getValueByDataKey)(entry2, dataKey), (0, _isArray2.default)(value) || (value = [baseValue, value])), layout === "radial") {
          innerRadius = (0, _ChartUtils.getCateCoordinateOfBar)({
            axis: radiusAxis,
            ticks: radiusAxisTicks,
            bandSize,
            offset: pos.offset,
            entry: entry2,
            index
          }), endAngle = angleAxis.scale(value[1]), startAngle = angleAxis.scale(value[0]), outerRadius = innerRadius + pos.size;
          var deltaAngle = endAngle - startAngle;
          if (Math.abs(minPointSize) > 0 && Math.abs(deltaAngle) < Math.abs(minPointSize)) {
            var delta = (0, _DataUtils.mathSign)(deltaAngle || minPointSize) * (Math.abs(minPointSize) - Math.abs(deltaAngle));
            endAngle += delta;
          }
          backgroundSector = {
            background: {
              cx,
              cy,
              innerRadius,
              outerRadius,
              startAngle: props.startAngle,
              endAngle: props.endAngle
            }
          };
        } else {
          innerRadius = radiusAxis.scale(value[0]), outerRadius = radiusAxis.scale(value[1]), startAngle = (0, _ChartUtils.getCateCoordinateOfBar)({
            axis: angleAxis,
            ticks: angleAxisTicks,
            bandSize,
            offset: pos.offset,
            entry: entry2,
            index
          }), endAngle = startAngle + pos.size;
          var deltaRadius = outerRadius - innerRadius;
          if (Math.abs(minPointSize) > 0 && Math.abs(deltaRadius) < Math.abs(minPointSize)) {
            var _delta = (0, _DataUtils.mathSign)(deltaRadius || minPointSize) * (Math.abs(minPointSize) - Math.abs(deltaRadius));
            outerRadius += _delta;
          }
        }
        return _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, entry2), backgroundSector), {}, {
          payload: entry2,
          value: stackedData ? value : value[1],
          cx,
          cy,
          innerRadius,
          outerRadius,
          startAngle,
          endAngle
        }, cells && cells[index] && cells[index].props), {}, {
          tooltipPayload: [(0, _ChartUtils.getTooltipItem)(item, entry2)],
          tooltipPosition: (0, _PolarUtils.polarToCartesian)(cx, cy, (innerRadius + outerRadius) / 2, (startAngle + endAngle) / 2)
        });
      });
      return {
        data: sectors,
        layout
      };
    };
  }
});

// node_modules/recharts/lib/util/CssPrefixUtils.js
var require_CssPrefixUtils = __commonJS({
  "node_modules/recharts/lib/util/CssPrefixUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.generatePrefixStyle = void 0;
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    var PREFIX_LIST = ["Webkit", "Moz", "O", "ms"], generatePrefixStyle = function(name, value) {
      if (!name)
        return null;
      var camelName = name.replace(/(\w)/, function(v) {
        return v.toUpperCase();
      }), result = PREFIX_LIST.reduce(function(res, entry2) {
        return _objectSpread3(_objectSpread3({}, res), {}, _defineProperty3({}, entry2 + camelName, value));
      }, {});
      return result[name] = value, result;
    };
    exports.generatePrefixStyle = generatePrefixStyle;
  }
});

// node_modules/recharts/lib/cartesian/Brush.js
var require_Brush = __commonJS({
  "node_modules/recharts/lib/cartesian/Brush.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Brush = void 0;
    var _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _range2 = _interopRequireDefault(require("lodash/range")), _react = _interopRequireWildcard(require("react")), _classnames = _interopRequireDefault(require("classnames")), _d3Scale = require("d3-scale"), _Layer = require_Layer(), _Text = require_Text(), _ChartUtils = require_ChartUtils(), _DataUtils = require_DataUtils(), _CssPrefixUtils = require_CssPrefixUtils(), _types = require_types();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var createScale = function(_ref) {
      var data = _ref.data, startIndex = _ref.startIndex, endIndex = _ref.endIndex, x = _ref.x, width = _ref.width, travellerWidth = _ref.travellerWidth;
      if (!data || !data.length)
        return {};
      var len = data.length, scale = (0, _d3Scale.scalePoint)().domain((0, _range2.default)(0, len)).range([x, x + width - travellerWidth]), scaleValues = scale.domain().map(function(entry2) {
        return scale(entry2);
      });
      return {
        isTextActive: !1,
        isSlideMoving: !1,
        isTravellerMoving: !1,
        startX: scale(startIndex),
        endX: scale(endIndex),
        scale,
        scaleValues
      };
    }, isTouch = function(e) {
      return e.changedTouches && !!e.changedTouches.length;
    }, Brush = /* @__PURE__ */ function(_PureComponent) {
      _inherits(Brush2, _PureComponent);
      var _super = _createSuper(Brush2);
      function Brush2(props) {
        var _this;
        return _classCallCheck(this, Brush2), _this = _super.call(this, props), _this.leaveTimer = void 0, _this.travellerDragStartHandlers = void 0, _this.handleDrag = function(e) {
          _this.leaveTimer && (clearTimeout(_this.leaveTimer), _this.leaveTimer = null), _this.state.isTravellerMoving ? _this.handleTravellerMove(e) : _this.state.isSlideMoving && _this.handleSlideDrag(e);
        }, _this.handleTouchMove = function(e) {
          e.changedTouches != null && e.changedTouches.length > 0 && _this.handleDrag(e.changedTouches[0]);
        }, _this.handleDragEnd = function() {
          _this.setState({
            isTravellerMoving: !1,
            isSlideMoving: !1
          }), _this.detachDragEndListener();
        }, _this.handleLeaveWrapper = function() {
          (_this.state.isTravellerMoving || _this.state.isSlideMoving) && (_this.leaveTimer = window.setTimeout(_this.handleDragEnd, _this.props.leaveTimeOut));
        }, _this.handleEnterSlideOrTraveller = function() {
          _this.setState({
            isTextActive: !0
          });
        }, _this.handleLeaveSlideOrTraveller = function() {
          _this.setState({
            isTextActive: !1
          });
        }, _this.handleSlideDragStart = function(e) {
          var event = isTouch(e) ? e.changedTouches[0] : e;
          _this.setState({
            isTravellerMoving: !1,
            isSlideMoving: !0,
            slideMoveStartX: event.pageX
          }), _this.attachDragEndListener();
        }, _this.travellerDragStartHandlers = {
          startX: _this.handleTravellerDragStart.bind(_assertThisInitialized(_this), "startX"),
          endX: _this.handleTravellerDragStart.bind(_assertThisInitialized(_this), "endX")
        }, _this.state = {}, _this;
      }
      return _createClass(Brush2, [{
        key: "componentWillUnmount",
        value: function() {
          this.leaveTimer && (clearTimeout(this.leaveTimer), this.leaveTimer = null), this.detachDragEndListener();
        }
      }, {
        key: "getIndex",
        value: function(_ref2) {
          var startX = _ref2.startX, endX = _ref2.endX, scaleValues = this.state.scaleValues, _this$props = this.props, gap = _this$props.gap, data = _this$props.data, lastIndex = data.length - 1, min = Math.min(startX, endX), max = Math.max(startX, endX), minIndex = Brush2.getIndexInRange(scaleValues, min), maxIndex = Brush2.getIndexInRange(scaleValues, max);
          return {
            startIndex: minIndex - minIndex % gap,
            endIndex: maxIndex === lastIndex ? lastIndex : maxIndex - maxIndex % gap
          };
        }
      }, {
        key: "getTextOfTick",
        value: function(index) {
          var _this$props2 = this.props, data = _this$props2.data, tickFormatter = _this$props2.tickFormatter, dataKey = _this$props2.dataKey, text = (0, _ChartUtils.getValueByDataKey)(data[index], dataKey, index);
          return (0, _isFunction2.default)(tickFormatter) ? tickFormatter(text, index) : text;
        }
      }, {
        key: "attachDragEndListener",
        value: function() {
          window.addEventListener("mouseup", this.handleDragEnd, !0), window.addEventListener("touchend", this.handleDragEnd, !0), window.addEventListener("mousemove", this.handleDrag, !0);
        }
      }, {
        key: "detachDragEndListener",
        value: function() {
          window.removeEventListener("mouseup", this.handleDragEnd, !0), window.removeEventListener("touchend", this.handleDragEnd, !0), window.removeEventListener("mousemove", this.handleDrag, !0);
        }
      }, {
        key: "handleSlideDrag",
        value: function(e) {
          var _this$state = this.state, slideMoveStartX = _this$state.slideMoveStartX, startX = _this$state.startX, endX = _this$state.endX, _this$props3 = this.props, x = _this$props3.x, width = _this$props3.width, travellerWidth = _this$props3.travellerWidth, startIndex = _this$props3.startIndex, endIndex = _this$props3.endIndex, onChange = _this$props3.onChange, delta = e.pageX - slideMoveStartX;
          delta > 0 ? delta = Math.min(delta, x + width - travellerWidth - endX, x + width - travellerWidth - startX) : delta < 0 && (delta = Math.max(delta, x - startX, x - endX));
          var newIndex = this.getIndex({
            startX: startX + delta,
            endX: endX + delta
          });
          (newIndex.startIndex !== startIndex || newIndex.endIndex !== endIndex) && onChange && onChange(newIndex), this.setState({
            startX: startX + delta,
            endX: endX + delta,
            slideMoveStartX: e.pageX
          });
        }
      }, {
        key: "handleTravellerDragStart",
        value: function(id, e) {
          var event = isTouch(e) ? e.changedTouches[0] : e;
          this.setState({
            isSlideMoving: !1,
            isTravellerMoving: !0,
            movingTravellerId: id,
            brushMoveStartX: event.pageX
          }), this.attachDragEndListener();
        }
      }, {
        key: "handleTravellerMove",
        value: function(e) {
          var _this$setState, _this$state2 = this.state, brushMoveStartX = _this$state2.brushMoveStartX, movingTravellerId = _this$state2.movingTravellerId, endX = _this$state2.endX, startX = _this$state2.startX, prevValue = this.state[movingTravellerId], _this$props4 = this.props, x = _this$props4.x, width = _this$props4.width, travellerWidth = _this$props4.travellerWidth, onChange = _this$props4.onChange, gap = _this$props4.gap, data = _this$props4.data, params = {
            startX: this.state.startX,
            endX: this.state.endX
          }, delta = e.pageX - brushMoveStartX;
          delta > 0 ? delta = Math.min(delta, x + width - travellerWidth - prevValue) : delta < 0 && (delta = Math.max(delta, x - prevValue)), params[movingTravellerId] = prevValue + delta;
          var newIndex = this.getIndex(params), startIndex = newIndex.startIndex, endIndex = newIndex.endIndex, isFullGap = function() {
            var lastIndex = data.length - 1;
            return movingTravellerId === "startX" && (endX > startX ? startIndex % gap === 0 : endIndex % gap === 0) || endX < startX && endIndex === lastIndex || movingTravellerId === "endX" && (endX > startX ? endIndex % gap === 0 : startIndex % gap === 0) || endX > startX && endIndex === lastIndex;
          };
          this.setState((_this$setState = {}, _defineProperty3(_this$setState, movingTravellerId, prevValue + delta), _defineProperty3(_this$setState, "brushMoveStartX", e.pageX), _this$setState), function() {
            onChange && isFullGap() && onChange(newIndex);
          });
        }
      }, {
        key: "renderBackground",
        value: function() {
          var _this$props5 = this.props, x = _this$props5.x, y = _this$props5.y, width = _this$props5.width, height = _this$props5.height, fill = _this$props5.fill, stroke = _this$props5.stroke;
          return /* @__PURE__ */ _react.default.createElement("rect", {
            stroke,
            fill,
            x,
            y,
            width,
            height
          });
        }
      }, {
        key: "renderPanorama",
        value: function() {
          var _this$props6 = this.props, x = _this$props6.x, y = _this$props6.y, width = _this$props6.width, height = _this$props6.height, data = _this$props6.data, children = _this$props6.children, padding = _this$props6.padding, chartElement = _react.Children.only(children);
          return chartElement ? /* @__PURE__ */ _react.default.cloneElement(chartElement, {
            x,
            y,
            width,
            height,
            margin: padding,
            compact: !0,
            data
          }) : null;
        }
      }, {
        key: "renderTravellerLayer",
        value: function(travellerX, id) {
          var _this$props7 = this.props, y = _this$props7.y, travellerWidth = _this$props7.travellerWidth, height = _this$props7.height, traveller = _this$props7.traveller, x = Math.max(travellerX, this.props.x), travellerProps = _objectSpread3(_objectSpread3({}, (0, _types.filterProps)(this.props)), {}, {
            x,
            y,
            width: travellerWidth,
            height
          });
          return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: "recharts-brush-traveller",
            onMouseEnter: this.handleEnterSlideOrTraveller,
            onMouseLeave: this.handleLeaveSlideOrTraveller,
            onMouseDown: this.travellerDragStartHandlers[id],
            onTouchStart: this.travellerDragStartHandlers[id],
            style: {
              cursor: "col-resize"
            }
          }, Brush2.renderTraveller(traveller, travellerProps));
        }
      }, {
        key: "renderSlide",
        value: function(startX, endX) {
          var _this$props8 = this.props, y = _this$props8.y, height = _this$props8.height, stroke = _this$props8.stroke, travellerWidth = _this$props8.travellerWidth, x = Math.min(startX, endX) + travellerWidth, width = Math.max(Math.abs(endX - startX) - travellerWidth, 0);
          return /* @__PURE__ */ _react.default.createElement("rect", {
            className: "recharts-brush-slide",
            onMouseEnter: this.handleEnterSlideOrTraveller,
            onMouseLeave: this.handleLeaveSlideOrTraveller,
            onMouseDown: this.handleSlideDragStart,
            onTouchStart: this.handleSlideDragStart,
            style: {
              cursor: "move"
            },
            stroke: "none",
            fill: stroke,
            fillOpacity: 0.2,
            x,
            y,
            width,
            height
          });
        }
      }, {
        key: "renderText",
        value: function() {
          var _this$props9 = this.props, startIndex = _this$props9.startIndex, endIndex = _this$props9.endIndex, y = _this$props9.y, height = _this$props9.height, travellerWidth = _this$props9.travellerWidth, stroke = _this$props9.stroke, _this$state3 = this.state, startX = _this$state3.startX, endX = _this$state3.endX, offset = 5, attrs = {
            pointerEvents: "none",
            fill: stroke
          };
          return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: "recharts-brush-texts"
          }, /* @__PURE__ */ _react.default.createElement(_Text.Text, _extends({
            textAnchor: "end",
            verticalAnchor: "middle",
            x: Math.min(startX, endX) - offset,
            y: y + height / 2
          }, attrs), this.getTextOfTick(startIndex)), /* @__PURE__ */ _react.default.createElement(_Text.Text, _extends({
            textAnchor: "start",
            verticalAnchor: "middle",
            x: Math.max(startX, endX) + travellerWidth + offset,
            y: y + height / 2
          }, attrs), this.getTextOfTick(endIndex)));
        }
      }, {
        key: "render",
        value: function() {
          var _this$props10 = this.props, data = _this$props10.data, className = _this$props10.className, children = _this$props10.children, x = _this$props10.x, y = _this$props10.y, width = _this$props10.width, height = _this$props10.height, alwaysShowText = _this$props10.alwaysShowText, _this$state4 = this.state, startX = _this$state4.startX, endX = _this$state4.endX, isTextActive = _this$state4.isTextActive, isSlideMoving = _this$state4.isSlideMoving, isTravellerMoving = _this$state4.isTravellerMoving;
          if (!data || !data.length || !(0, _DataUtils.isNumber)(x) || !(0, _DataUtils.isNumber)(y) || !(0, _DataUtils.isNumber)(width) || !(0, _DataUtils.isNumber)(height) || width <= 0 || height <= 0)
            return null;
          var layerClass = (0, _classnames.default)("recharts-brush", className), isPanoramic = _react.default.Children.count(children) === 1, style = (0, _CssPrefixUtils.generatePrefixStyle)("userSelect", "none");
          return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: layerClass,
            onMouseLeave: this.handleLeaveWrapper,
            onTouchMove: this.handleTouchMove,
            style
          }, this.renderBackground(), isPanoramic && this.renderPanorama(), this.renderSlide(startX, endX), this.renderTravellerLayer(startX, "startX"), this.renderTravellerLayer(endX, "endX"), (isTextActive || isSlideMoving || isTravellerMoving || alwaysShowText) && this.renderText());
        }
      }], [{
        key: "renderDefaultTraveller",
        value: function(props) {
          var x = props.x, y = props.y, width = props.width, height = props.height, stroke = props.stroke, lineY = Math.floor(y + height / 2) - 1;
          return /* @__PURE__ */ _react.default.createElement(_react.default.Fragment, null, /* @__PURE__ */ _react.default.createElement("rect", {
            x,
            y,
            width,
            height,
            fill: stroke,
            stroke: "none"
          }), /* @__PURE__ */ _react.default.createElement("line", {
            x1: x + 1,
            y1: lineY,
            x2: x + width - 1,
            y2: lineY,
            fill: "none",
            stroke: "#fff"
          }), /* @__PURE__ */ _react.default.createElement("line", {
            x1: x + 1,
            y1: lineY + 2,
            x2: x + width - 1,
            y2: lineY + 2,
            fill: "none",
            stroke: "#fff"
          }));
        }
      }, {
        key: "renderTraveller",
        value: function(option, props) {
          var rectangle;
          return /* @__PURE__ */ _react.default.isValidElement(option) ? rectangle = /* @__PURE__ */ _react.default.cloneElement(option, props) : (0, _isFunction2.default)(option) ? rectangle = option(props) : rectangle = Brush2.renderDefaultTraveller(props), rectangle;
        }
      }, {
        key: "getDerivedStateFromProps",
        value: function(nextProps, prevState) {
          var data = nextProps.data, width = nextProps.width, x = nextProps.x, travellerWidth = nextProps.travellerWidth, updateId = nextProps.updateId, startIndex = nextProps.startIndex, endIndex = nextProps.endIndex;
          if (data !== prevState.prevData || updateId !== prevState.prevUpdateId)
            return _objectSpread3({
              prevData: data,
              prevTravellerWidth: travellerWidth,
              prevUpdateId: updateId,
              prevX: x,
              prevWidth: width
            }, data && data.length ? createScale({
              data,
              width,
              x,
              travellerWidth,
              startIndex,
              endIndex
            }) : {
              scale: null,
              scaleValues: null
            });
          if (prevState.scale && (width !== prevState.prevWidth || x !== prevState.prevX || travellerWidth !== prevState.prevTravellerWidth)) {
            prevState.scale.range([x, x + width - travellerWidth]);
            var scaleValues = prevState.scale.domain().map(function(entry2) {
              return prevState.scale(entry2);
            });
            return {
              prevData: data,
              prevTravellerWidth: travellerWidth,
              prevUpdateId: updateId,
              prevX: x,
              prevWidth: width,
              startX: prevState.scale(nextProps.startIndex),
              endX: prevState.scale(nextProps.endIndex),
              scaleValues
            };
          }
          return null;
        }
      }, {
        key: "getIndexInRange",
        value: function(range, x) {
          for (var len = range.length, start = 0, end = len - 1; end - start > 1; ) {
            var middle = Math.floor((start + end) / 2);
            range[middle] > x ? end = middle : start = middle;
          }
          return x >= range[end] ? end : start;
        }
      }]), Brush2;
    }(_react.PureComponent);
    exports.Brush = Brush;
    Brush.displayName = "Brush";
    Brush.defaultProps = {
      height: 40,
      travellerWidth: 5,
      gap: 1,
      fill: "#fff",
      stroke: "#666",
      padding: {
        top: 1,
        right: 1,
        bottom: 1,
        left: 1
      },
      leaveTimeOut: 1e3,
      alwaysShowText: !1
    };
  }
});

// node_modules/recharts/lib/util/IfOverflowMatches.js
var require_IfOverflowMatches = __commonJS({
  "node_modules/recharts/lib/util/IfOverflowMatches.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.ifOverflowMatches = void 0;
    var ifOverflowMatches = function(props, value) {
      var alwaysShow = props.alwaysShow, ifOverflow = props.ifOverflow;
      return alwaysShow && (ifOverflow = "extendDomain"), ifOverflow === value;
    };
    exports.ifOverflowMatches = ifOverflowMatches;
  }
});

// node_modules/recharts/lib/util/CartesianUtils.js
var require_CartesianUtils = __commonJS({
  "node_modules/recharts/lib/util/CartesianUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.createLabeledScales = exports.ScaleHelper = exports.rectWithCoords = exports.rectWithPoints = exports.formatAxisMap = void 0;
    var _every2 = _interopRequireDefault(require("lodash/every")), _mapValues2 = _interopRequireDefault(require("lodash/mapValues")), _ChartUtils = require_ChartUtils(), _ReactUtils = require_ReactUtils(), _DataUtils = require_DataUtils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    var formatAxisMap = function(props, axisMap, offset, axisType, chartName) {
      var width = props.width, height = props.height, layout = props.layout, children = props.children, ids = Object.keys(axisMap), steps = {
        left: offset.left,
        leftMirror: offset.left,
        right: width - offset.right,
        rightMirror: width - offset.right,
        top: offset.top,
        topMirror: offset.top,
        bottom: height - offset.bottom,
        bottomMirror: height - offset.bottom
      }, hasBar = !!(0, _ReactUtils.findChildByType)(children, "Bar");
      return ids.reduce(function(result, id) {
        var axis = axisMap[id], orientation = axis.orientation, domain = axis.domain, _axis$padding = axis.padding, padding = _axis$padding === void 0 ? {} : _axis$padding, mirror = axis.mirror, reversed = axis.reversed, offsetKey = "".concat(orientation).concat(mirror ? "Mirror" : ""), calculatedPadding, range, x, y, needSpace;
        if (axis.type === "number" && (axis.padding === "gap" || axis.padding === "no-gap")) {
          var diff = domain[1] - domain[0], smallestDistanceBetweenValues = 1 / 0, sortedValues = axis.categoricalDomain.sort();
          sortedValues.forEach(function(value, index) {
            index > 0 && (smallestDistanceBetweenValues = Math.min((value || 0) - (sortedValues[index - 1] || 0), smallestDistanceBetweenValues));
          });
          var smallestDistanceInPercent = smallestDistanceBetweenValues / diff, rangeWidth = axis.layout === "vertical" ? offset.height : offset.width;
          if (axis.padding === "gap" && (calculatedPadding = smallestDistanceInPercent * rangeWidth / 2), axis.padding === "no-gap") {
            var gap = (0, _DataUtils.getPercentValue)(props.barCategoryGap, smallestDistanceInPercent * rangeWidth), halfBand = smallestDistanceInPercent * rangeWidth / 2;
            calculatedPadding = halfBand - gap - (halfBand - gap) / rangeWidth * gap;
          }
        }
        axisType === "xAxis" ? range = [offset.left + (padding.left || 0) + (calculatedPadding || 0), offset.left + offset.width - (padding.right || 0) - (calculatedPadding || 0)] : axisType === "yAxis" ? range = layout === "horizontal" ? [offset.top + offset.height - (padding.bottom || 0), offset.top + (padding.top || 0)] : [offset.top + (padding.top || 0) + (calculatedPadding || 0), offset.top + offset.height - (padding.bottom || 0) - (calculatedPadding || 0)] : range = axis.range, reversed && (range = [range[1], range[0]]);
        var _parseScale = (0, _ChartUtils.parseScale)(axis, chartName, hasBar), scale = _parseScale.scale, realScaleType = _parseScale.realScaleType;
        scale.domain(domain).range(range), (0, _ChartUtils.checkDomainOfScale)(scale);
        var ticks = (0, _ChartUtils.getTicksOfScale)(scale, _objectSpread3(_objectSpread3({}, axis), {}, {
          realScaleType
        }));
        axisType === "xAxis" ? (needSpace = orientation === "top" && !mirror || orientation === "bottom" && mirror, x = offset.left, y = steps[offsetKey] - needSpace * axis.height) : axisType === "yAxis" && (needSpace = orientation === "left" && !mirror || orientation === "right" && mirror, x = steps[offsetKey] - needSpace * axis.width, y = offset.top);
        var finalAxis = _objectSpread3(_objectSpread3(_objectSpread3({}, axis), ticks), {}, {
          realScaleType,
          x,
          y,
          scale,
          width: axisType === "xAxis" ? offset.width : axis.width,
          height: axisType === "yAxis" ? offset.height : axis.height
        });
        return finalAxis.bandSize = (0, _ChartUtils.getBandSizeOfAxis)(finalAxis, ticks), !axis.hide && axisType === "xAxis" ? steps[offsetKey] += (needSpace ? -1 : 1) * finalAxis.height : axis.hide || (steps[offsetKey] += (needSpace ? -1 : 1) * finalAxis.width), _objectSpread3(_objectSpread3({}, result), {}, _defineProperty3({}, id, finalAxis));
      }, {});
    };
    exports.formatAxisMap = formatAxisMap;
    var rectWithPoints = function(_ref, _ref2) {
      var x1 = _ref.x, y1 = _ref.y, x2 = _ref2.x, y2 = _ref2.y;
      return {
        x: Math.min(x1, x2),
        y: Math.min(y1, y2),
        width: Math.abs(x2 - x1),
        height: Math.abs(y2 - y1)
      };
    };
    exports.rectWithPoints = rectWithPoints;
    var rectWithCoords = function(_ref3) {
      var x1 = _ref3.x1, y1 = _ref3.y1, x2 = _ref3.x2, y2 = _ref3.y2;
      return rectWithPoints({
        x: x1,
        y: y1
      }, {
        x: x2,
        y: y2
      });
    };
    exports.rectWithCoords = rectWithCoords;
    var ScaleHelper = /* @__PURE__ */ function() {
      function ScaleHelper2(scale) {
        _classCallCheck(this, ScaleHelper2), this.scale = void 0, this.scale = scale;
      }
      return _createClass(ScaleHelper2, [{
        key: "domain",
        get: function() {
          return this.scale.domain;
        }
      }, {
        key: "range",
        get: function() {
          return this.scale.range;
        }
      }, {
        key: "rangeMin",
        get: function() {
          return this.range()[0];
        }
      }, {
        key: "rangeMax",
        get: function() {
          return this.range()[1];
        }
      }, {
        key: "bandwidth",
        get: function() {
          return this.scale.bandwidth;
        }
      }, {
        key: "apply",
        value: function(value) {
          var _ref4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, bandAware = _ref4.bandAware, position = _ref4.position;
          if (value !== void 0) {
            if (position)
              switch (position) {
                case "start":
                  return this.scale(value);
                case "middle": {
                  var offset = this.bandwidth ? this.bandwidth() / 2 : 0;
                  return this.scale(value) + offset;
                }
                case "end": {
                  var _offset = this.bandwidth ? this.bandwidth() : 0;
                  return this.scale(value) + _offset;
                }
                default:
                  return this.scale(value);
              }
            if (bandAware) {
              var _offset2 = this.bandwidth ? this.bandwidth() / 2 : 0;
              return this.scale(value) + _offset2;
            }
            return this.scale(value);
          }
        }
      }, {
        key: "isInRange",
        value: function(value) {
          var range = this.range(), first = range[0], last = range[range.length - 1];
          return first <= last ? value >= first && value <= last : value >= last && value <= first;
        }
      }], [{
        key: "create",
        value: function(obj) {
          return new ScaleHelper2(obj);
        }
      }]), ScaleHelper2;
    }();
    exports.ScaleHelper = ScaleHelper;
    ScaleHelper.EPS = 1e-4;
    var createLabeledScales = function(options) {
      var scales = Object.keys(options).reduce(function(res, key) {
        return _objectSpread3(_objectSpread3({}, res), {}, _defineProperty3({}, key, ScaleHelper.create(options[key])));
      }, {});
      return _objectSpread3(_objectSpread3({}, scales), {}, {
        apply: function(coord) {
          var _ref5 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, bandAware = _ref5.bandAware, position = _ref5.position;
          return (0, _mapValues2.default)(coord, function(value, label) {
            return scales[label].apply(value, {
              bandAware,
              position
            });
          });
        },
        isInRange: function(coord) {
          return (0, _every2.default)(coord, function(value, label) {
            return scales[label].isInRange(value);
          });
        }
      });
    };
    exports.createLabeledScales = createLabeledScales;
  }
});

// node_modules/recharts/lib/cartesian/ReferenceLine.js
var require_ReferenceLine = __commonJS({
  "node_modules/recharts/lib/cartesian/ReferenceLine.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.ReferenceLine = ReferenceLine;
    var _some2 = _interopRequireDefault(require("lodash/some")), _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _react = _interopRequireDefault(require("react")), _classnames = _interopRequireDefault(require("classnames")), _Layer = require_Layer(), _Label = require_Label(), _IfOverflowMatches = require_IfOverflowMatches(), _DataUtils = require_DataUtils(), _CartesianUtils = require_CartesianUtils(), _LogUtils = require_LogUtils(), _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!!o) {
        if (typeof o == "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
    }
    function _arrayLikeToArray(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(arr)))) {
        var _arr = [], _n = !0, _d = !1, _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    var renderLine = function(option, props) {
      var line;
      return /* @__PURE__ */ _react.default.isValidElement(option) ? line = /* @__PURE__ */ _react.default.cloneElement(option, props) : (0, _isFunction2.default)(option) ? line = option(props) : line = /* @__PURE__ */ _react.default.createElement("line", _extends({}, props, {
        className: "recharts-reference-line-line"
      })), line;
    }, getEndPoints = function(scales, isFixedX, isFixedY, isSegment, props) {
      var _props$viewBox = props.viewBox, x = _props$viewBox.x, y = _props$viewBox.y, width = _props$viewBox.width, height = _props$viewBox.height, position = props.position;
      if (isFixedY) {
        var yCoord = props.y, orientation = props.yAxis.orientation, coord = scales.y.apply(yCoord, {
          position
        });
        if ((0, _IfOverflowMatches.ifOverflowMatches)(props, "discard") && !scales.y.isInRange(coord))
          return null;
        var points = [{
          x: x + width,
          y: coord
        }, {
          x,
          y: coord
        }];
        return orientation === "left" ? points.reverse() : points;
      }
      if (isFixedX) {
        var xCoord = props.x, _orientation = props.xAxis.orientation, _coord = scales.x.apply(xCoord, {
          position
        });
        if ((0, _IfOverflowMatches.ifOverflowMatches)(props, "discard") && !scales.x.isInRange(_coord))
          return null;
        var _points = [{
          x: _coord,
          y: y + height
        }, {
          x: _coord,
          y
        }];
        return _orientation === "top" ? _points.reverse() : _points;
      }
      if (isSegment) {
        var segment = props.segment, _points2 = segment.map(function(p) {
          return scales.apply(p, {
            position
          });
        });
        return (0, _IfOverflowMatches.ifOverflowMatches)(props, "discard") && (0, _some2.default)(_points2, function(p) {
          return !scales.isInRange(p);
        }) ? null : _points2;
      }
      return null;
    };
    function ReferenceLine(props) {
      var fixedX = props.x, fixedY = props.y, segment = props.segment, xAxis = props.xAxis, yAxis = props.yAxis, shape = props.shape, className = props.className, alwaysShow = props.alwaysShow, clipPathId = props.clipPathId;
      (0, _LogUtils.warn)(alwaysShow === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.');
      var scales = (0, _CartesianUtils.createLabeledScales)({
        x: xAxis.scale,
        y: yAxis.scale
      }), isX = (0, _DataUtils.isNumOrStr)(fixedX), isY = (0, _DataUtils.isNumOrStr)(fixedY), isSegment = segment && segment.length === 2, endPoints = getEndPoints(scales, isX, isY, isSegment, props);
      if (!endPoints)
        return null;
      var _endPoints = _slicedToArray(endPoints, 2), _endPoints$ = _endPoints[0], x1 = _endPoints$.x, y1 = _endPoints$.y, _endPoints$2 = _endPoints[1], x2 = _endPoints$2.x, y2 = _endPoints$2.y, clipPath = (0, _IfOverflowMatches.ifOverflowMatches)(props, "hidden") ? "url(#".concat(clipPathId, ")") : void 0, lineProps = _objectSpread3(_objectSpread3({
        clipPath
      }, (0, _types.filterProps)(props, !0)), {}, {
        x1,
        y1,
        x2,
        y2
      });
      return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
        className: (0, _classnames.default)("recharts-reference-line", className)
      }, renderLine(shape, lineProps), _Label.Label.renderCallByParent(props, (0, _CartesianUtils.rectWithCoords)({
        x1,
        y1,
        x2,
        y2
      })));
    }
    ReferenceLine.displayName = "ReferenceLine";
    ReferenceLine.defaultProps = {
      isFront: !1,
      ifOverflow: "discard",
      xAxisId: 0,
      yAxisId: 0,
      fill: "none",
      stroke: "#ccc",
      fillOpacity: 1,
      strokeWidth: 1,
      position: "middle"
    };
  }
});

// node_modules/recharts/lib/cartesian/ReferenceDot.js
var require_ReferenceDot = __commonJS({
  "node_modules/recharts/lib/cartesian/ReferenceDot.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.ReferenceDot = ReferenceDot;
    var _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _react = _interopRequireDefault(require("react")), _classnames = _interopRequireDefault(require("classnames")), _Layer = require_Layer(), _Dot = require_Dot(), _Label = require_Label(), _DataUtils = require_DataUtils(), _IfOverflowMatches = require_IfOverflowMatches(), _CartesianUtils = require_CartesianUtils(), _LogUtils = require_LogUtils(), _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    var getCoordinate = function(props) {
      var x = props.x, y = props.y, xAxis = props.xAxis, yAxis = props.yAxis, scales = (0, _CartesianUtils.createLabeledScales)({
        x: xAxis.scale,
        y: yAxis.scale
      }), result = scales.apply({
        x,
        y
      }, {
        bandAware: !0
      });
      return (0, _IfOverflowMatches.ifOverflowMatches)(props, "discard") && !scales.isInRange(result) ? null : result;
    };
    function ReferenceDot(props) {
      var x = props.x, y = props.y, r = props.r, alwaysShow = props.alwaysShow, clipPathId = props.clipPathId, isX = (0, _DataUtils.isNumOrStr)(x), isY = (0, _DataUtils.isNumOrStr)(y);
      if ((0, _LogUtils.warn)(alwaysShow === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.'), !isX || !isY)
        return null;
      var coordinate = getCoordinate(props);
      if (!coordinate)
        return null;
      var cx = coordinate.x, cy = coordinate.y, shape = props.shape, className = props.className, clipPath = (0, _IfOverflowMatches.ifOverflowMatches)(props, "hidden") ? "url(#".concat(clipPathId, ")") : void 0, dotProps = _objectSpread3(_objectSpread3({
        clipPath
      }, (0, _types.filterProps)(props, !0)), {}, {
        cx,
        cy
      });
      return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
        className: (0, _classnames.default)("recharts-reference-dot", className)
      }, ReferenceDot.renderDot(shape, dotProps), _Label.Label.renderCallByParent(props, {
        x: cx - r,
        y: cy - r,
        width: 2 * r,
        height: 2 * r
      }));
    }
    ReferenceDot.displayName = "ReferenceDot";
    ReferenceDot.defaultProps = {
      isFront: !1,
      ifOverflow: "discard",
      xAxisId: 0,
      yAxisId: 0,
      r: 10,
      fill: "#fff",
      stroke: "#ccc",
      fillOpacity: 1,
      strokeWidth: 1
    };
    ReferenceDot.renderDot = function(option, props) {
      var dot;
      return /* @__PURE__ */ _react.default.isValidElement(option) ? dot = /* @__PURE__ */ _react.default.cloneElement(option, props) : (0, _isFunction2.default)(option) ? dot = option(props) : dot = /* @__PURE__ */ _react.default.createElement(_Dot.Dot, _extends({}, props, {
        cx: props.cx,
        cy: props.cy,
        className: "recharts-reference-dot-dot"
      })), dot;
    };
  }
});

// node_modules/recharts/lib/cartesian/ReferenceArea.js
var require_ReferenceArea = __commonJS({
  "node_modules/recharts/lib/cartesian/ReferenceArea.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.ReferenceArea = ReferenceArea;
    var _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _react = _interopRequireDefault(require("react")), _classnames = _interopRequireDefault(require("classnames")), _Layer = require_Layer(), _Label = require_Label(), _CartesianUtils = require_CartesianUtils(), _IfOverflowMatches = require_IfOverflowMatches(), _DataUtils = require_DataUtils(), _LogUtils = require_LogUtils(), _Rectangle = require_Rectangle(), _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    var getRect = function(hasX1, hasX2, hasY1, hasY2, props) {
      var xValue1 = props.x1, xValue2 = props.x2, yValue1 = props.y1, yValue2 = props.y2, xAxis = props.xAxis, yAxis = props.yAxis;
      if (!xAxis || !yAxis)
        return null;
      var scales = (0, _CartesianUtils.createLabeledScales)({
        x: xAxis.scale,
        y: yAxis.scale
      }), p1 = {
        x: hasX1 ? scales.x.apply(xValue1, {
          position: "start"
        }) : scales.x.rangeMin,
        y: hasY1 ? scales.y.apply(yValue1, {
          position: "start"
        }) : scales.y.rangeMin
      }, p2 = {
        x: hasX2 ? scales.x.apply(xValue2, {
          position: "end"
        }) : scales.x.rangeMax,
        y: hasY2 ? scales.y.apply(yValue2, {
          position: "end"
        }) : scales.y.rangeMax
      };
      return (0, _IfOverflowMatches.ifOverflowMatches)(props, "discard") && (!scales.isInRange(p1) || !scales.isInRange(p2)) ? null : (0, _CartesianUtils.rectWithPoints)(p1, p2);
    };
    function ReferenceArea(props) {
      var x1 = props.x1, x2 = props.x2, y1 = props.y1, y2 = props.y2, className = props.className, alwaysShow = props.alwaysShow, clipPathId = props.clipPathId;
      (0, _LogUtils.warn)(alwaysShow === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.');
      var hasX1 = (0, _DataUtils.isNumOrStr)(x1), hasX2 = (0, _DataUtils.isNumOrStr)(x2), hasY1 = (0, _DataUtils.isNumOrStr)(y1), hasY2 = (0, _DataUtils.isNumOrStr)(y2), shape = props.shape;
      if (!hasX1 && !hasX2 && !hasY1 && !hasY2 && !shape)
        return null;
      var rect = getRect(hasX1, hasX2, hasY1, hasY2, props);
      if (!rect && !shape)
        return null;
      var clipPath = (0, _IfOverflowMatches.ifOverflowMatches)(props, "hidden") ? "url(#".concat(clipPathId, ")") : void 0;
      return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
        className: (0, _classnames.default)("recharts-reference-area", className)
      }, ReferenceArea.renderRect(shape, _objectSpread3(_objectSpread3({
        clipPath
      }, (0, _types.filterProps)(props, !0)), rect)), _Label.Label.renderCallByParent(props, rect));
    }
    ReferenceArea.displayName = "ReferenceArea";
    ReferenceArea.defaultProps = {
      isFront: !1,
      ifOverflow: "discard",
      xAxisId: 0,
      yAxisId: 0,
      r: 10,
      fill: "#ccc",
      fillOpacity: 0.5,
      stroke: "none",
      strokeWidth: 1
    };
    ReferenceArea.renderRect = function(option, props) {
      var rect;
      return /* @__PURE__ */ _react.default.isValidElement(option) ? rect = /* @__PURE__ */ _react.default.cloneElement(option, props) : (0, _isFunction2.default)(option) ? rect = option(props) : rect = /* @__PURE__ */ _react.default.createElement(_Rectangle.Rectangle, _extends({}, props, {
        className: "recharts-reference-area-rect"
      })), rect;
    };
  }
});

// node_modules/recharts/lib/cartesian/CartesianAxis.js
var require_CartesianAxis = __commonJS({
  "node_modules/recharts/lib/cartesian/CartesianAxis.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.CartesianAxis = void 0;
    var _get2 = _interopRequireDefault(require("lodash/get")), _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _react = _interopRequireWildcard(require("react")), _classnames = _interopRequireDefault(require("classnames")), _ShallowEqual = require_ShallowEqual(), _DOMUtils = require_DOMUtils(), _Layer = require_Layer(), _Text = require_Text(), _Label = require_Label(), _Global = require_Global(), _DataUtils = require_DataUtils(), _types = require_types();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose2(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source, key) || (target[key] = source[key]));
      }
      return target;
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var CartesianAxis = /* @__PURE__ */ function(_Component) {
      _inherits(CartesianAxis2, _Component);
      var _super = _createSuper(CartesianAxis2);
      function CartesianAxis2(props) {
        var _this;
        return _classCallCheck(this, CartesianAxis2), _this = _super.call(this, props), _this.layerReference = void 0, _this.state = {
          fontSize: "",
          letterSpacing: ""
        }, _this;
      }
      return _createClass(CartesianAxis2, [{
        key: "shouldComponentUpdate",
        value: function(_ref, nextState) {
          var viewBox = _ref.viewBox, restProps = _objectWithoutProperties2(_ref, ["viewBox"]), _this$props = this.props, viewBoxOld = _this$props.viewBox, restPropsOld = _objectWithoutProperties2(_this$props, ["viewBox"]);
          return !(0, _ShallowEqual.shallowEqual)(viewBox, viewBoxOld) || !(0, _ShallowEqual.shallowEqual)(restProps, restPropsOld) || !(0, _ShallowEqual.shallowEqual)(nextState, this.state);
        }
      }, {
        key: "componentDidMount",
        value: function() {
          var htmlLayer = this.layerReference;
          if (!!htmlLayer) {
            var tick = htmlLayer.getElementsByClassName("recharts-cartesian-axis-tick-value")[0];
            tick && this.setState({
              fontSize: window.getComputedStyle(tick).fontSize,
              letterSpacing: window.getComputedStyle(tick).letterSpacing
            });
          }
        }
      }, {
        key: "getTickLineCoord",
        value: function(data) {
          var _this$props2 = this.props, x = _this$props2.x, y = _this$props2.y, width = _this$props2.width, height = _this$props2.height, orientation = _this$props2.orientation, tickSize = _this$props2.tickSize, mirror = _this$props2.mirror, tickMargin = _this$props2.tickMargin, x1, x2, y1, y2, tx, ty, sign = mirror ? -1 : 1, finalTickSize = data.tickSize || tickSize, tickCoord = (0, _DataUtils.isNumber)(data.tickCoord) ? data.tickCoord : data.coordinate;
          switch (orientation) {
            case "top":
              x1 = x2 = data.coordinate, y2 = y + +!mirror * height, y1 = y2 - sign * finalTickSize, ty = y1 - sign * tickMargin, tx = tickCoord;
              break;
            case "left":
              y1 = y2 = data.coordinate, x2 = x + +!mirror * width, x1 = x2 - sign * finalTickSize, tx = x1 - sign * tickMargin, ty = tickCoord;
              break;
            case "right":
              y1 = y2 = data.coordinate, x2 = x + +mirror * width, x1 = x2 + sign * finalTickSize, tx = x1 + sign * tickMargin, ty = tickCoord;
              break;
            default:
              x1 = x2 = data.coordinate, y2 = y + +mirror * height, y1 = y2 + sign * finalTickSize, ty = y1 + sign * tickMargin, tx = tickCoord;
              break;
          }
          return {
            line: {
              x1,
              y1,
              x2,
              y2
            },
            tick: {
              x: tx,
              y: ty
            }
          };
        }
      }, {
        key: "getTickTextAnchor",
        value: function() {
          var _this$props3 = this.props, orientation = _this$props3.orientation, mirror = _this$props3.mirror, textAnchor;
          switch (orientation) {
            case "left":
              textAnchor = mirror ? "start" : "end";
              break;
            case "right":
              textAnchor = mirror ? "end" : "start";
              break;
            default:
              textAnchor = "middle";
              break;
          }
          return textAnchor;
        }
      }, {
        key: "getTickVerticalAnchor",
        value: function() {
          var _this$props4 = this.props, orientation = _this$props4.orientation, mirror = _this$props4.mirror, verticalAnchor = "end";
          switch (orientation) {
            case "left":
            case "right":
              verticalAnchor = "middle";
              break;
            case "top":
              verticalAnchor = mirror ? "start" : "end";
              break;
            default:
              verticalAnchor = mirror ? "end" : "start";
              break;
          }
          return verticalAnchor;
        }
      }, {
        key: "renderAxisLine",
        value: function() {
          var _this$props5 = this.props, x = _this$props5.x, y = _this$props5.y, width = _this$props5.width, height = _this$props5.height, orientation = _this$props5.orientation, mirror = _this$props5.mirror, axisLine = _this$props5.axisLine, props = _objectSpread3(_objectSpread3(_objectSpread3({}, (0, _types.filterProps)(this.props)), (0, _types.filterProps)(axisLine)), {}, {
            fill: "none"
          });
          if (orientation === "top" || orientation === "bottom") {
            var needHeight = +(orientation === "top" && !mirror || orientation === "bottom" && mirror);
            props = _objectSpread3(_objectSpread3({}, props), {}, {
              x1: x,
              y1: y + needHeight * height,
              x2: x + width,
              y2: y + needHeight * height
            });
          } else {
            var needWidth = +(orientation === "left" && !mirror || orientation === "right" && mirror);
            props = _objectSpread3(_objectSpread3({}, props), {}, {
              x1: x + needWidth * width,
              y1: y,
              x2: x + needWidth * width,
              y2: y + height
            });
          }
          return /* @__PURE__ */ _react.default.createElement("line", _extends({}, props, {
            className: (0, _classnames.default)("recharts-cartesian-axis-line", (0, _get2.default)(axisLine, "className"))
          }));
        }
      }, {
        key: "renderTicks",
        value: function(ticks, fontSize, letterSpacing) {
          var _this2 = this, _this$props6 = this.props, tickLine = _this$props6.tickLine, stroke = _this$props6.stroke, tick = _this$props6.tick, tickFormatter = _this$props6.tickFormatter, unit = _this$props6.unit, finalTicks = CartesianAxis2.getTicks(_objectSpread3(_objectSpread3({}, this.props), {}, {
            ticks
          }), fontSize, letterSpacing), textAnchor = this.getTickTextAnchor(), verticalAnchor = this.getTickVerticalAnchor(), axisProps = (0, _types.filterProps)(this.props), customTickProps = (0, _types.filterProps)(tick), tickLineProps = _objectSpread3(_objectSpread3({}, axisProps), {}, {
            fill: "none"
          }, (0, _types.filterProps)(tickLine)), items = finalTicks.map(function(entry2, i) {
            var _this2$getTickLineCoo = _this2.getTickLineCoord(entry2), lineCoord = _this2$getTickLineCoo.line, tickCoord = _this2$getTickLineCoo.tick, tickProps = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({
              textAnchor,
              verticalAnchor
            }, axisProps), {}, {
              stroke: "none",
              fill: stroke
            }, customTickProps), tickCoord), {}, {
              index: i,
              payload: entry2,
              visibleTicksCount: finalTicks.length,
              tickFormatter
            });
            return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, _extends({
              className: "recharts-cartesian-axis-tick",
              key: "tick-".concat(i)
            }, (0, _types.adaptEventsOfChild)(_this2.props, entry2, i)), tickLine && /* @__PURE__ */ _react.default.createElement("line", _extends({}, tickLineProps, lineCoord, {
              className: (0, _classnames.default)("recharts-cartesian-axis-tick-line", (0, _get2.default)(tickLine, "className"))
            })), tick && CartesianAxis2.renderTickItem(tick, tickProps, "".concat((0, _isFunction2.default)(tickFormatter) ? tickFormatter(entry2.value, i) : entry2.value).concat(unit || "")));
          });
          return /* @__PURE__ */ _react.default.createElement("g", {
            className: "recharts-cartesian-axis-ticks"
          }, items);
        }
      }, {
        key: "render",
        value: function() {
          var _this3 = this, _this$props7 = this.props, axisLine = _this$props7.axisLine, width = _this$props7.width, height = _this$props7.height, ticksGenerator = _this$props7.ticksGenerator, className = _this$props7.className, hide = _this$props7.hide;
          if (hide)
            return null;
          var _this$props8 = this.props, ticks = _this$props8.ticks, noTicksProps = _objectWithoutProperties2(_this$props8, ["ticks"]), finalTicks = ticks;
          return (0, _isFunction2.default)(ticksGenerator) && (finalTicks = ticks && ticks.length > 0 ? ticksGenerator(this.props) : ticksGenerator(noTicksProps)), width <= 0 || height <= 0 || !finalTicks || !finalTicks.length ? null : /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: (0, _classnames.default)("recharts-cartesian-axis", className),
            ref: function(_ref2) {
              _this3.layerReference = _ref2;
            }
          }, axisLine && this.renderAxisLine(), this.renderTicks(finalTicks, this.state.fontSize, this.state.letterSpacing), _Label.Label.renderCallByParent(this.props));
        }
      }], [{
        key: "getTicks",
        value: function(props, fontSize, letterSpacing) {
          var tick = props.tick, ticks = props.ticks, viewBox = props.viewBox, minTickGap = props.minTickGap, orientation = props.orientation, interval = props.interval, tickFormatter = props.tickFormatter, unit = props.unit;
          return !ticks || !ticks.length || !tick ? [] : (0, _DataUtils.isNumber)(interval) || _Global.Global.isSsr ? CartesianAxis2.getNumberIntervalTicks(ticks, typeof interval == "number" && (0, _DataUtils.isNumber)(interval) ? interval : 0) : interval === "preserveStartEnd" ? CartesianAxis2.getTicksStart({
            ticks,
            tickFormatter,
            viewBox,
            orientation,
            minTickGap,
            unit,
            fontSize,
            letterSpacing
          }, !0) : interval === "preserveStart" ? CartesianAxis2.getTicksStart({
            ticks,
            tickFormatter,
            viewBox,
            orientation,
            minTickGap,
            unit,
            fontSize,
            letterSpacing
          }) : CartesianAxis2.getTicksEnd({
            ticks,
            tickFormatter,
            viewBox,
            orientation,
            minTickGap,
            unit,
            fontSize,
            letterSpacing
          });
        }
      }, {
        key: "getNumberIntervalTicks",
        value: function(ticks, interval) {
          return ticks.filter(function(entry2, i) {
            return i % (interval + 1) === 0;
          });
        }
      }, {
        key: "getTicksStart",
        value: function(_ref3, preserveEnd) {
          var ticks = _ref3.ticks, tickFormatter = _ref3.tickFormatter, viewBox = _ref3.viewBox, orientation = _ref3.orientation, minTickGap = _ref3.minTickGap, unit = _ref3.unit, fontSize = _ref3.fontSize, letterSpacing = _ref3.letterSpacing, x = viewBox.x, y = viewBox.y, width = viewBox.width, height = viewBox.height, sizeKey = orientation === "top" || orientation === "bottom" ? "width" : "height", result = (ticks || []).slice(), unitSize = unit && sizeKey === "width" ? (0, _DOMUtils.getStringSize)(unit, {
            fontSize,
            letterSpacing
          })[sizeKey] : 0, len = result.length, sign = len >= 2 ? (0, _DataUtils.mathSign)(result[1].coordinate - result[0].coordinate) : 1, start, end;
          if (sign === 1 ? (start = sizeKey === "width" ? x : y, end = sizeKey === "width" ? x + width : y + height) : (start = sizeKey === "width" ? x + width : y + height, end = sizeKey === "width" ? x : y), preserveEnd) {
            var tail = ticks[len - 1], tailContent = (0, _isFunction2.default)(tickFormatter) ? tickFormatter(tail.value, len - 1) : tail.value, tailSize = (0, _DOMUtils.getStringSize)(tailContent, {
              fontSize,
              letterSpacing
            })[sizeKey] + unitSize, tailGap = sign * (tail.coordinate + sign * tailSize / 2 - end);
            result[len - 1] = tail = _objectSpread3(_objectSpread3({}, tail), {}, {
              tickCoord: tailGap > 0 ? tail.coordinate - tailGap * sign : tail.coordinate
            });
            var isTailShow = sign * (tail.tickCoord - sign * tailSize / 2 - start) >= 0 && sign * (tail.tickCoord + sign * tailSize / 2 - end) <= 0;
            isTailShow && (end = tail.tickCoord - sign * (tailSize / 2 + minTickGap), result[len - 1] = _objectSpread3(_objectSpread3({}, tail), {}, {
              isShow: !0
            }));
          }
          for (var count = preserveEnd ? len - 1 : len, i = 0; i < count; i++) {
            var entry2 = result[i], content = (0, _isFunction2.default)(tickFormatter) ? tickFormatter(entry2.value, i) : entry2.value, size = (0, _DOMUtils.getStringSize)(content, {
              fontSize,
              letterSpacing
            })[sizeKey] + unitSize;
            if (i === 0) {
              var gap = sign * (entry2.coordinate - sign * size / 2 - start);
              result[i] = entry2 = _objectSpread3(_objectSpread3({}, entry2), {}, {
                tickCoord: gap < 0 ? entry2.coordinate - gap * sign : entry2.coordinate
              });
            } else
              result[i] = entry2 = _objectSpread3(_objectSpread3({}, entry2), {}, {
                tickCoord: entry2.coordinate
              });
            var isShow = sign * (entry2.tickCoord - sign * size / 2 - start) >= 0 && sign * (entry2.tickCoord + sign * size / 2 - end) <= 0;
            isShow && (start = entry2.tickCoord + sign * (size / 2 + minTickGap), result[i] = _objectSpread3(_objectSpread3({}, entry2), {}, {
              isShow: !0
            }));
          }
          return result.filter(function(entry3) {
            return entry3.isShow;
          });
        }
      }, {
        key: "getTicksEnd",
        value: function(_ref4) {
          var ticks = _ref4.ticks, tickFormatter = _ref4.tickFormatter, viewBox = _ref4.viewBox, orientation = _ref4.orientation, minTickGap = _ref4.minTickGap, unit = _ref4.unit, fontSize = _ref4.fontSize, letterSpacing = _ref4.letterSpacing, x = viewBox.x, y = viewBox.y, width = viewBox.width, height = viewBox.height, sizeKey = orientation === "top" || orientation === "bottom" ? "width" : "height", unitSize = unit && sizeKey === "width" ? (0, _DOMUtils.getStringSize)(unit, {
            fontSize,
            letterSpacing
          })[sizeKey] : 0, result = (ticks || []).slice(), len = result.length, sign = len >= 2 ? (0, _DataUtils.mathSign)(result[1].coordinate - result[0].coordinate) : 1, start, end;
          sign === 1 ? (start = sizeKey === "width" ? x : y, end = sizeKey === "width" ? x + width : y + height) : (start = sizeKey === "width" ? x + width : y + height, end = sizeKey === "width" ? x : y);
          for (var i = len - 1; i >= 0; i--) {
            var entry2 = result[i], content = (0, _isFunction2.default)(tickFormatter) ? tickFormatter(entry2.value, len - i - 1) : entry2.value, size = (0, _DOMUtils.getStringSize)(content, {
              fontSize,
              letterSpacing
            })[sizeKey] + unitSize;
            if (i === len - 1) {
              var gap = sign * (entry2.coordinate + sign * size / 2 - end);
              result[i] = entry2 = _objectSpread3(_objectSpread3({}, entry2), {}, {
                tickCoord: gap > 0 ? entry2.coordinate - gap * sign : entry2.coordinate
              });
            } else
              result[i] = entry2 = _objectSpread3(_objectSpread3({}, entry2), {}, {
                tickCoord: entry2.coordinate
              });
            var isShow = sign * (entry2.tickCoord - sign * size / 2 - start) >= 0 && sign * (entry2.tickCoord + sign * size / 2 - end) <= 0;
            isShow && (end = entry2.tickCoord - sign * (size / 2 + minTickGap), result[i] = _objectSpread3(_objectSpread3({}, entry2), {}, {
              isShow: !0
            }));
          }
          return result.filter(function(entry3) {
            return entry3.isShow;
          });
        }
      }, {
        key: "renderTickItem",
        value: function(option, props, value) {
          var tickItem;
          return /* @__PURE__ */ _react.default.isValidElement(option) ? tickItem = /* @__PURE__ */ _react.default.cloneElement(option, props) : (0, _isFunction2.default)(option) ? tickItem = option(props) : tickItem = /* @__PURE__ */ _react.default.createElement(_Text.Text, _extends({}, props, {
            className: "recharts-cartesian-axis-tick-value"
          }), value), tickItem;
        }
      }]), CartesianAxis2;
    }(_react.Component);
    exports.CartesianAxis = CartesianAxis;
    CartesianAxis.displayName = "CartesianAxis";
    CartesianAxis.defaultProps = {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      viewBox: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      },
      orientation: "bottom",
      ticks: [],
      stroke: "#666",
      tickLine: !0,
      axisLine: !0,
      tick: !0,
      mirror: !1,
      minTickGap: 5,
      tickSize: 6,
      tickMargin: 2,
      interval: "preserveEnd"
    };
  }
});

// node_modules/recharts/lib/cartesian/CartesianGrid.js
var require_CartesianGrid = __commonJS({
  "node_modules/recharts/lib/cartesian/CartesianGrid.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.CartesianGrid = void 0;
    var _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _react = _interopRequireWildcard(require("react")), _DataUtils = require_DataUtils(), _types = require_types();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose2(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source, key) || (target[key] = source[key]));
      }
      return target;
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var CartesianGrid = /* @__PURE__ */ function(_PureComponent) {
      _inherits(CartesianGrid2, _PureComponent);
      var _super = _createSuper(CartesianGrid2);
      function CartesianGrid2() {
        return _classCallCheck(this, CartesianGrid2), _super.apply(this, arguments);
      }
      return _createClass(CartesianGrid2, [{
        key: "renderHorizontal",
        value: function(horizontalPoints) {
          var _this = this, _this$props = this.props, x = _this$props.x, width = _this$props.width, horizontal = _this$props.horizontal;
          if (!horizontalPoints || !horizontalPoints.length)
            return null;
          var items = horizontalPoints.map(function(entry2, i) {
            var props = _objectSpread3(_objectSpread3({}, _this.props), {}, {
              x1: x,
              y1: entry2,
              x2: x + width,
              y2: entry2,
              key: "line-".concat(i),
              index: i
            });
            return CartesianGrid2.renderLineItem(horizontal, props);
          });
          return /* @__PURE__ */ _react.default.createElement("g", {
            className: "recharts-cartesian-grid-horizontal"
          }, items);
        }
      }, {
        key: "renderVertical",
        value: function(verticalPoints) {
          var _this2 = this, _this$props2 = this.props, y = _this$props2.y, height = _this$props2.height, vertical = _this$props2.vertical;
          if (!verticalPoints || !verticalPoints.length)
            return null;
          var items = verticalPoints.map(function(entry2, i) {
            var props = _objectSpread3(_objectSpread3({}, _this2.props), {}, {
              x1: entry2,
              y1: y,
              x2: entry2,
              y2: y + height,
              key: "line-".concat(i),
              index: i
            });
            return CartesianGrid2.renderLineItem(vertical, props);
          });
          return /* @__PURE__ */ _react.default.createElement("g", {
            className: "recharts-cartesian-grid-vertical"
          }, items);
        }
      }, {
        key: "renderVerticalStripes",
        value: function(verticalPoints) {
          var verticalFill = this.props.verticalFill;
          if (!verticalFill || !verticalFill.length)
            return null;
          var _this$props3 = this.props, fillOpacity = _this$props3.fillOpacity, x = _this$props3.x, y = _this$props3.y, width = _this$props3.width, height = _this$props3.height, roundedSortedVerticalPoints = verticalPoints.map(function(e) {
            return Math.round(e + x - x);
          }).sort(function(a, b) {
            return a - b;
          });
          x !== roundedSortedVerticalPoints[0] && roundedSortedVerticalPoints.unshift(0);
          var items = roundedSortedVerticalPoints.map(function(entry2, i) {
            var lastStripe = !roundedSortedVerticalPoints[i + 1], lineWidth = lastStripe ? x + width - entry2 : roundedSortedVerticalPoints[i + 1] - entry2;
            if (lineWidth <= 0)
              return null;
            var colorIndex = i % verticalFill.length;
            return /* @__PURE__ */ _react.default.createElement("rect", {
              key: "react-".concat(i),
              x: entry2,
              y,
              width: lineWidth,
              height,
              stroke: "none",
              fill: verticalFill[colorIndex],
              fillOpacity,
              className: "recharts-cartesian-grid-bg"
            });
          });
          return /* @__PURE__ */ _react.default.createElement("g", {
            className: "recharts-cartesian-gridstripes-vertical"
          }, items);
        }
      }, {
        key: "renderHorizontalStripes",
        value: function(horizontalPoints) {
          var horizontalFill = this.props.horizontalFill;
          if (!horizontalFill || !horizontalFill.length)
            return null;
          var _this$props4 = this.props, fillOpacity = _this$props4.fillOpacity, x = _this$props4.x, y = _this$props4.y, width = _this$props4.width, height = _this$props4.height, roundedSortedHorizontalPoints = horizontalPoints.map(function(e) {
            return Math.round(e + y - y);
          }).sort(function(a, b) {
            return a - b;
          });
          y !== roundedSortedHorizontalPoints[0] && roundedSortedHorizontalPoints.unshift(0);
          var items = roundedSortedHorizontalPoints.map(function(entry2, i) {
            var lastStripe = !roundedSortedHorizontalPoints[i + 1], lineHeight = lastStripe ? y + height - entry2 : roundedSortedHorizontalPoints[i + 1] - entry2;
            if (lineHeight <= 0)
              return null;
            var colorIndex = i % horizontalFill.length;
            return /* @__PURE__ */ _react.default.createElement("rect", {
              key: "react-".concat(i),
              y: entry2,
              x,
              height: lineHeight,
              width,
              stroke: "none",
              fill: horizontalFill[colorIndex],
              fillOpacity,
              className: "recharts-cartesian-grid-bg"
            });
          });
          return /* @__PURE__ */ _react.default.createElement("g", {
            className: "recharts-cartesian-gridstripes-horizontal"
          }, items);
        }
      }, {
        key: "renderBackground",
        value: function() {
          var fill = this.props.fill;
          if (!fill || fill === "none")
            return null;
          var _this$props5 = this.props, fillOpacity = _this$props5.fillOpacity, x = _this$props5.x, y = _this$props5.y, width = _this$props5.width, height = _this$props5.height;
          return /* @__PURE__ */ _react.default.createElement("rect", {
            x,
            y,
            width,
            height,
            stroke: "none",
            fill,
            fillOpacity,
            className: "recharts-cartesian-grid-bg"
          });
        }
      }, {
        key: "render",
        value: function() {
          var _this$props6 = this.props, x = _this$props6.x, y = _this$props6.y, width = _this$props6.width, height = _this$props6.height, horizontal = _this$props6.horizontal, vertical = _this$props6.vertical, horizontalCoordinatesGenerator = _this$props6.horizontalCoordinatesGenerator, verticalCoordinatesGenerator = _this$props6.verticalCoordinatesGenerator, xAxis = _this$props6.xAxis, yAxis = _this$props6.yAxis, offset = _this$props6.offset, chartWidth = _this$props6.chartWidth, chartHeight = _this$props6.chartHeight;
          if (!(0, _DataUtils.isNumber)(width) || width <= 0 || !(0, _DataUtils.isNumber)(height) || height <= 0 || !(0, _DataUtils.isNumber)(x) || x !== +x || !(0, _DataUtils.isNumber)(y) || y !== +y)
            return null;
          var _this$props7 = this.props, horizontalPoints = _this$props7.horizontalPoints, verticalPoints = _this$props7.verticalPoints;
          return (!horizontalPoints || !horizontalPoints.length) && (0, _isFunction2.default)(horizontalCoordinatesGenerator) && (horizontalPoints = horizontalCoordinatesGenerator({
            yAxis,
            width: chartWidth,
            height: chartHeight,
            offset
          })), (!verticalPoints || !verticalPoints.length) && (0, _isFunction2.default)(verticalCoordinatesGenerator) && (verticalPoints = verticalCoordinatesGenerator({
            xAxis,
            width: chartWidth,
            height: chartHeight,
            offset
          })), /* @__PURE__ */ _react.default.createElement("g", {
            className: "recharts-cartesian-grid"
          }, this.renderBackground(), horizontal && this.renderHorizontal(horizontalPoints), vertical && this.renderVertical(verticalPoints), horizontal && this.renderHorizontalStripes(horizontalPoints), vertical && this.renderVerticalStripes(verticalPoints));
        }
      }], [{
        key: "renderLineItem",
        value: function(option, props) {
          var lineItem;
          if (/* @__PURE__ */ _react.default.isValidElement(option))
            lineItem = /* @__PURE__ */ _react.default.cloneElement(option, props);
          else if ((0, _isFunction2.default)(option))
            lineItem = option(props);
          else {
            var x1 = props.x1, y1 = props.y1, x2 = props.x2, y2 = props.y2, key = props.key, others = _objectWithoutProperties2(props, ["x1", "y1", "x2", "y2", "key"]);
            lineItem = /* @__PURE__ */ _react.default.createElement("line", _extends({}, (0, _types.filterProps)(others), {
              x1,
              y1,
              x2,
              y2,
              fill: "none",
              key
            }));
          }
          return lineItem;
        }
      }]), CartesianGrid2;
    }(_react.PureComponent);
    exports.CartesianGrid = CartesianGrid;
    CartesianGrid.displayName = "CartesianGrid";
    CartesianGrid.defaultProps = {
      horizontal: !0,
      vertical: !0,
      horizontalPoints: [],
      verticalPoints: [],
      stroke: "#ccc",
      fill: "none",
      verticalFill: [],
      horizontalFill: []
    };
  }
});

// node_modules/recharts/lib/cartesian/ErrorBar.js
var require_ErrorBar = __commonJS({
  "node_modules/recharts/lib/cartesian/ErrorBar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.ErrorBar = ErrorBar;
    var _react = _interopRequireDefault(require("react")), _Layer = require_Layer(), _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!!o) {
        if (typeof o == "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
    }
    function _arrayLikeToArray(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(arr)))) {
        var _arr = [], _n = !0, _d = !1, _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose2(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source, key) || (target[key] = source[key]));
      }
      return target;
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    function ErrorBar(props) {
      var offset = props.offset, layout = props.layout, width = props.width, dataKey = props.dataKey, data = props.data, dataPointFormatter = props.dataPointFormatter, xAxis = props.xAxis, yAxis = props.yAxis, others = _objectWithoutProperties2(props, ["offset", "layout", "width", "dataKey", "data", "dataPointFormatter", "xAxis", "yAxis"]), svgProps = (0, _types.filterProps)(others), errorBars = data.map(function(entry2, i) {
        var _dataPointFormatter = dataPointFormatter(entry2, dataKey), x = _dataPointFormatter.x, y = _dataPointFormatter.y, value = _dataPointFormatter.value, errorVal = _dataPointFormatter.errorVal;
        if (!errorVal)
          return null;
        var lineCoordinates = [], lowBound, highBound;
        if (Array.isArray(errorVal)) {
          var _errorVal = _slicedToArray(errorVal, 2);
          lowBound = _errorVal[0], highBound = _errorVal[1];
        } else
          lowBound = highBound = errorVal;
        if (layout === "vertical") {
          var scale = xAxis.scale, yMid = y + offset, yMin = yMid + width, yMax = yMid - width, xMin = scale(value - lowBound), xMax = scale(value + highBound);
          lineCoordinates.push({
            x1: xMax,
            y1: yMin,
            x2: xMax,
            y2: yMax
          }), lineCoordinates.push({
            x1: xMin,
            y1: yMid,
            x2: xMax,
            y2: yMid
          }), lineCoordinates.push({
            x1: xMin,
            y1: yMin,
            x2: xMin,
            y2: yMax
          });
        } else if (layout === "horizontal") {
          var _scale = yAxis.scale, xMid = x + offset, _xMin = xMid - width, _xMax = xMid + width, _yMin = _scale(value - lowBound), _yMax = _scale(value + highBound);
          lineCoordinates.push({
            x1: _xMin,
            y1: _yMax,
            x2: _xMax,
            y2: _yMax
          }), lineCoordinates.push({
            x1: xMid,
            y1: _yMin,
            x2: xMid,
            y2: _yMax
          }), lineCoordinates.push({
            x1: _xMin,
            y1: _yMin,
            x2: _xMax,
            y2: _yMin
          });
        }
        return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, _extends({
          className: "recharts-errorBar",
          key: "bar-".concat(i)
        }, svgProps), lineCoordinates.map(function(coordinates, index) {
          return /* @__PURE__ */ _react.default.createElement("line", _extends({}, coordinates, {
            key: "line-".concat(index)
          }));
        }));
      });
      return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
        className: "recharts-errorBars"
      }, errorBars);
    }
    ErrorBar.defaultProps = {
      stroke: "black",
      strokeWidth: 1.5,
      width: 5,
      offset: 0,
      layout: "horizontal"
    };
    ErrorBar.displayName = "ErrorBar";
  }
});

// node_modules/recharts/lib/cartesian/Line.js
var require_Line = __commonJS({
  "node_modules/recharts/lib/cartesian/Line.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Line = void 0;
    var _isEqual2 = _interopRequireDefault(require("lodash/isEqual")), _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _isNil2 = _interopRequireDefault(require("lodash/isNil")), _react = _interopRequireWildcard(require("react")), _reactSmooth = _interopRequireDefault(require("react-smooth")), _classnames = _interopRequireDefault(require("classnames")), _Curve = require_Curve(), _Dot = require_Dot(), _Layer = require_Layer(), _LabelList = require_LabelList(), _ErrorBar = require_ErrorBar(), _DataUtils = require_DataUtils(), _ReactUtils = require_ReactUtils(), _Global = require_Global(), _ChartUtils = require_ChartUtils(), _types = require_types();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose2(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source, key) || (target[key] = source[key]));
      }
      return target;
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!!o) {
        if (typeof o == "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
    }
    function _iterableToArray(iter) {
      if (typeof Symbol < "u" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var Line = /* @__PURE__ */ function(_PureComponent) {
      _inherits(Line2, _PureComponent);
      var _super = _createSuper(Line2);
      function Line2() {
        var _this;
        _classCallCheck(this, Line2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        return _this = _super.call.apply(_super, [this].concat(args)), _this.mainCurve = void 0, _this.state = {
          isAnimationFinished: !0,
          totalLength: 0
        }, _this.getStrokeDasharray = function(length, totalLength, lines) {
          for (var lineLength = lines.reduce(function(pre, next) {
            return pre + next;
          }), count = Math.floor(length / lineLength), remainLength = length % lineLength, restLength = totalLength - length, remainLines = [], i = 0, sum = 0; ; sum += lines[i], ++i)
            if (sum + lines[i] > remainLength) {
              remainLines = [].concat(_toConsumableArray(lines.slice(0, i)), [remainLength - sum]);
              break;
            }
          var emptyLines = remainLines.length % 2 === 0 ? [0, restLength] : [restLength];
          return [].concat(_toConsumableArray(Line2.repeat(lines, count)), _toConsumableArray(remainLines), emptyLines).map(function(line) {
            return "".concat(line, "px");
          }).join(", ");
        }, _this.id = (0, _DataUtils.uniqueId)("recharts-line-"), _this.pathRef = function(node) {
          _this.mainCurve = node;
        }, _this.handleAnimationEnd = function() {
          _this.setState({
            isAnimationFinished: !0
          }), _this.props.onAnimationEnd && _this.props.onAnimationEnd();
        }, _this.handleAnimationStart = function() {
          _this.setState({
            isAnimationFinished: !1
          }), _this.props.onAnimationStart && _this.props.onAnimationStart();
        }, _this;
      }
      return _createClass(Line2, [{
        key: "componentDidMount",
        value: function() {
          if (!!this.props.isAnimationActive) {
            var totalLength = this.getTotalLength();
            this.setState({
              totalLength
            });
          }
        }
      }, {
        key: "getTotalLength",
        value: function() {
          var curveDom = this.mainCurve;
          try {
            return curveDom && curveDom.getTotalLength && curveDom.getTotalLength() || 0;
          } catch {
            return 0;
          }
        }
      }, {
        key: "renderErrorBar",
        value: function() {
          if (this.props.isAnimationActive && !this.state.isAnimationFinished)
            return null;
          var _this$props = this.props, points = _this$props.points, xAxis = _this$props.xAxis, yAxis = _this$props.yAxis, layout = _this$props.layout, children = _this$props.children, errorBarItems = (0, _ReactUtils.findAllByType)(children, _ErrorBar.ErrorBar.displayName);
          if (!errorBarItems)
            return null;
          function dataPointFormatter(dataPoint, dataKey) {
            return {
              x: dataPoint.x,
              y: dataPoint.y,
              value: dataPoint.value,
              errorVal: (0, _ChartUtils.getValueByDataKey)(dataPoint.payload, dataKey)
            };
          }
          return errorBarItems.map(function(item, i) {
            return /* @__PURE__ */ _react.default.cloneElement(item, {
              key: "bar-".concat(i),
              data: points,
              xAxis,
              yAxis,
              layout,
              dataPointFormatter
            });
          });
        }
      }, {
        key: "renderDots",
        value: function(needClip, clipPathId) {
          var isAnimationActive = this.props.isAnimationActive;
          if (isAnimationActive && !this.state.isAnimationFinished)
            return null;
          var _this$props2 = this.props, dot = _this$props2.dot, points = _this$props2.points, dataKey = _this$props2.dataKey, lineProps = (0, _types.filterProps)(this.props), customDotProps = (0, _types.filterProps)(dot, !0), dots = points.map(function(entry2, i) {
            var dotProps = _objectSpread3(_objectSpread3(_objectSpread3({
              key: "dot-".concat(i),
              r: 3
            }, lineProps), customDotProps), {}, {
              value: entry2.value,
              dataKey,
              cx: entry2.x,
              cy: entry2.y,
              index: i,
              payload: entry2.payload
            });
            return Line2.renderDotItem(dot, dotProps);
          }), dotsProps = {
            clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null
          };
          return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, _extends({
            className: "recharts-line-dots",
            key: "dots"
          }, dotsProps, {
            role: "img"
          }), dots);
        }
      }, {
        key: "renderCurveStatically",
        value: function(points, needClip, clipPathId, props) {
          var _this$props3 = this.props, type = _this$props3.type, layout = _this$props3.layout, connectNulls = _this$props3.connectNulls, ref = _this$props3.ref, others = _objectWithoutProperties2(_this$props3, ["type", "layout", "connectNulls", "ref"]), curveProps = _objectSpread3(_objectSpread3(_objectSpread3({}, (0, _types.filterProps)(others, !0)), {}, {
            fill: "none",
            className: "recharts-line-curve",
            clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null,
            points
          }, props), {}, {
            type,
            layout,
            connectNulls
          });
          return /* @__PURE__ */ _react.default.createElement(_Curve.Curve, _extends({}, curveProps, {
            pathRef: this.pathRef
          }));
        }
      }, {
        key: "renderCurveWithAnimation",
        value: function(needClip, clipPathId) {
          var _this2 = this, _this$props4 = this.props, points = _this$props4.points, strokeDasharray = _this$props4.strokeDasharray, isAnimationActive = _this$props4.isAnimationActive, animationBegin = _this$props4.animationBegin, animationDuration = _this$props4.animationDuration, animationEasing = _this$props4.animationEasing, animationId = _this$props4.animationId, animateNewValues = _this$props4.animateNewValues, width = _this$props4.width, height = _this$props4.height, _this$state = this.state, prevPoints = _this$state.prevPoints, totalLength = _this$state.totalLength;
          return /* @__PURE__ */ _react.default.createElement(_reactSmooth.default, {
            begin: animationBegin,
            duration: animationDuration,
            isActive: isAnimationActive,
            easing: animationEasing,
            from: {
              t: 0
            },
            to: {
              t: 1
            },
            key: "line-".concat(animationId),
            onAnimationEnd: this.handleAnimationEnd,
            onAnimationStart: this.handleAnimationStart
          }, function(_ref) {
            var t = _ref.t;
            if (prevPoints) {
              var prevPointsDiffFactor = prevPoints.length / points.length, stepData = points.map(function(entry2, index) {
                var prevPointIndex = Math.floor(index * prevPointsDiffFactor);
                if (prevPoints[prevPointIndex]) {
                  var prev = prevPoints[prevPointIndex], interpolatorX = (0, _DataUtils.interpolateNumber)(prev.x, entry2.x), interpolatorY = (0, _DataUtils.interpolateNumber)(prev.y, entry2.y);
                  return _objectSpread3(_objectSpread3({}, entry2), {}, {
                    x: interpolatorX(t),
                    y: interpolatorY(t)
                  });
                }
                if (animateNewValues) {
                  var _interpolatorX = (0, _DataUtils.interpolateNumber)(width * 2, entry2.x), _interpolatorY = (0, _DataUtils.interpolateNumber)(height / 2, entry2.y);
                  return _objectSpread3(_objectSpread3({}, entry2), {}, {
                    x: _interpolatorX(t),
                    y: _interpolatorY(t)
                  });
                }
                return _objectSpread3(_objectSpread3({}, entry2), {}, {
                  x: entry2.x,
                  y: entry2.y
                });
              });
              return _this2.renderCurveStatically(stepData, needClip, clipPathId);
            }
            var interpolator = (0, _DataUtils.interpolateNumber)(0, totalLength), curLength = interpolator(t), currentStrokeDasharray;
            if (strokeDasharray) {
              var lines = "".concat(strokeDasharray).split(/[,\s]+/gim).map(function(num) {
                return parseFloat(num);
              });
              currentStrokeDasharray = _this2.getStrokeDasharray(curLength, totalLength, lines);
            } else
              currentStrokeDasharray = "".concat(curLength, "px ").concat(totalLength - curLength, "px");
            return _this2.renderCurveStatically(points, needClip, clipPathId, {
              strokeDasharray: currentStrokeDasharray
            });
          });
        }
      }, {
        key: "renderCurve",
        value: function(needClip, clipPathId) {
          var _this$props5 = this.props, points = _this$props5.points, isAnimationActive = _this$props5.isAnimationActive, _this$state2 = this.state, prevPoints = _this$state2.prevPoints, totalLength = _this$state2.totalLength;
          return isAnimationActive && points && points.length && (!prevPoints && totalLength > 0 || !(0, _isEqual2.default)(prevPoints, points)) ? this.renderCurveWithAnimation(needClip, clipPathId) : this.renderCurveStatically(points, needClip, clipPathId);
        }
      }, {
        key: "render",
        value: function() {
          var _this$props6 = this.props, hide = _this$props6.hide, dot = _this$props6.dot, points = _this$props6.points, className = _this$props6.className, xAxis = _this$props6.xAxis, yAxis = _this$props6.yAxis, top = _this$props6.top, left = _this$props6.left, width = _this$props6.width, height = _this$props6.height, isAnimationActive = _this$props6.isAnimationActive, id = _this$props6.id;
          if (hide || !points || !points.length)
            return null;
          var isAnimationFinished = this.state.isAnimationFinished, hasSinglePoint = points.length === 1, layerClass = (0, _classnames.default)("recharts-line", className), needClip = xAxis && xAxis.allowDataOverflow || yAxis && yAxis.allowDataOverflow, clipPathId = (0, _isNil2.default)(id) ? this.id : id;
          return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: layerClass
          }, needClip ? /* @__PURE__ */ _react.default.createElement("defs", null, /* @__PURE__ */ _react.default.createElement("clipPath", {
            id: "clipPath-".concat(clipPathId)
          }, /* @__PURE__ */ _react.default.createElement("rect", {
            x: left,
            y: top,
            width,
            height
          }))) : null, !hasSinglePoint && this.renderCurve(needClip, clipPathId), this.renderErrorBar(), (hasSinglePoint || dot) && this.renderDots(needClip, clipPathId), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(this.props, points));
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function(nextProps, prevState) {
          return nextProps.animationId !== prevState.prevAnimationId ? {
            prevAnimationId: nextProps.animationId,
            curPoints: nextProps.points,
            prevPoints: prevState.curPoints
          } : nextProps.points !== prevState.curPoints ? {
            curPoints: nextProps.points
          } : null;
        }
      }, {
        key: "repeat",
        value: function(lines, count) {
          for (var linesUnit = lines.length % 2 !== 0 ? [].concat(_toConsumableArray(lines), [0]) : lines, result = [], i = 0; i < count; ++i)
            result = [].concat(_toConsumableArray(result), _toConsumableArray(linesUnit));
          return result;
        }
      }, {
        key: "renderDotItem",
        value: function(option, props) {
          var dotItem;
          if (/* @__PURE__ */ _react.default.isValidElement(option))
            dotItem = /* @__PURE__ */ _react.default.cloneElement(option, props);
          else if ((0, _isFunction2.default)(option))
            dotItem = option(props);
          else {
            var className = (0, _classnames.default)("recharts-line-dot", option ? option.className : "");
            dotItem = /* @__PURE__ */ _react.default.createElement(_Dot.Dot, _extends({}, props, {
              className
            }));
          }
          return dotItem;
        }
      }]), Line2;
    }(_react.PureComponent);
    exports.Line = Line;
    Line.displayName = "Line";
    Line.defaultProps = {
      xAxisId: 0,
      yAxisId: 0,
      connectNulls: !1,
      activeDot: !0,
      dot: !0,
      legendType: "line",
      stroke: "#3182bd",
      strokeWidth: 1,
      fill: "#fff",
      points: [],
      isAnimationActive: !_Global.Global.isSsr,
      animateNewValues: !0,
      animationBegin: 0,
      animationDuration: 1500,
      animationEasing: "ease",
      hide: !1,
      label: !1
    };
    Line.getComposedData = function(_ref2) {
      var props = _ref2.props, xAxis = _ref2.xAxis, yAxis = _ref2.yAxis, xAxisTicks = _ref2.xAxisTicks, yAxisTicks = _ref2.yAxisTicks, dataKey = _ref2.dataKey, bandSize = _ref2.bandSize, displayedData = _ref2.displayedData, offset = _ref2.offset, layout = props.layout, points = displayedData.map(function(entry2, index) {
        var value = (0, _ChartUtils.getValueByDataKey)(entry2, dataKey);
        return layout === "horizontal" ? {
          x: (0, _ChartUtils.getCateCoordinateOfLine)({
            axis: xAxis,
            ticks: xAxisTicks,
            bandSize,
            entry: entry2,
            index
          }),
          y: (0, _isNil2.default)(value) ? null : yAxis.scale(value),
          value,
          payload: entry2
        } : {
          x: (0, _isNil2.default)(value) ? null : xAxis.scale(value),
          y: (0, _ChartUtils.getCateCoordinateOfLine)({
            axis: yAxis,
            ticks: yAxisTicks,
            bandSize,
            entry: entry2,
            index
          }),
          value,
          payload: entry2
        };
      });
      return _objectSpread3({
        points,
        layout
      }, offset);
    };
  }
});

// node_modules/recharts/lib/cartesian/Area.js
var require_Area = __commonJS({
  "node_modules/recharts/lib/cartesian/Area.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Area = void 0;
    var _isEqual2 = _interopRequireDefault(require("lodash/isEqual")), _isNaN2 = _interopRequireDefault(require("lodash/isNaN")), _max2 = _interopRequireDefault(require("lodash/max")), _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _get2 = _interopRequireDefault(require("lodash/get")), _isNil2 = _interopRequireDefault(require("lodash/isNil")), _isArray2 = _interopRequireDefault(require("lodash/isArray")), _react = _interopRequireWildcard(require("react")), _classnames = _interopRequireDefault(require("classnames")), _reactSmooth = _interopRequireDefault(require("react-smooth")), _Curve = require_Curve(), _Dot = require_Dot(), _Layer = require_Layer(), _LabelList = require_LabelList(), _Global = require_Global(), _DataUtils = require_DataUtils(), _ChartUtils = require_ChartUtils(), _types = require_types();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose2(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source, key) || (target[key] = source[key]));
      }
      return target;
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var Area = /* @__PURE__ */ function(_PureComponent) {
      _inherits(Area2, _PureComponent);
      var _super = _createSuper(Area2);
      function Area2() {
        var _this;
        _classCallCheck(this, Area2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        return _this = _super.call.apply(_super, [this].concat(args)), _this.state = {
          isAnimationFinished: !0
        }, _this.id = (0, _DataUtils.uniqueId)("recharts-area-"), _this.handleAnimationEnd = function() {
          var onAnimationEnd = _this.props.onAnimationEnd;
          _this.setState({
            isAnimationFinished: !0
          }), (0, _isFunction2.default)(onAnimationEnd) && onAnimationEnd();
        }, _this.handleAnimationStart = function() {
          var onAnimationStart = _this.props.onAnimationStart;
          _this.setState({
            isAnimationFinished: !1
          }), (0, _isFunction2.default)(onAnimationStart) && onAnimationStart();
        }, _this;
      }
      return _createClass(Area2, [{
        key: "renderDots",
        value: function(needClip, clipPathId) {
          var isAnimationActive = this.props.isAnimationActive, isAnimationFinished = this.state.isAnimationFinished;
          if (isAnimationActive && !isAnimationFinished)
            return null;
          var _this$props = this.props, dot = _this$props.dot, points = _this$props.points, dataKey = _this$props.dataKey, areaProps = (0, _types.filterProps)(this.props), customDotProps = (0, _types.filterProps)(dot, !0), dots = points.map(function(entry2, i) {
            var dotProps = _objectSpread3(_objectSpread3(_objectSpread3({
              key: "dot-".concat(i),
              r: 3
            }, areaProps), customDotProps), {}, {
              dataKey,
              cx: entry2.x,
              cy: entry2.y,
              index: i,
              value: entry2.value,
              payload: entry2.payload
            });
            return Area2.renderDotItem(dot, dotProps);
          }), dotsProps = {
            clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null
          };
          return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, _extends({
            className: "recharts-area-dots"
          }, dotsProps), dots);
        }
      }, {
        key: "renderHorizontalRect",
        value: function(alpha) {
          var _this$props2 = this.props, baseLine = _this$props2.baseLine, points = _this$props2.points, strokeWidth = _this$props2.strokeWidth, startX = points[0].x, endX = points[points.length - 1].x, width = alpha * Math.abs(startX - endX), maxY = (0, _max2.default)(points.map(function(entry2) {
            return entry2.y || 0;
          }));
          return (0, _DataUtils.isNumber)(baseLine) && typeof baseLine == "number" ? maxY = Math.max(baseLine, maxY) : baseLine && (0, _isArray2.default)(baseLine) && baseLine.length && (maxY = Math.max((0, _max2.default)(baseLine.map(function(entry2) {
            return entry2.y || 0;
          })), maxY)), (0, _DataUtils.isNumber)(maxY) ? /* @__PURE__ */ _react.default.createElement("rect", {
            x: startX < endX ? startX : startX - width,
            y: 0,
            width,
            height: Math.floor(maxY + (strokeWidth ? parseInt("".concat(strokeWidth), 10) : 1))
          }) : null;
        }
      }, {
        key: "renderVerticalRect",
        value: function(alpha) {
          var _this$props3 = this.props, baseLine = _this$props3.baseLine, points = _this$props3.points, strokeWidth = _this$props3.strokeWidth, startY = points[0].y, endY = points[points.length - 1].y, height = alpha * Math.abs(startY - endY), maxX = (0, _max2.default)(points.map(function(entry2) {
            return entry2.x || 0;
          }));
          return (0, _DataUtils.isNumber)(baseLine) && typeof baseLine == "number" ? maxX = Math.max(baseLine, maxX) : baseLine && (0, _isArray2.default)(baseLine) && baseLine.length && (maxX = Math.max((0, _max2.default)(baseLine.map(function(entry2) {
            return entry2.x || 0;
          })), maxX)), (0, _DataUtils.isNumber)(maxX) ? /* @__PURE__ */ _react.default.createElement("rect", {
            x: 0,
            y: startY < endY ? startY : startY - height,
            width: maxX + (strokeWidth ? parseInt("".concat(strokeWidth), 10) : 1),
            height: Math.floor(height)
          }) : null;
        }
      }, {
        key: "renderClipRect",
        value: function(alpha) {
          var layout = this.props.layout;
          return layout === "vertical" ? this.renderVerticalRect(alpha) : this.renderHorizontalRect(alpha);
        }
      }, {
        key: "renderAreaStatically",
        value: function(points, baseLine, needClip, clipPathId) {
          var _this$props4 = this.props, layout = _this$props4.layout, type = _this$props4.type, stroke = _this$props4.stroke, connectNulls = _this$props4.connectNulls, isRange = _this$props4.isRange, ref = _this$props4.ref, others = _objectWithoutProperties2(_this$props4, ["layout", "type", "stroke", "connectNulls", "isRange", "ref"]);
          return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null
          }, /* @__PURE__ */ _react.default.createElement(_Curve.Curve, _extends({}, (0, _types.filterProps)(others, !0), {
            points,
            connectNulls,
            type,
            baseLine,
            layout,
            stroke: "none",
            className: "recharts-area-area"
          })), stroke !== "none" && /* @__PURE__ */ _react.default.createElement(_Curve.Curve, _extends({}, (0, _types.filterProps)(this.props), {
            className: "recharts-area-curve",
            layout,
            type,
            connectNulls,
            fill: "none",
            points
          })), stroke !== "none" && isRange && /* @__PURE__ */ _react.default.createElement(_Curve.Curve, _extends({}, (0, _types.filterProps)(this.props), {
            className: "recharts-area-curve",
            layout,
            type,
            connectNulls,
            fill: "none",
            points: baseLine
          })));
        }
      }, {
        key: "renderAreaWithAnimation",
        value: function(needClip, clipPathId) {
          var _this2 = this, _this$props5 = this.props, points = _this$props5.points, baseLine = _this$props5.baseLine, isAnimationActive = _this$props5.isAnimationActive, animationBegin = _this$props5.animationBegin, animationDuration = _this$props5.animationDuration, animationEasing = _this$props5.animationEasing, animationId = _this$props5.animationId, _this$state = this.state, prevPoints = _this$state.prevPoints, prevBaseLine = _this$state.prevBaseLine;
          return /* @__PURE__ */ _react.default.createElement(_reactSmooth.default, {
            begin: animationBegin,
            duration: animationDuration,
            isActive: isAnimationActive,
            easing: animationEasing,
            from: {
              t: 0
            },
            to: {
              t: 1
            },
            key: "area-".concat(animationId),
            onAnimationEnd: this.handleAnimationEnd,
            onAnimationStart: this.handleAnimationStart
          }, function(_ref) {
            var t = _ref.t;
            if (prevPoints) {
              var prevPointsDiffFactor = prevPoints.length / points.length, stepPoints = points.map(function(entry2, index) {
                var prevPointIndex = Math.floor(index * prevPointsDiffFactor);
                if (prevPoints[prevPointIndex]) {
                  var prev = prevPoints[prevPointIndex], interpolatorX = (0, _DataUtils.interpolateNumber)(prev.x, entry2.x), interpolatorY = (0, _DataUtils.interpolateNumber)(prev.y, entry2.y);
                  return _objectSpread3(_objectSpread3({}, entry2), {}, {
                    x: interpolatorX(t),
                    y: interpolatorY(t)
                  });
                }
                return entry2;
              }), stepBaseLine;
              if ((0, _DataUtils.isNumber)(baseLine) && typeof baseLine == "number") {
                var interpolator = (0, _DataUtils.interpolateNumber)(prevBaseLine, baseLine);
                stepBaseLine = interpolator(t);
              } else if ((0, _isNil2.default)(baseLine) || (0, _isNaN2.default)(baseLine)) {
                var _interpolator = (0, _DataUtils.interpolateNumber)(prevBaseLine, 0);
                stepBaseLine = _interpolator(t);
              } else
                stepBaseLine = baseLine.map(function(entry2, index) {
                  var prevPointIndex = Math.floor(index * prevPointsDiffFactor);
                  if (prevBaseLine[prevPointIndex]) {
                    var prev = prevBaseLine[prevPointIndex], interpolatorX = (0, _DataUtils.interpolateNumber)(prev.x, entry2.x), interpolatorY = (0, _DataUtils.interpolateNumber)(prev.y, entry2.y);
                    return _objectSpread3(_objectSpread3({}, entry2), {}, {
                      x: interpolatorX(t),
                      y: interpolatorY(t)
                    });
                  }
                  return entry2;
                });
              return _this2.renderAreaStatically(stepPoints, stepBaseLine, needClip, clipPathId);
            }
            return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, null, /* @__PURE__ */ _react.default.createElement("defs", null, /* @__PURE__ */ _react.default.createElement("clipPath", {
              id: "animationClipPath-".concat(clipPathId)
            }, _this2.renderClipRect(t))), /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
              clipPath: "url(#animationClipPath-".concat(clipPathId, ")")
            }, _this2.renderAreaStatically(points, baseLine, needClip, clipPathId)));
          });
        }
      }, {
        key: "renderArea",
        value: function(needClip, clipPathId) {
          var _this$props6 = this.props, points = _this$props6.points, baseLine = _this$props6.baseLine, isAnimationActive = _this$props6.isAnimationActive, _this$state2 = this.state, prevPoints = _this$state2.prevPoints, prevBaseLine = _this$state2.prevBaseLine, totalLength = _this$state2.totalLength;
          return isAnimationActive && points && points.length && (!prevPoints && totalLength > 0 || !(0, _isEqual2.default)(prevPoints, points) || !(0, _isEqual2.default)(prevBaseLine, baseLine)) ? this.renderAreaWithAnimation(needClip, clipPathId) : this.renderAreaStatically(points, baseLine, needClip, clipPathId);
        }
      }, {
        key: "render",
        value: function() {
          var _this$props7 = this.props, hide = _this$props7.hide, dot = _this$props7.dot, points = _this$props7.points, className = _this$props7.className, top = _this$props7.top, left = _this$props7.left, xAxis = _this$props7.xAxis, yAxis = _this$props7.yAxis, width = _this$props7.width, height = _this$props7.height, isAnimationActive = _this$props7.isAnimationActive, id = _this$props7.id;
          if (hide || !points || !points.length)
            return null;
          var isAnimationFinished = this.state.isAnimationFinished, hasSinglePoint = points.length === 1, layerClass = (0, _classnames.default)("recharts-area", className), needClip = xAxis && xAxis.allowDataOverflow || yAxis && yAxis.allowDataOverflow, clipPathId = (0, _isNil2.default)(id) ? this.id : id;
          return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: layerClass
          }, needClip ? /* @__PURE__ */ _react.default.createElement("defs", null, /* @__PURE__ */ _react.default.createElement("clipPath", {
            id: "clipPath-".concat(clipPathId)
          }, /* @__PURE__ */ _react.default.createElement("rect", {
            x: left,
            y: top,
            width,
            height: Math.floor(height)
          }))) : null, hasSinglePoint ? null : this.renderArea(needClip, clipPathId), (dot || hasSinglePoint) && this.renderDots(needClip, clipPathId), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(this.props, points));
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function(nextProps, prevState) {
          return nextProps.animationId !== prevState.prevAnimationId ? {
            prevAnimationId: nextProps.animationId,
            curPoints: nextProps.points,
            curBaseLine: nextProps.baseLine,
            prevPoints: prevState.curPoints,
            prevBaseLine: prevState.curBaseLine
          } : nextProps.points !== prevState.curPoints || nextProps.baseLine !== prevState.curBaseLine ? {
            curPoints: nextProps.points,
            curBaseLine: nextProps.baseLine
          } : null;
        }
      }]), Area2;
    }(_react.PureComponent);
    exports.Area = Area;
    Area.displayName = "Area";
    Area.defaultProps = {
      stroke: "#3182bd",
      fill: "#3182bd",
      fillOpacity: 0.6,
      xAxisId: 0,
      yAxisId: 0,
      legendType: "line",
      connectNulls: !1,
      points: [],
      dot: !1,
      activeDot: !0,
      hide: !1,
      isAnimationActive: !_Global.Global.isSsr,
      animationBegin: 0,
      animationDuration: 1500,
      animationEasing: "ease"
    };
    Area.getBaseValue = function(props, item, xAxis, yAxis) {
      var layout = props.layout, baseValue = item.props.baseValue;
      if ((0, _DataUtils.isNumber)(baseValue) && typeof baseValue == "number")
        return baseValue;
      var numericAxis = layout === "horizontal" ? yAxis : xAxis, domain = numericAxis.scale.domain();
      if (numericAxis.type === "number") {
        var max = Math.max(domain[0], domain[1]), min = Math.min(domain[0], domain[1]);
        return baseValue === "dataMin" ? min : baseValue === "dataMax" || max < 0 ? max : Math.max(Math.min(domain[0], domain[1]), 0);
      }
      return baseValue === "dataMin" ? domain[0] : baseValue === "dataMax" ? domain[1] : domain[0];
    };
    Area.getComposedData = function(_ref2) {
      var props = _ref2.props, item = _ref2.item, xAxis = _ref2.xAxis, yAxis = _ref2.yAxis, xAxisTicks = _ref2.xAxisTicks, yAxisTicks = _ref2.yAxisTicks, bandSize = _ref2.bandSize, dataKey = _ref2.dataKey, stackedData = _ref2.stackedData, dataStartIndex = _ref2.dataStartIndex, displayedData = _ref2.displayedData, offset = _ref2.offset, layout = props.layout, hasStack = stackedData && stackedData.length, baseValue = Area.getBaseValue(props, item, xAxis, yAxis), isRange = !1, points = displayedData.map(function(entry2, index) {
        var originalValue = (0, _ChartUtils.getValueByDataKey)(entry2, dataKey), value;
        hasStack ? value = stackedData[dataStartIndex + index] : (value = originalValue, (0, _isArray2.default)(value) ? isRange = !0 : value = [baseValue, value]);
        var isBreakPoint = (0, _isNil2.default)(value[1]) || hasStack && (0, _isNil2.default)(originalValue);
        return layout === "horizontal" ? {
          x: (0, _ChartUtils.getCateCoordinateOfLine)({
            axis: xAxis,
            ticks: xAxisTicks,
            bandSize,
            entry: entry2,
            index
          }),
          y: isBreakPoint ? null : yAxis.scale(value[1]),
          value,
          payload: entry2
        } : {
          x: isBreakPoint ? null : xAxis.scale(value[1]),
          y: (0, _ChartUtils.getCateCoordinateOfLine)({
            axis: yAxis,
            ticks: yAxisTicks,
            bandSize,
            entry: entry2,
            index
          }),
          value,
          payload: entry2
        };
      }), baseLine;
      return hasStack || isRange ? baseLine = points.map(function(entry2) {
        return layout === "horizontal" ? {
          x: entry2.x,
          y: !(0, _isNil2.default)((0, _get2.default)(entry2, "value[0]")) && !(0, _isNil2.default)((0, _get2.default)(entry2, "y")) ? yAxis.scale((0, _get2.default)(entry2, "value[0]")) : null
        } : {
          x: (0, _isNil2.default)((0, _get2.default)(entry2, "value[0]")) ? null : xAxis.scale((0, _get2.default)(entry2, "value[0]")),
          y: entry2.y
        };
      }) : layout === "horizontal" ? baseLine = yAxis.scale(baseValue) : baseLine = xAxis.scale(baseValue), _objectSpread3({
        points,
        baseLine,
        layout,
        isRange
      }, offset);
    };
    Area.renderDotItem = function(option, props) {
      var dotItem;
      return /* @__PURE__ */ _react.default.isValidElement(option) ? dotItem = /* @__PURE__ */ _react.default.cloneElement(option, props) : (0, _isFunction2.default)(option) ? dotItem = option(props) : dotItem = /* @__PURE__ */ _react.default.createElement(_Dot.Dot, _extends({}, props, {
        className: "recharts-area-dot"
      })), dotItem;
    };
  }
});

// node_modules/recharts/lib/cartesian/Bar.js
var require_Bar = __commonJS({
  "node_modules/recharts/lib/cartesian/Bar.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Bar = void 0;
    var _isNil2 = _interopRequireDefault(require("lodash/isNil")), _isEqual2 = _interopRequireDefault(require("lodash/isEqual")), _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _isArray2 = _interopRequireDefault(require("lodash/isArray")), _react = _interopRequireWildcard(require("react")), _classnames = _interopRequireDefault(require("classnames")), _reactSmooth = _interopRequireDefault(require("react-smooth")), _Rectangle = require_Rectangle(), _Layer = require_Layer(), _ErrorBar = require_ErrorBar(), _Cell = require_Cell(), _LabelList = require_LabelList(), _DataUtils = require_DataUtils(), _ReactUtils = require_ReactUtils(), _Global = require_Global(), _ChartUtils = require_ChartUtils(), _types = require_types();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose2(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source, key) || (target[key] = source[key]));
      }
      return target;
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var Bar = /* @__PURE__ */ function(_PureComponent) {
      _inherits(Bar2, _PureComponent);
      var _super = _createSuper(Bar2);
      function Bar2() {
        var _this;
        _classCallCheck(this, Bar2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        return _this = _super.call.apply(_super, [this].concat(args)), _this.state = {
          isAnimationFinished: !1
        }, _this.id = (0, _DataUtils.uniqueId)("recharts-bar-"), _this.handleAnimationEnd = function() {
          var onAnimationEnd = _this.props.onAnimationEnd;
          _this.setState({
            isAnimationFinished: !0
          }), onAnimationEnd && onAnimationEnd();
        }, _this.handleAnimationStart = function() {
          var onAnimationStart = _this.props.onAnimationStart;
          _this.setState({
            isAnimationFinished: !1
          }), onAnimationStart && onAnimationStart();
        }, _this;
      }
      return _createClass(Bar2, [{
        key: "renderRectanglesStatically",
        value: function(data) {
          var _this2 = this, shape = this.props.shape, baseProps = (0, _types.filterProps)(this.props);
          return data && data.map(function(entry2, i) {
            var props = _objectSpread3(_objectSpread3(_objectSpread3({}, baseProps), entry2), {}, {
              index: i
            });
            return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, _extends({
              className: "recharts-bar-rectangle"
            }, (0, _types.adaptEventsOfChild)(_this2.props, entry2, i), {
              key: "rectangle-".concat(i),
              role: "img"
            }), Bar2.renderRectangle(shape, props));
          });
        }
      }, {
        key: "renderRectanglesWithAnimation",
        value: function() {
          var _this3 = this, _this$props = this.props, data = _this$props.data, layout = _this$props.layout, isAnimationActive = _this$props.isAnimationActive, animationBegin = _this$props.animationBegin, animationDuration = _this$props.animationDuration, animationEasing = _this$props.animationEasing, animationId = _this$props.animationId, prevData = this.state.prevData;
          return /* @__PURE__ */ _react.default.createElement(_reactSmooth.default, {
            begin: animationBegin,
            duration: animationDuration,
            isActive: isAnimationActive,
            easing: animationEasing,
            from: {
              t: 0
            },
            to: {
              t: 1
            },
            key: "bar-".concat(animationId),
            onAnimationEnd: this.handleAnimationEnd,
            onAnimationStart: this.handleAnimationStart
          }, function(_ref) {
            var t = _ref.t, stepData = data.map(function(entry2, index) {
              var prev = prevData && prevData[index];
              if (prev) {
                var interpolatorX = (0, _DataUtils.interpolateNumber)(prev.x, entry2.x), interpolatorY = (0, _DataUtils.interpolateNumber)(prev.y, entry2.y), interpolatorWidth = (0, _DataUtils.interpolateNumber)(prev.width, entry2.width), interpolatorHeight = (0, _DataUtils.interpolateNumber)(prev.height, entry2.height);
                return _objectSpread3(_objectSpread3({}, entry2), {}, {
                  x: interpolatorX(t),
                  y: interpolatorY(t),
                  width: interpolatorWidth(t),
                  height: interpolatorHeight(t)
                });
              }
              if (layout === "horizontal") {
                var _interpolatorHeight = (0, _DataUtils.interpolateNumber)(0, entry2.height), h = _interpolatorHeight(t);
                return _objectSpread3(_objectSpread3({}, entry2), {}, {
                  y: entry2.y + entry2.height - h,
                  height: h
                });
              }
              var interpolator = (0, _DataUtils.interpolateNumber)(0, entry2.width), w = interpolator(t);
              return _objectSpread3(_objectSpread3({}, entry2), {}, {
                width: w
              });
            });
            return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, null, _this3.renderRectanglesStatically(stepData));
          });
        }
      }, {
        key: "renderRectangles",
        value: function() {
          var _this$props2 = this.props, data = _this$props2.data, isAnimationActive = _this$props2.isAnimationActive, prevData = this.state.prevData;
          return isAnimationActive && data && data.length && (!prevData || !(0, _isEqual2.default)(prevData, data)) ? this.renderRectanglesWithAnimation() : this.renderRectanglesStatically(data);
        }
      }, {
        key: "renderBackground",
        value: function() {
          var _this4 = this, data = this.props.data, backgroundProps = (0, _types.filterProps)(this.props.background);
          return data.map(function(entry2, i) {
            var value = entry2.value, background = entry2.background, rest = _objectWithoutProperties2(entry2, ["value", "background"]);
            if (!background)
              return null;
            var props = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({}, rest), {}, {
              fill: "#eee"
            }, background), backgroundProps), (0, _types.adaptEventsOfChild)(_this4.props, entry2, i)), {}, {
              index: i,
              key: "background-bar-".concat(i),
              className: "recharts-bar-background-rectangle"
            });
            return Bar2.renderRectangle(_this4.props.background, props);
          });
        }
      }, {
        key: "renderErrorBar",
        value: function() {
          if (this.props.isAnimationActive && !this.state.isAnimationFinished)
            return null;
          var _this$props3 = this.props, data = _this$props3.data, xAxis = _this$props3.xAxis, yAxis = _this$props3.yAxis, layout = _this$props3.layout, children = _this$props3.children, errorBarItems = (0, _ReactUtils.findAllByType)(children, _ErrorBar.ErrorBar.displayName);
          if (!errorBarItems)
            return null;
          var offset = layout === "vertical" ? data[0].height / 2 : data[0].width / 2;
          function dataPointFormatter(dataPoint, dataKey) {
            return {
              x: dataPoint.x,
              y: dataPoint.y,
              value: dataPoint.value,
              errorVal: (0, _ChartUtils.getValueByDataKey)(dataPoint, dataKey)
            };
          }
          return errorBarItems.map(function(item, i) {
            return /* @__PURE__ */ _react.default.cloneElement(item, {
              key: "error-bar-".concat(i),
              data,
              xAxis,
              yAxis,
              layout,
              offset,
              dataPointFormatter
            });
          });
        }
      }, {
        key: "render",
        value: function() {
          var _this$props4 = this.props, hide = _this$props4.hide, data = _this$props4.data, className = _this$props4.className, xAxis = _this$props4.xAxis, yAxis = _this$props4.yAxis, left = _this$props4.left, top = _this$props4.top, width = _this$props4.width, height = _this$props4.height, isAnimationActive = _this$props4.isAnimationActive, background = _this$props4.background, id = _this$props4.id;
          if (hide || !data || !data.length)
            return null;
          var isAnimationFinished = this.state.isAnimationFinished, layerClass = (0, _classnames.default)("recharts-bar", className), needClip = xAxis && xAxis.allowDataOverflow || yAxis && yAxis.allowDataOverflow, clipPathId = (0, _isNil2.default)(id) ? this.id : id;
          return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: layerClass
          }, needClip ? /* @__PURE__ */ _react.default.createElement("defs", null, /* @__PURE__ */ _react.default.createElement("clipPath", {
            id: "clipPath-".concat(clipPathId)
          }, /* @__PURE__ */ _react.default.createElement("rect", {
            x: left,
            y: top,
            width,
            height
          }))) : null, /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: "recharts-bar-rectangles",
            clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null
          }, background ? this.renderBackground() : null, this.renderRectangles()), this.renderErrorBar(), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(this.props, data));
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function(nextProps, prevState) {
          return nextProps.animationId !== prevState.prevAnimationId ? {
            prevAnimationId: nextProps.animationId,
            curData: nextProps.data,
            prevData: prevState.curData
          } : nextProps.data !== prevState.curData ? {
            curData: nextProps.data
          } : null;
        }
      }, {
        key: "renderRectangle",
        value: function(option, props) {
          var rectangle;
          return /* @__PURE__ */ _react.default.isValidElement(option) ? rectangle = /* @__PURE__ */ _react.default.cloneElement(option, props) : (0, _isFunction2.default)(option) ? rectangle = option(props) : rectangle = /* @__PURE__ */ _react.default.createElement(_Rectangle.Rectangle, props), rectangle;
        }
      }]), Bar2;
    }(_react.PureComponent);
    exports.Bar = Bar;
    Bar.displayName = "Bar";
    Bar.defaultProps = {
      xAxisId: 0,
      yAxisId: 0,
      legendType: "rect",
      minPointSize: 0,
      hide: !1,
      data: [],
      layout: "vertical",
      isAnimationActive: !_Global.Global.isSsr,
      animationBegin: 0,
      animationDuration: 400,
      animationEasing: "ease"
    };
    Bar.getComposedData = function(_ref2) {
      var props = _ref2.props, item = _ref2.item, barPosition = _ref2.barPosition, bandSize = _ref2.bandSize, xAxis = _ref2.xAxis, yAxis = _ref2.yAxis, xAxisTicks = _ref2.xAxisTicks, yAxisTicks = _ref2.yAxisTicks, stackedData = _ref2.stackedData, dataStartIndex = _ref2.dataStartIndex, displayedData = _ref2.displayedData, offset = _ref2.offset, pos = (0, _ChartUtils.findPositionOfBar)(barPosition, item);
      if (!pos)
        return null;
      var layout = props.layout, _item$props = item.props, dataKey = _item$props.dataKey, children = _item$props.children, minPointSize = _item$props.minPointSize, numericAxis = layout === "horizontal" ? yAxis : xAxis, stackedDomain = stackedData ? numericAxis.scale.domain() : null, baseValue = (0, _ChartUtils.getBaseValueOfBar)({
        numericAxis
      }), cells = (0, _ReactUtils.findAllByType)(children, _Cell.Cell.displayName), rects = displayedData.map(function(entry2, index) {
        var value, x, y, width, height, background;
        if (stackedData ? value = (0, _ChartUtils.truncateByDomain)(stackedData[dataStartIndex + index], stackedDomain) : (value = (0, _ChartUtils.getValueByDataKey)(entry2, dataKey), (0, _isArray2.default)(value) || (value = [baseValue, value])), layout === "horizontal") {
          if (x = (0, _ChartUtils.getCateCoordinateOfBar)({
            axis: xAxis,
            ticks: xAxisTicks,
            bandSize,
            offset: pos.offset,
            entry: entry2,
            index
          }), y = yAxis.scale(value[1]), width = pos.size, height = yAxis.scale(value[0]) - yAxis.scale(value[1]), background = {
            x,
            y: yAxis.y,
            width,
            height: yAxis.height
          }, Math.abs(minPointSize) > 0 && Math.abs(height) < Math.abs(minPointSize)) {
            var delta = (0, _DataUtils.mathSign)(height || minPointSize) * (Math.abs(minPointSize) - Math.abs(height));
            y -= delta, height += delta;
          }
        } else if (x = xAxis.scale(value[0]), y = (0, _ChartUtils.getCateCoordinateOfBar)({
          axis: yAxis,
          ticks: yAxisTicks,
          bandSize,
          offset: pos.offset,
          entry: entry2,
          index
        }), width = xAxis.scale(value[1]) - xAxis.scale(value[0]), height = pos.size, background = {
          x: xAxis.x,
          y,
          width: xAxis.width,
          height
        }, Math.abs(minPointSize) > 0 && Math.abs(width) < Math.abs(minPointSize)) {
          var _delta = (0, _DataUtils.mathSign)(width || minPointSize) * (Math.abs(minPointSize) - Math.abs(width));
          width += _delta;
        }
        return _objectSpread3(_objectSpread3(_objectSpread3({}, entry2), {}, {
          x,
          y,
          width,
          height,
          value: stackedData ? value : value[1],
          payload: entry2,
          background
        }, cells && cells[index] && cells[index].props), {}, {
          tooltipPayload: [(0, _ChartUtils.getTooltipItem)(item, entry2)],
          tooltipPosition: {
            x: x + width / 2,
            y: y + height / 2
          }
        });
      });
      return _objectSpread3({
        data: rects,
        layout
      }, offset);
    };
  }
});

// node_modules/recharts/lib/cartesian/ZAxis.js
var require_ZAxis = __commonJS({
  "node_modules/recharts/lib/cartesian/ZAxis.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.ZAxis = void 0;
    var ZAxis = function() {
      return null;
    };
    exports.ZAxis = ZAxis;
    ZAxis.displayName = "ZAxis";
    ZAxis.defaultProps = {
      zAxisId: 0,
      range: [64, 64],
      scale: "auto",
      type: "number"
    };
  }
});

// node_modules/recharts/lib/cartesian/Scatter.js
var require_Scatter = __commonJS({
  "node_modules/recharts/lib/cartesian/Scatter.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Scatter = void 0;
    var _isEqual2 = _interopRequireDefault(require("lodash/isEqual")), _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _isNil2 = _interopRequireDefault(require("lodash/isNil")), _react = _interopRequireWildcard(require("react")), _reactSmooth = _interopRequireDefault(require("react-smooth")), _classnames = _interopRequireDefault(require("classnames")), _Layer = require_Layer(), _LabelList = require_LabelList(), _ReactUtils = require_ReactUtils(), _Global = require_Global(), _ZAxis = require_ZAxis(), _Curve = require_Curve(), _Symbols = require_Symbols(), _ErrorBar = require_ErrorBar(), _Cell = require_Cell(), _DataUtils = require_DataUtils(), _ChartUtils = require_ChartUtils(), _types = require_types();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var Scatter = /* @__PURE__ */ function(_PureComponent) {
      _inherits(Scatter2, _PureComponent);
      var _super = _createSuper(Scatter2);
      function Scatter2() {
        var _this;
        _classCallCheck(this, Scatter2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        return _this = _super.call.apply(_super, [this].concat(args)), _this.state = {
          isAnimationFinished: !1
        }, _this.handleAnimationEnd = function() {
          _this.setState({
            isAnimationFinished: !0
          });
        }, _this.handleAnimationStart = function() {
          _this.setState({
            isAnimationFinished: !1
          });
        }, _this.id = (0, _DataUtils.uniqueId)("recharts-scatter-"), _this;
      }
      return _createClass(Scatter2, [{
        key: "renderSymbolsStatically",
        value: function(points) {
          var _this2 = this, _this$props = this.props, shape = _this$props.shape, activeShape = _this$props.activeShape, activeIndex = _this$props.activeIndex, baseProps = (0, _types.filterProps)(this.props);
          return points.map(function(entry2, i) {
            var props = _objectSpread3(_objectSpread3({
              key: "symbol-".concat(i)
            }, baseProps), entry2);
            return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, _extends({
              className: "recharts-scatter-symbol"
            }, (0, _types.adaptEventsOfChild)(_this2.props, entry2, i), {
              key: "symbol-".concat(i),
              role: "img"
            }), Scatter2.renderSymbolItem(activeIndex === i ? activeShape : shape, props));
          });
        }
      }, {
        key: "renderSymbolsWithAnimation",
        value: function() {
          var _this3 = this, _this$props2 = this.props, points = _this$props2.points, isAnimationActive = _this$props2.isAnimationActive, animationBegin = _this$props2.animationBegin, animationDuration = _this$props2.animationDuration, animationEasing = _this$props2.animationEasing, animationId = _this$props2.animationId, prevPoints = this.state.prevPoints;
          return /* @__PURE__ */ _react.default.createElement(_reactSmooth.default, {
            begin: animationBegin,
            duration: animationDuration,
            isActive: isAnimationActive,
            easing: animationEasing,
            from: {
              t: 0
            },
            to: {
              t: 1
            },
            key: "pie-".concat(animationId),
            onAnimationEnd: this.handleAnimationEnd,
            onAnimationStart: this.handleAnimationStart
          }, function(_ref) {
            var t = _ref.t, stepData = points.map(function(entry2, index) {
              var prev = prevPoints && prevPoints[index];
              if (prev) {
                var interpolatorCx = (0, _DataUtils.interpolateNumber)(prev.cx, entry2.cx), interpolatorCy = (0, _DataUtils.interpolateNumber)(prev.cy, entry2.cy), interpolatorSize = (0, _DataUtils.interpolateNumber)(prev.size, entry2.size);
                return _objectSpread3(_objectSpread3({}, entry2), {}, {
                  cx: interpolatorCx(t),
                  cy: interpolatorCy(t),
                  size: interpolatorSize(t)
                });
              }
              var interpolator = (0, _DataUtils.interpolateNumber)(0, entry2.size);
              return _objectSpread3(_objectSpread3({}, entry2), {}, {
                size: interpolator(t)
              });
            });
            return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, null, _this3.renderSymbolsStatically(stepData));
          });
        }
      }, {
        key: "renderSymbols",
        value: function() {
          var _this$props3 = this.props, points = _this$props3.points, isAnimationActive = _this$props3.isAnimationActive, prevPoints = this.state.prevPoints;
          return isAnimationActive && points && points.length && (!prevPoints || !(0, _isEqual2.default)(prevPoints, points)) ? this.renderSymbolsWithAnimation() : this.renderSymbolsStatically(points);
        }
      }, {
        key: "renderErrorBar",
        value: function() {
          var isAnimationActive = this.props.isAnimationActive;
          if (isAnimationActive && !this.state.isAnimationFinished)
            return null;
          var _this$props4 = this.props, points = _this$props4.points, xAxis = _this$props4.xAxis, yAxis = _this$props4.yAxis, children = _this$props4.children, errorBarItems = (0, _ReactUtils.findAllByType)(children, _ErrorBar.ErrorBar.displayName);
          if (!errorBarItems)
            return null;
          function dataPointFormatterY(dataPoint, dataKey) {
            return {
              x: dataPoint.cx,
              y: dataPoint.cy,
              value: +dataPoint.node.y,
              errorVal: (0, _ChartUtils.getValueByDataKey)(dataPoint, dataKey)
            };
          }
          function dataPointFormatterX(dataPoint, dataKey) {
            return {
              x: dataPoint.cx,
              y: dataPoint.cy,
              value: +dataPoint.node.x,
              errorVal: (0, _ChartUtils.getValueByDataKey)(dataPoint, dataKey)
            };
          }
          return errorBarItems.map(function(item, i) {
            var direction = item.props.direction;
            return /* @__PURE__ */ _react.default.cloneElement(item, {
              key: i,
              data: points,
              xAxis,
              yAxis,
              layout: direction === "x" ? "vertical" : "horizontal",
              dataPointFormatter: direction === "x" ? dataPointFormatterX : dataPointFormatterY
            });
          });
        }
      }, {
        key: "renderLine",
        value: function() {
          var _this$props5 = this.props, points = _this$props5.points, line = _this$props5.line, lineType = _this$props5.lineType, lineJointType = _this$props5.lineJointType, scatterProps = (0, _types.filterProps)(this.props), customLineProps = (0, _types.filterProps)(line), linePoints, lineItem;
          if (lineType === "joint")
            linePoints = points.map(function(entry2) {
              return {
                x: entry2.cx,
                y: entry2.cy
              };
            });
          else if (lineType === "fitting") {
            var _getLinearRegression = (0, _DataUtils.getLinearRegression)(points), xmin = _getLinearRegression.xmin, xmax = _getLinearRegression.xmax, a = _getLinearRegression.a, b = _getLinearRegression.b, linearExp = function(x) {
              return a * x + b;
            };
            linePoints = [{
              x: xmin,
              y: linearExp(xmin)
            }, {
              x: xmax,
              y: linearExp(xmax)
            }];
          }
          var lineProps = _objectSpread3(_objectSpread3(_objectSpread3({}, scatterProps), {}, {
            fill: "none",
            stroke: scatterProps && scatterProps.fill
          }, customLineProps), {}, {
            points: linePoints
          });
          return /* @__PURE__ */ _react.default.isValidElement(line) ? lineItem = /* @__PURE__ */ _react.default.cloneElement(line, lineProps) : (0, _isFunction2.default)(line) ? lineItem = line(lineProps) : lineItem = /* @__PURE__ */ _react.default.createElement(_Curve.Curve, _extends({}, lineProps, {
            type: lineJointType
          })), /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: "recharts-scatter-line",
            key: "recharts-scatter-line"
          }, lineItem);
        }
      }, {
        key: "render",
        value: function() {
          var _this$props6 = this.props, hide = _this$props6.hide, points = _this$props6.points, line = _this$props6.line, className = _this$props6.className, xAxis = _this$props6.xAxis, yAxis = _this$props6.yAxis, left = _this$props6.left, top = _this$props6.top, width = _this$props6.width, height = _this$props6.height, id = _this$props6.id, isAnimationActive = _this$props6.isAnimationActive;
          if (hide || !points || !points.length)
            return null;
          var isAnimationFinished = this.state.isAnimationFinished, layerClass = (0, _classnames.default)("recharts-scatter", className), needClip = xAxis && xAxis.allowDataOverflow || yAxis && yAxis.allowDataOverflow, clipPathId = (0, _isNil2.default)(id) ? this.id : id;
          return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: layerClass,
            clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null
          }, needClip ? /* @__PURE__ */ _react.default.createElement("defs", null, /* @__PURE__ */ _react.default.createElement("clipPath", {
            id: "clipPath-".concat(clipPathId)
          }, /* @__PURE__ */ _react.default.createElement("rect", {
            x: left,
            y: top,
            width,
            height
          }))) : null, line && this.renderLine(), this.renderErrorBar(), /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            key: "recharts-scatter-symbols"
          }, this.renderSymbols()), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(this.props, points));
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function(nextProps, prevState) {
          return nextProps.animationId !== prevState.prevAnimationId ? {
            prevAnimationId: nextProps.animationId,
            curPoints: nextProps.points,
            prevPoints: prevState.curPoints
          } : nextProps.points !== prevState.curPoints ? {
            curPoints: nextProps.points
          } : null;
        }
      }, {
        key: "renderSymbolItem",
        value: function(option, props) {
          var symbol;
          return /* @__PURE__ */ _react.default.isValidElement(option) ? symbol = /* @__PURE__ */ _react.default.cloneElement(option, props) : (0, _isFunction2.default)(option) ? symbol = option(props) : typeof option == "string" && (symbol = /* @__PURE__ */ _react.default.createElement(_Symbols.Symbols, _extends({}, props, {
            type: option
          }))), symbol;
        }
      }]), Scatter2;
    }(_react.PureComponent);
    exports.Scatter = Scatter;
    Scatter.displayName = "Scatter";
    Scatter.defaultProps = {
      xAxisId: 0,
      yAxisId: 0,
      zAxisId: 0,
      legendType: "circle",
      lineType: "joint",
      lineJointType: "linear",
      data: [],
      shape: "circle",
      hide: !1,
      isAnimationActive: !_Global.Global.isSsr,
      animationBegin: 0,
      animationDuration: 400,
      animationEasing: "linear"
    };
    Scatter.getComposedData = function(_ref2) {
      var xAxis = _ref2.xAxis, yAxis = _ref2.yAxis, zAxis = _ref2.zAxis, item = _ref2.item, displayedData = _ref2.displayedData, xAxisTicks = _ref2.xAxisTicks, yAxisTicks = _ref2.yAxisTicks, offset = _ref2.offset, tooltipType = item.props.tooltipType, cells = (0, _ReactUtils.findAllByType)(item.props.children, _Cell.Cell.displayName), xAxisDataKey = (0, _isNil2.default)(xAxis.dataKey) ? item.props.dataKey : xAxis.dataKey, yAxisDataKey = (0, _isNil2.default)(yAxis.dataKey) ? item.props.dataKey : yAxis.dataKey, zAxisDataKey = zAxis && zAxis.dataKey, defaultRangeZ = zAxis ? zAxis.range : _ZAxis.ZAxis.defaultProps.range, defaultZ = defaultRangeZ && defaultRangeZ[0], xBandSize = xAxis.scale.bandwidth ? xAxis.scale.bandwidth() : 0, yBandSize = yAxis.scale.bandwidth ? yAxis.scale.bandwidth() : 0, points = displayedData.map(function(entry2, index) {
        var x = (0, _ChartUtils.getValueByDataKey)(entry2, xAxisDataKey), y = (0, _ChartUtils.getValueByDataKey)(entry2, yAxisDataKey), z = !(0, _isNil2.default)(zAxisDataKey) && (0, _ChartUtils.getValueByDataKey)(entry2, zAxisDataKey) || "-", tooltipPayload = [{
          name: (0, _isNil2.default)(xAxis.dataKey) ? item.props.name : xAxis.name || xAxis.dataKey,
          unit: xAxis.unit || "",
          value: x,
          payload: entry2,
          dataKey: xAxisDataKey,
          type: tooltipType
        }, {
          name: (0, _isNil2.default)(yAxis.dataKey) ? item.props.name : yAxis.name || yAxis.dataKey,
          unit: yAxis.unit || "",
          value: y,
          payload: entry2,
          dataKey: yAxisDataKey,
          type: tooltipType
        }];
        z !== "-" && tooltipPayload.push({
          name: zAxis.name || zAxis.dataKey,
          unit: zAxis.unit || "",
          value: z,
          payload: entry2,
          dataKey: zAxisDataKey,
          type: tooltipType
        });
        var cx = (0, _ChartUtils.getCateCoordinateOfLine)({
          axis: xAxis,
          ticks: xAxisTicks,
          bandSize: xBandSize,
          entry: entry2,
          index,
          dataKey: xAxisDataKey
        }), cy = (0, _ChartUtils.getCateCoordinateOfLine)({
          axis: yAxis,
          ticks: yAxisTicks,
          bandSize: yBandSize,
          entry: entry2,
          index,
          dataKey: yAxisDataKey
        }), size = z !== "-" ? zAxis.scale(z) : defaultZ, radius = Math.sqrt(Math.max(size, 0) / Math.PI);
        return _objectSpread3(_objectSpread3({}, entry2), {}, {
          cx,
          cy,
          x: cx - radius,
          y: cy - radius,
          xAxis,
          yAxis,
          zAxis,
          width: 2 * radius,
          height: 2 * radius,
          size,
          node: {
            x,
            y,
            z
          },
          tooltipPayload,
          tooltipPosition: {
            x: cx,
            y: cy
          },
          payload: entry2
        }, cells && cells[index] && cells[index].props);
      });
      return _objectSpread3({
        points
      }, offset);
    };
  }
});

// node_modules/recharts/lib/cartesian/XAxis.js
var require_XAxis = __commonJS({
  "node_modules/recharts/lib/cartesian/XAxis.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.XAxis = void 0;
    var XAxis = function() {
      return null;
    };
    exports.XAxis = XAxis;
    XAxis.displayName = "XAxis";
    XAxis.defaultProps = {
      allowDecimals: !0,
      hide: !1,
      orientation: "bottom",
      width: 0,
      height: 30,
      mirror: !1,
      xAxisId: 0,
      tickCount: 5,
      type: "category",
      domain: [0, "auto"],
      padding: {
        left: 0,
        right: 0
      },
      allowDataOverflow: !1,
      scale: "auto",
      reversed: !1,
      allowDuplicatedCategory: !0
    };
  }
});

// node_modules/recharts/lib/cartesian/YAxis.js
var require_YAxis = __commonJS({
  "node_modules/recharts/lib/cartesian/YAxis.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.YAxis = void 0;
    var YAxis = function() {
      return null;
    };
    exports.YAxis = YAxis;
    YAxis.displayName = "YAxis";
    YAxis.defaultProps = {
      allowDuplicatedCategory: !0,
      allowDecimals: !0,
      hide: !1,
      orientation: "left",
      width: 60,
      height: 0,
      mirror: !1,
      yAxisId: 0,
      tickCount: 5,
      type: "number",
      domain: [0, "auto"],
      padding: {
        top: 0,
        bottom: 0
      },
      allowDataOverflow: !1,
      scale: "auto",
      reversed: !1
    };
  }
});

// node_modules/recharts/lib/util/DetectReferenceElementsDomain.js
var require_DetectReferenceElementsDomain = __commonJS({
  "node_modules/recharts/lib/util/DetectReferenceElementsDomain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.detectReferenceElementsDomain = void 0;
    var _ReferenceDot = require_ReferenceDot(), _ReferenceLine = require_ReferenceLine(), _ReferenceArea = require_ReferenceArea(), _IfOverflowMatches = require_IfOverflowMatches(), _ReactUtils = require_ReactUtils(), _DataUtils = require_DataUtils(), detectReferenceElementsDomain = function(children, domain, axisId, axisType, specifiedTicks) {
      var lines = (0, _ReactUtils.findAllByType)(children, _ReferenceLine.ReferenceLine.displayName), dots = (0, _ReactUtils.findAllByType)(children, _ReferenceDot.ReferenceDot.displayName), elements = lines.concat(dots), areas = (0, _ReactUtils.findAllByType)(children, _ReferenceArea.ReferenceArea.displayName), idKey = "".concat(axisType, "Id"), valueKey = axisType[0], finalDomain = domain;
      if (elements.length && (finalDomain = elements.reduce(function(result, el) {
        if (el.props[idKey] === axisId && (0, _IfOverflowMatches.ifOverflowMatches)(el.props, "extendDomain") && (0, _DataUtils.isNumber)(el.props[valueKey])) {
          var value = el.props[valueKey];
          return [Math.min(result[0], value), Math.max(result[1], value)];
        }
        return result;
      }, finalDomain)), areas.length) {
        var key1 = "".concat(valueKey, "1"), key2 = "".concat(valueKey, "2");
        finalDomain = areas.reduce(function(result, el) {
          if (el.props[idKey] === axisId && (0, _IfOverflowMatches.ifOverflowMatches)(el.props, "extendDomain") && (0, _DataUtils.isNumber)(el.props[key1]) && (0, _DataUtils.isNumber)(el.props[key2])) {
            var value1 = el.props[key1], value2 = el.props[key2];
            return [Math.min(result[0], value1, value2), Math.max(result[1], value1, value2)];
          }
          return result;
        }, finalDomain);
      }
      return specifiedTicks && specifiedTicks.length && (finalDomain = specifiedTicks.reduce(function(result, tick) {
        return (0, _DataUtils.isNumber)(tick) ? [Math.min(result[0], tick), Math.max(result[1], tick)] : result;
      }, finalDomain)), finalDomain;
    };
    exports.detectReferenceElementsDomain = detectReferenceElementsDomain;
  }
});

// node_modules/recharts/lib/util/Events.js
var require_Events = __commonJS({
  "node_modules/recharts/lib/util/Events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.SYNC_EVENT = exports.eventCenter = void 0;
    var _eventemitter = _interopRequireDefault(require("eventemitter3"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var eventCenter = new _eventemitter.default();
    exports.eventCenter = eventCenter;
    eventCenter.setMaxListeners && eventCenter.setMaxListeners(10);
    var SYNC_EVENT = "recharts.syncMouseEvents";
    exports.SYNC_EVENT = SYNC_EVENT;
  }
});

// node_modules/recharts/lib/chart/generateCategoricalChart.js
var require_generateCategoricalChart = __commonJS({
  "node_modules/recharts/lib/chart/generateCategoricalChart.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.generateCategoricalChart = void 0;
    var _every2 = _interopRequireDefault(require("lodash/every")), _find2 = _interopRequireDefault(require("lodash/find")), _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _throttle2 = _interopRequireDefault(require("lodash/throttle")), _sortBy2 = _interopRequireDefault(require("lodash/sortBy")), _get2 = _interopRequireDefault(require("lodash/get")), _range2 = _interopRequireDefault(require("lodash/range")), _isNil2 = _interopRequireDefault(require("lodash/isNil")), _isBoolean2 = _interopRequireDefault(require("lodash/isBoolean")), _isArray2 = _interopRequireDefault(require("lodash/isArray")), _react = _interopRequireWildcard(require("react")), _classnames = _interopRequireDefault(require("classnames")), _Surface = require_Surface(), _Layer = require_Layer(), _Tooltip = require_Tooltip(), _Legend = require_Legend(), _Curve = require_Curve(), _Cross = require_Cross(), _Sector = require_Sector(), _Dot = require_Dot(), _Rectangle = require_Rectangle(), _ReactUtils = require_ReactUtils(), _CartesianAxis = require_CartesianAxis(), _Brush = require_Brush(), _DOMUtils = require_DOMUtils(), _DataUtils = require_DataUtils(), _ChartUtils = require_ChartUtils(), _DetectReferenceElementsDomain = require_DetectReferenceElementsDomain(), _PolarUtils = require_PolarUtils(), _ShallowEqual = require_ShallowEqual(), _Events = require_Events(), _types = require_types();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _iterableToArrayLimit(arr, i) {
      if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(arr)))) {
        var _arr = [], _n = !0, _d = !1, _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose2(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source, key) || (target[key] = source[key]));
      }
      return target;
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!!o) {
        if (typeof o == "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
    }
    function _iterableToArray(iter) {
      if (typeof Symbol < "u" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _arrayLikeToArray(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    var ORIENT_MAP = {
      xAxis: ["bottom", "top"],
      yAxis: ["left", "right"]
    }, originCoordinate = {
      x: 0,
      y: 0
    }, isFinit = Number.isFinite ? Number.isFinite : isFinite, defer = typeof requestAnimationFrame == "function" ? requestAnimationFrame : typeof setImmediate == "function" ? setImmediate : setTimeout, deferClear = typeof cancelAnimationFrame == "function" ? cancelAnimationFrame : typeof clearImmediate == "function" ? clearImmediate : clearTimeout, calculateTooltipPos = function(rangeObj, layout) {
      return layout === "horizontal" ? rangeObj.x : layout === "vertical" ? rangeObj.y : layout === "centric" ? rangeObj.angle : rangeObj.radius;
    }, getActiveCoordinate = function(layout, tooltipTicks, activeIndex, rangeObj) {
      var entry2 = tooltipTicks.find(function(tick) {
        return tick && tick.index === activeIndex;
      });
      if (entry2) {
        if (layout === "horizontal")
          return {
            x: entry2.coordinate,
            y: rangeObj.y
          };
        if (layout === "vertical")
          return {
            x: rangeObj.x,
            y: entry2.coordinate
          };
        if (layout === "centric") {
          var _angle = entry2.coordinate, _radius = rangeObj.radius;
          return _objectSpread3(_objectSpread3(_objectSpread3({}, rangeObj), (0, _PolarUtils.polarToCartesian)(rangeObj.cx, rangeObj.cy, _radius, _angle)), {}, {
            angle: _angle,
            radius: _radius
          });
        }
        var radius = entry2.coordinate, angle = rangeObj.angle;
        return _objectSpread3(_objectSpread3(_objectSpread3({}, rangeObj), (0, _PolarUtils.polarToCartesian)(rangeObj.cx, rangeObj.cy, radius, angle)), {}, {
          angle,
          radius
        });
      }
      return originCoordinate;
    }, getDisplayedData = function(data, _ref, item) {
      var graphicalItems = _ref.graphicalItems, dataStartIndex = _ref.dataStartIndex, dataEndIndex = _ref.dataEndIndex, itemsData = (graphicalItems || []).reduce(function(result, child) {
        var itemData = child.props.data;
        return itemData && itemData.length ? [].concat(_toConsumableArray(result), _toConsumableArray(itemData)) : result;
      }, []);
      return itemsData && itemsData.length > 0 ? itemsData : item && item.props && item.props.data && item.props.data.length > 0 ? item.props.data : data && data.length && (0, _DataUtils.isNumber)(dataStartIndex) && (0, _DataUtils.isNumber)(dataEndIndex) ? data.slice(dataStartIndex, dataEndIndex + 1) : [];
    }, getTooltipContent = function(state, chartData, activeIndex, activeLabel) {
      var graphicalItems = state.graphicalItems, tooltipAxis = state.tooltipAxis, displayedData = getDisplayedData(chartData, state);
      return activeIndex < 0 || !graphicalItems || !graphicalItems.length || activeIndex >= displayedData.length ? null : graphicalItems.reduce(function(result, child) {
        var hide = child.props.hide;
        if (hide)
          return result;
        var data = child.props.data, payload;
        if (tooltipAxis.dataKey && !tooltipAxis.allowDuplicatedCategory) {
          var entries = data === void 0 ? displayedData : data;
          payload = (0, _DataUtils.findEntryInArray)(entries, tooltipAxis.dataKey, activeLabel);
        } else
          payload = data && data[activeIndex] || displayedData[activeIndex];
        return payload ? [].concat(_toConsumableArray(result), [(0, _ChartUtils.getTooltipItem)(child, payload)]) : result;
      }, []);
    }, getTooltipData = function(state, chartData, layout, rangeObj) {
      var rangeData = rangeObj || {
        x: state.chartX,
        y: state.chartY
      }, pos = calculateTooltipPos(rangeData, layout), ticks = state.orderedTooltipTicks, axis = state.tooltipAxis, tooltipTicks = state.tooltipTicks, activeIndex = (0, _ChartUtils.calculateActiveTickIndex)(pos, ticks, tooltipTicks, axis);
      if (activeIndex >= 0 && tooltipTicks) {
        var activeLabel = tooltipTicks[activeIndex] && tooltipTicks[activeIndex].value, activePayload = getTooltipContent(state, chartData, activeIndex, activeLabel), activeCoordinate = getActiveCoordinate(layout, ticks, activeIndex, rangeData);
        return {
          activeTooltipIndex: activeIndex,
          activeLabel,
          activePayload,
          activeCoordinate
        };
      }
      return null;
    }, getAxisMapByAxes = function(props, _ref2) {
      var axes = _ref2.axes, graphicalItems = _ref2.graphicalItems, axisType = _ref2.axisType, axisIdKey = _ref2.axisIdKey, stackGroups = _ref2.stackGroups, dataStartIndex = _ref2.dataStartIndex, dataEndIndex = _ref2.dataEndIndex, layout = props.layout, children = props.children, stackOffset = props.stackOffset, isCategorical = (0, _ChartUtils.isCategoricalAxis)(layout, axisType), axisMap = axes.reduce(function(result, child) {
        var _child$props = child.props, type = _child$props.type, dataKey = _child$props.dataKey, allowDataOverflow = _child$props.allowDataOverflow, allowDuplicatedCategory = _child$props.allowDuplicatedCategory, scale = _child$props.scale, ticks = _child$props.ticks, axisId = child.props[axisIdKey], displayedData = getDisplayedData(props.data, {
          graphicalItems: graphicalItems.filter(function(item) {
            return item.props[axisIdKey] === axisId;
          }),
          dataStartIndex,
          dataEndIndex
        }), len = displayedData.length;
        if (!result[axisId]) {
          var domain, duplicateDomain, categoricalDomain;
          if (dataKey) {
            if (domain = (0, _ChartUtils.getDomainOfDataByKey)(displayedData, dataKey, type), type === "category" && isCategorical) {
              var duplicate = (0, _DataUtils.hasDuplicate)(domain);
              allowDuplicatedCategory && duplicate ? (duplicateDomain = domain, domain = (0, _range2.default)(0, len)) : allowDuplicatedCategory || (domain = (0, _ChartUtils.parseDomainOfCategoryAxis)(child.props.domain, domain, child).reduce(function(finalDomain, entry2) {
                return finalDomain.indexOf(entry2) >= 0 ? finalDomain : [].concat(_toConsumableArray(finalDomain), [entry2]);
              }, []));
            } else if (type === "category")
              allowDuplicatedCategory ? domain = domain.filter(function(entry2) {
                return entry2 !== "" && !(0, _isNil2.default)(entry2);
              }) : domain = (0, _ChartUtils.parseDomainOfCategoryAxis)(child.props.domain, domain, child).reduce(function(finalDomain, entry2) {
                return finalDomain.indexOf(entry2) >= 0 || entry2 === "" || (0, _isNil2.default)(entry2) ? finalDomain : [].concat(_toConsumableArray(finalDomain), [entry2]);
              }, []);
            else if (type === "number") {
              var errorBarsDomain = (0, _ChartUtils.parseErrorBarsOfAxis)(displayedData, graphicalItems.filter(function(item) {
                return item.props[axisIdKey] === axisId && !item.props.hide;
              }), dataKey, axisType, layout);
              errorBarsDomain && (domain = errorBarsDomain);
            }
            isCategorical && (type === "number" || scale !== "auto") && (categoricalDomain = (0, _ChartUtils.getDomainOfDataByKey)(displayedData, dataKey, "category"));
          } else
            isCategorical ? domain = (0, _range2.default)(0, len) : stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack && type === "number" ? domain = stackOffset === "expand" ? [0, 1] : (0, _ChartUtils.getDomainOfStackGroups)(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex) : domain = (0, _ChartUtils.getDomainOfItemsWithSameAxis)(displayedData, graphicalItems.filter(function(item) {
              return item.props[axisIdKey] === axisId && !item.props.hide;
            }), type, layout, !0);
          if (type === "number")
            domain = (0, _DetectReferenceElementsDomain.detectReferenceElementsDomain)(children, domain, axisId, axisType, ticks), child.props.domain && (domain = (0, _ChartUtils.parseSpecifiedDomain)(child.props.domain, domain, allowDataOverflow));
          else if (type === "category" && child.props.domain) {
            var axisDomain = child.props.domain, isDomainValidate = domain.every(function(entry2) {
              return axisDomain.indexOf(entry2) >= 0;
            });
            isDomainValidate && (domain = axisDomain);
          }
          return _objectSpread3(_objectSpread3({}, result), {}, _defineProperty3({}, axisId, _objectSpread3(_objectSpread3({}, child.props), {}, {
            axisType,
            domain,
            categoricalDomain,
            duplicateDomain,
            originalDomain: child.props.domain,
            isCategorical,
            layout
          })));
        }
        return result;
      }, {});
      return axisMap;
    }, getAxisMapByItems = function(props, _ref3) {
      var graphicalItems = _ref3.graphicalItems, Axis = _ref3.Axis, axisType = _ref3.axisType, axisIdKey = _ref3.axisIdKey, stackGroups = _ref3.stackGroups, dataStartIndex = _ref3.dataStartIndex, dataEndIndex = _ref3.dataEndIndex, layout = props.layout, children = props.children, displayedData = getDisplayedData(props.data, {
        graphicalItems,
        dataStartIndex,
        dataEndIndex
      }), len = displayedData.length, isCategorical = (0, _ChartUtils.isCategoricalAxis)(layout, axisType), index = -1, axisMap = graphicalItems.reduce(function(result, child) {
        var axisId = child.props[axisIdKey];
        if (!result[axisId]) {
          index++;
          var domain;
          return isCategorical ? domain = (0, _range2.default)(0, len) : stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack ? (domain = (0, _ChartUtils.getDomainOfStackGroups)(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex), domain = (0, _DetectReferenceElementsDomain.detectReferenceElementsDomain)(children, domain, axisId, axisType)) : (domain = (0, _ChartUtils.parseSpecifiedDomain)(Axis.defaultProps.domain, (0, _ChartUtils.getDomainOfItemsWithSameAxis)(displayedData, graphicalItems.filter(function(item) {
            return item.props[axisIdKey] === axisId && !item.props.hide;
          }), "number", layout), Axis.defaultProps.allowDataOverflow), domain = (0, _DetectReferenceElementsDomain.detectReferenceElementsDomain)(children, domain, axisId, axisType)), _objectSpread3(_objectSpread3({}, result), {}, _defineProperty3({}, axisId, _objectSpread3(_objectSpread3({
            axisType
          }, Axis.defaultProps), {}, {
            hide: !0,
            orientation: (0, _get2.default)(ORIENT_MAP, "".concat(axisType, ".").concat(index % 2), null),
            domain,
            originalDomain: Axis.defaultProps.domain,
            isCategorical,
            layout
          })));
        }
        return result;
      }, {});
      return axisMap;
    }, getAxisMap = function(props, _ref4) {
      var _ref4$axisType = _ref4.axisType, axisType = _ref4$axisType === void 0 ? "xAxis" : _ref4$axisType, AxisComp = _ref4.AxisComp, graphicalItems = _ref4.graphicalItems, stackGroups = _ref4.stackGroups, dataStartIndex = _ref4.dataStartIndex, dataEndIndex = _ref4.dataEndIndex, children = props.children, axisIdKey = "".concat(axisType, "Id"), axes = (0, _ReactUtils.findAllByType)(children, AxisComp), axisMap = {};
      return axes && axes.length ? axisMap = getAxisMapByAxes(props, {
        axes,
        graphicalItems,
        axisType,
        axisIdKey,
        stackGroups,
        dataStartIndex,
        dataEndIndex
      }) : graphicalItems && graphicalItems.length && (axisMap = getAxisMapByItems(props, {
        Axis: AxisComp,
        graphicalItems,
        axisType,
        axisIdKey,
        stackGroups,
        dataStartIndex,
        dataEndIndex
      })), axisMap;
    }, tooltipTicksGenerator = function(axisMap) {
      var axis = (0, _DataUtils.getAnyElementOfObject)(axisMap), tooltipTicks = (0, _ChartUtils.getTicksOfAxis)(axis, !1, !0);
      return {
        tooltipTicks,
        orderedTooltipTicks: (0, _sortBy2.default)(tooltipTicks, function(o) {
          return o.coordinate;
        }),
        tooltipAxis: axis,
        tooltipAxisBandSize: (0, _ChartUtils.getBandSizeOfAxis)(axis, tooltipTicks)
      };
    }, createDefaultState = function(props) {
      var _brushItem$props, _brushItem$props2, children = props.children, defaultShowTooltip = props.defaultShowTooltip, brushItem = (0, _ReactUtils.findChildByType)(children, _Brush.Brush.displayName), startIndex = brushItem && brushItem.props && brushItem.props.startIndex || 0, endIndex = (brushItem == null || (_brushItem$props = brushItem.props) === null || _brushItem$props === void 0 ? void 0 : _brushItem$props.endIndex) !== void 0 ? brushItem == null || (_brushItem$props2 = brushItem.props) === null || _brushItem$props2 === void 0 ? void 0 : _brushItem$props2.endIndex : props.data && props.data.length - 1 || 0;
      return {
        chartX: 0,
        chartY: 0,
        dataStartIndex: startIndex,
        dataEndIndex: endIndex,
        activeTooltipIndex: -1,
        isTooltipActive: (0, _isNil2.default)(defaultShowTooltip) ? !1 : defaultShowTooltip
      };
    }, hasGraphicalBarItem = function(graphicalItems) {
      return !graphicalItems || !graphicalItems.length ? !1 : graphicalItems.some(function(item) {
        var name = (0, _ReactUtils.getDisplayName)(item && item.type);
        return name && name.indexOf("Bar") >= 0;
      });
    }, getAxisNameByLayout = function(layout) {
      return layout === "horizontal" ? {
        numericAxisName: "yAxis",
        cateAxisName: "xAxis"
      } : layout === "vertical" ? {
        numericAxisName: "xAxis",
        cateAxisName: "yAxis"
      } : layout === "centric" ? {
        numericAxisName: "radiusAxis",
        cateAxisName: "angleAxis"
      } : {
        numericAxisName: "angleAxis",
        cateAxisName: "radiusAxis"
      };
    }, calculateOffset = function(_ref5, prevLegendBBox) {
      var props = _ref5.props, graphicalItems = _ref5.graphicalItems, _ref5$xAxisMap = _ref5.xAxisMap, xAxisMap = _ref5$xAxisMap === void 0 ? {} : _ref5$xAxisMap, _ref5$yAxisMap = _ref5.yAxisMap, yAxisMap = _ref5$yAxisMap === void 0 ? {} : _ref5$yAxisMap, width = props.width, height = props.height, children = props.children, margin = props.margin || {}, brushItem = (0, _ReactUtils.findChildByType)(children, _Brush.Brush.displayName), legendItem = (0, _ReactUtils.findChildByType)(children, _Legend.Legend.displayName), offsetH = Object.keys(yAxisMap).reduce(function(result, id) {
        var entry2 = yAxisMap[id], orientation = entry2.orientation;
        return !entry2.mirror && !entry2.hide ? _objectSpread3(_objectSpread3({}, result), {}, _defineProperty3({}, orientation, result[orientation] + entry2.width)) : result;
      }, {
        left: margin.left || 0,
        right: margin.right || 0
      }), offsetV = Object.keys(xAxisMap).reduce(function(result, id) {
        var entry2 = xAxisMap[id], orientation = entry2.orientation;
        return !entry2.mirror && !entry2.hide ? _objectSpread3(_objectSpread3({}, result), {}, _defineProperty3({}, orientation, (0, _get2.default)(result, "".concat(orientation)) + entry2.height)) : result;
      }, {
        top: margin.top || 0,
        bottom: margin.bottom || 0
      }), offset = _objectSpread3(_objectSpread3({}, offsetV), offsetH), brushBottom = offset.bottom;
      return brushItem && (offset.bottom += brushItem.props.height || _Brush.Brush.defaultProps.height), legendItem && prevLegendBBox && (offset = (0, _ChartUtils.appendOffsetOfLegend)(offset, graphicalItems, props, prevLegendBBox)), _objectSpread3(_objectSpread3({
        brushBottom
      }, offset), {}, {
        width: width - offset.left - offset.right,
        height: height - offset.top - offset.bottom
      });
    }, generateCategoricalChart = function(_ref6) {
      var _class, _temp, chartName = _ref6.chartName, GraphicalChild = _ref6.GraphicalChild, _ref6$defaultTooltipE = _ref6.defaultTooltipEventType, defaultTooltipEventType = _ref6$defaultTooltipE === void 0 ? "axis" : _ref6$defaultTooltipE, _ref6$validateTooltip = _ref6.validateTooltipEventTypes, validateTooltipEventTypes = _ref6$validateTooltip === void 0 ? ["axis"] : _ref6$validateTooltip, axisComponents = _ref6.axisComponents, legendContent = _ref6.legendContent, formatAxisMap = _ref6.formatAxisMap, defaultProps = _ref6.defaultProps, getFormatItems = function(props, currentState) {
        var graphicalItems = currentState.graphicalItems, stackGroups = currentState.stackGroups, offset = currentState.offset, updateId = currentState.updateId, dataStartIndex = currentState.dataStartIndex, dataEndIndex = currentState.dataEndIndex, barSize = props.barSize, layout = props.layout, barGap = props.barGap, barCategoryGap = props.barCategoryGap, globalMaxBarSize = props.maxBarSize, _getAxisNameByLayout = getAxisNameByLayout(layout), numericAxisName = _getAxisNameByLayout.numericAxisName, cateAxisName = _getAxisNameByLayout.cateAxisName, hasBar = hasGraphicalBarItem(graphicalItems), sizeList = hasBar && (0, _ChartUtils.getBarSizeList)({
          barSize,
          stackGroups
        }), formattedItems = [];
        return graphicalItems.forEach(function(item, index) {
          var displayedData = getDisplayedData(props.data, {
            dataStartIndex,
            dataEndIndex
          }, item), _item$props = item.props, dataKey = _item$props.dataKey, childMaxBarSize = _item$props.maxBarSize, numericAxisId = item.props["".concat(numericAxisName, "Id")], cateAxisId = item.props["".concat(cateAxisName, "Id")], axisObj = axisComponents.reduce(function(result, entry2) {
            var _objectSpread6, axisMap = currentState["".concat(entry2.axisType, "Map")], id = item.props["".concat(entry2.axisType, "Id")], axis = axisMap && axisMap[id];
            return _objectSpread3(_objectSpread3({}, result), {}, (_objectSpread6 = {}, _defineProperty3(_objectSpread6, entry2.axisType, axis), _defineProperty3(_objectSpread6, "".concat(entry2.axisType, "Ticks"), (0, _ChartUtils.getTicksOfAxis)(axis)), _objectSpread6));
          }, {}), cateAxis = axisObj[cateAxisName], cateTicks = axisObj["".concat(cateAxisName, "Ticks")], stackedData = stackGroups && stackGroups[numericAxisId] && stackGroups[numericAxisId].hasStack && (0, _ChartUtils.getStackedDataOfItem)(item, stackGroups[numericAxisId].stackGroups), itemIsBar = (0, _ReactUtils.getDisplayName)(item.type).indexOf("Bar") >= 0, bandSize = (0, _ChartUtils.getBandSizeOfAxis)(cateAxis, cateTicks), barPosition = [];
          if (itemIsBar) {
            var _ref7, _getBandSizeOfAxis, maxBarSize = (0, _isNil2.default)(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize, barBandSize = (_ref7 = (_getBandSizeOfAxis = (0, _ChartUtils.getBandSizeOfAxis)(cateAxis, cateTicks, !0)) !== null && _getBandSizeOfAxis !== void 0 ? _getBandSizeOfAxis : maxBarSize) !== null && _ref7 !== void 0 ? _ref7 : 0;
            barPosition = (0, _ChartUtils.getBarPosition)({
              barGap,
              barCategoryGap,
              bandSize: barBandSize !== bandSize ? barBandSize : bandSize,
              sizeList: sizeList[cateAxisId],
              maxBarSize
            }), barBandSize !== bandSize && (barPosition = barPosition.map(function(pos) {
              return _objectSpread3(_objectSpread3({}, pos), {}, {
                position: _objectSpread3(_objectSpread3({}, pos.position), {}, {
                  offset: pos.position.offset - barBandSize / 2
                })
              });
            }));
          }
          var composedFn = item && item.type && item.type.getComposedData;
          if (composedFn) {
            var _objectSpread7;
            formattedItems.push({
              props: _objectSpread3(_objectSpread3({}, composedFn(_objectSpread3(_objectSpread3({}, axisObj), {}, {
                displayedData,
                props,
                dataKey,
                item,
                bandSize,
                barPosition,
                offset,
                stackedData,
                layout,
                dataStartIndex,
                dataEndIndex
              }))), {}, (_objectSpread7 = {
                key: item.key || "item-".concat(index)
              }, _defineProperty3(_objectSpread7, numericAxisName, axisObj[numericAxisName]), _defineProperty3(_objectSpread7, cateAxisName, axisObj[cateAxisName]), _defineProperty3(_objectSpread7, "animationId", updateId), _objectSpread7)),
              childIndex: (0, _ReactUtils.parseChildIndex)(item, props.children),
              item
            });
          }
        }), formattedItems;
      }, updateStateOfAxisMapsOffsetAndStackGroups = function(_ref8, prevState) {
        var props = _ref8.props, dataStartIndex = _ref8.dataStartIndex, dataEndIndex = _ref8.dataEndIndex, updateId = _ref8.updateId;
        if (!(0, _ReactUtils.validateWidthHeight)({
          props
        }))
          return null;
        var children = props.children, layout = props.layout, stackOffset = props.stackOffset, data = props.data, reverseStackOrder = props.reverseStackOrder, _getAxisNameByLayout2 = getAxisNameByLayout(layout), numericAxisName = _getAxisNameByLayout2.numericAxisName, cateAxisName = _getAxisNameByLayout2.cateAxisName, graphicalItems = (0, _ReactUtils.findAllByType)(children, GraphicalChild), stackGroups = (0, _ChartUtils.getStackGroupsByAxisId)(data, graphicalItems, "".concat(numericAxisName, "Id"), "".concat(cateAxisName, "Id"), stackOffset, reverseStackOrder), axisObj = axisComponents.reduce(function(result, entry2) {
          var name = "".concat(entry2.axisType, "Map");
          return _objectSpread3(_objectSpread3({}, result), {}, _defineProperty3({}, name, getAxisMap(props, _objectSpread3(_objectSpread3({}, entry2), {}, {
            graphicalItems,
            stackGroups: entry2.axisType === numericAxisName && stackGroups,
            dataStartIndex,
            dataEndIndex
          }))));
        }, {}), offset = calculateOffset(_objectSpread3(_objectSpread3({}, axisObj), {}, {
          props,
          graphicalItems
        }), prevState == null ? void 0 : prevState.legendBBox);
        Object.keys(axisObj).forEach(function(key) {
          axisObj[key] = formatAxisMap(props, axisObj[key], offset, key.replace("Map", ""), chartName);
        });
        var cateAxisMap = axisObj["".concat(cateAxisName, "Map")], ticksObj = tooltipTicksGenerator(cateAxisMap), formattedGraphicalItems = getFormatItems(props, _objectSpread3(_objectSpread3({}, axisObj), {}, {
          dataStartIndex,
          dataEndIndex,
          updateId,
          graphicalItems,
          stackGroups,
          offset
        }));
        return _objectSpread3(_objectSpread3({
          formattedGraphicalItems,
          graphicalItems,
          offset,
          stackGroups
        }, ticksObj), axisObj);
      };
      return _temp = _class = /* @__PURE__ */ function(_Component) {
        _inherits(CategoricalChartWrapper, _Component);
        var _super = _createSuper(CategoricalChartWrapper);
        function CategoricalChartWrapper(_props) {
          var _this;
          return _classCallCheck(this, CategoricalChartWrapper), _this = _super.call(this, _props), _this.uniqueChartId = void 0, _this.clipPathId = void 0, _this.legendInstance = void 0, _this.deferId = void 0, _this.container = void 0, _this.clearDeferId = function() {
            !(0, _isNil2.default)(_this.deferId) && deferClear && deferClear(_this.deferId), _this.deferId = null;
          }, _this.handleLegendBBoxUpdate = function(box) {
            if (box) {
              var _this$state = _this.state, dataStartIndex = _this$state.dataStartIndex, dataEndIndex = _this$state.dataEndIndex, updateId = _this$state.updateId;
              _this.setState(_objectSpread3({
                legendBBox: box
              }, updateStateOfAxisMapsOffsetAndStackGroups({
                props: _this.props,
                dataStartIndex,
                dataEndIndex,
                updateId
              }, _objectSpread3(_objectSpread3({}, _this.state), {}, {
                legendBBox: box
              }))));
            }
          }, _this.handleReceiveSyncEvent = function(cId, chartId, data) {
            var syncId = _this.props.syncId;
            syncId === cId && chartId !== _this.uniqueChartId && (_this.clearDeferId(), _this.deferId = defer && defer(_this.applySyncEvent.bind(_assertThisInitialized(_this), data)));
          }, _this.handleBrushChange = function(_ref9) {
            var startIndex = _ref9.startIndex, endIndex = _ref9.endIndex;
            if (startIndex !== _this.state.dataStartIndex || endIndex !== _this.state.dataEndIndex) {
              var updateId = _this.state.updateId;
              _this.setState(function() {
                return _objectSpread3({
                  dataStartIndex: startIndex,
                  dataEndIndex: endIndex
                }, updateStateOfAxisMapsOffsetAndStackGroups({
                  props: _this.props,
                  dataStartIndex: startIndex,
                  dataEndIndex: endIndex,
                  updateId
                }, _this.state));
              }), _this.triggerSyncEvent({
                dataStartIndex: startIndex,
                dataEndIndex: endIndex
              });
            }
          }, _this.handleMouseEnter = function(e) {
            var onMouseEnter = _this.props.onMouseEnter, mouse = _this.getMouseInfo(e);
            if (mouse) {
              var _nextState = _objectSpread3(_objectSpread3({}, mouse), {}, {
                isTooltipActive: !0
              });
              _this.setState(_nextState), _this.triggerSyncEvent(_nextState), (0, _isFunction2.default)(onMouseEnter) && onMouseEnter(_nextState, e);
            }
          }, _this.triggeredAfterMouseMove = function(e) {
            var onMouseMove = _this.props.onMouseMove, mouse = _this.getMouseInfo(e), nextState = mouse ? _objectSpread3(_objectSpread3({}, mouse), {}, {
              isTooltipActive: !0
            }) : {
              isTooltipActive: !1
            };
            _this.setState(nextState), _this.triggerSyncEvent(nextState), (0, _isFunction2.default)(onMouseMove) && onMouseMove(nextState, e);
          }, _this.handleItemMouseEnter = function(el) {
            _this.setState(function() {
              return {
                isTooltipActive: !0,
                activeItem: el,
                activePayload: el.tooltipPayload,
                activeCoordinate: el.tooltipPosition || {
                  x: el.cx,
                  y: el.cy
                }
              };
            });
          }, _this.handleItemMouseLeave = function() {
            _this.setState(function() {
              return {
                isTooltipActive: !1
              };
            });
          }, _this.handleMouseMove = function(e) {
            e && (0, _isFunction2.default)(e.persist) && e.persist(), _this.triggeredAfterMouseMove(e);
          }, _this.handleMouseLeave = function(e) {
            var onMouseLeave = _this.props.onMouseLeave, nextState = {
              isTooltipActive: !1
            };
            _this.setState(nextState), _this.triggerSyncEvent(nextState), (0, _isFunction2.default)(onMouseLeave) && onMouseLeave(nextState, e), _this.cancelThrottledTriggerAfterMouseMove();
          }, _this.handleOuterEvent = function(e) {
            var eventName = (0, _ReactUtils.getReactEventByType)(e), event = (0, _get2.default)(_this.props, "".concat(eventName));
            if (eventName && (0, _isFunction2.default)(event)) {
              var mouse;
              /.*touch.*/i.test(eventName) ? mouse = _this.getMouseInfo(e.changedTouches[0]) : mouse = _this.getMouseInfo(e);
              var handler = event;
              handler(mouse, e);
            }
          }, _this.handleClick = function(e) {
            var onClick = _this.props.onClick, mouse = _this.getMouseInfo(e);
            if (mouse) {
              var _nextState2 = _objectSpread3(_objectSpread3({}, mouse), {}, {
                isTooltipActive: !0
              });
              _this.setState(_nextState2), _this.triggerSyncEvent(_nextState2), (0, _isFunction2.default)(onClick) && onClick(_nextState2, e);
            }
          }, _this.handleMouseDown = function(e) {
            var onMouseDown = _this.props.onMouseDown;
            if ((0, _isFunction2.default)(onMouseDown)) {
              var _nextState3 = _this.getMouseInfo(e);
              onMouseDown(_nextState3, e);
            }
          }, _this.handleMouseUp = function(e) {
            var onMouseUp = _this.props.onMouseUp;
            if ((0, _isFunction2.default)(onMouseUp)) {
              var _nextState4 = _this.getMouseInfo(e);
              onMouseUp(_nextState4, e);
            }
          }, _this.handleTouchMove = function(e) {
            e.changedTouches != null && e.changedTouches.length > 0 && _this.handleMouseMove(e.changedTouches[0]);
          }, _this.handleTouchStart = function(e) {
            e.changedTouches != null && e.changedTouches.length > 0 && _this.handleMouseDown(e.changedTouches[0]);
          }, _this.handleTouchEnd = function(e) {
            e.changedTouches != null && e.changedTouches.length > 0 && _this.handleMouseUp(e.changedTouches[0]);
          }, _this.verticalCoordinatesGenerator = function(_ref10) {
            var xAxis = _ref10.xAxis, width = _ref10.width, height = _ref10.height, offset = _ref10.offset;
            return (0, _ChartUtils.getCoordinatesOfGrid)(_CartesianAxis.CartesianAxis.getTicks(_objectSpread3(_objectSpread3(_objectSpread3({}, _CartesianAxis.CartesianAxis.defaultProps), xAxis), {}, {
              ticks: (0, _ChartUtils.getTicksOfAxis)(xAxis, !0),
              viewBox: {
                x: 0,
                y: 0,
                width,
                height
              }
            })), offset.left, offset.left + offset.width);
          }, _this.horizontalCoordinatesGenerator = function(_ref11) {
            var yAxis = _ref11.yAxis, width = _ref11.width, height = _ref11.height, offset = _ref11.offset;
            return (0, _ChartUtils.getCoordinatesOfGrid)(_CartesianAxis.CartesianAxis.getTicks(_objectSpread3(_objectSpread3(_objectSpread3({}, _CartesianAxis.CartesianAxis.defaultProps), yAxis), {}, {
              ticks: (0, _ChartUtils.getTicksOfAxis)(yAxis, !0),
              viewBox: {
                x: 0,
                y: 0,
                width,
                height
              }
            })), offset.top, offset.top + offset.height);
          }, _this.axesTicksGenerator = function(axis) {
            return (0, _ChartUtils.getTicksOfAxis)(axis, !0);
          }, _this.renderCursor = function(element) {
            var _this$state2 = _this.state, isTooltipActive = _this$state2.isTooltipActive, activeCoordinate = _this$state2.activeCoordinate, activePayload = _this$state2.activePayload, offset = _this$state2.offset, activeTooltipIndex = _this$state2.activeTooltipIndex, tooltipEventType = _this.getTooltipEventType();
            if (!element || !element.props.cursor || !isTooltipActive || !activeCoordinate || chartName !== "ScatterChart" && tooltipEventType !== "axis")
              return null;
            var layout = _this.props.layout, restProps, cursorComp = _Curve.Curve;
            if (chartName === "ScatterChart")
              restProps = activeCoordinate, cursorComp = _Cross.Cross;
            else if (chartName === "BarChart")
              restProps = _this.getCursorRectangle(), cursorComp = _Rectangle.Rectangle;
            else if (layout === "radial") {
              var _this$getCursorPoints = _this.getCursorPoints(), cx = _this$getCursorPoints.cx, cy = _this$getCursorPoints.cy, radius = _this$getCursorPoints.radius, startAngle = _this$getCursorPoints.startAngle, endAngle = _this$getCursorPoints.endAngle;
              restProps = {
                cx,
                cy,
                startAngle,
                endAngle,
                innerRadius: radius,
                outerRadius: radius
              }, cursorComp = _Sector.Sector;
            } else
              restProps = {
                points: _this.getCursorPoints()
              }, cursorComp = _Curve.Curve;
            var key = element.key || "_recharts-cursor", cursorProps = _objectSpread3(_objectSpread3(_objectSpread3(_objectSpread3({
              stroke: "#ccc",
              pointerEvents: "none"
            }, offset), restProps), (0, _types.filterProps)(element.props.cursor)), {}, {
              payload: activePayload,
              payloadIndex: activeTooltipIndex,
              key,
              className: "recharts-tooltip-cursor"
            });
            return /* @__PURE__ */ (0, _react.isValidElement)(element.props.cursor) ? /* @__PURE__ */ (0, _react.cloneElement)(element.props.cursor, cursorProps) : /* @__PURE__ */ (0, _react.createElement)(cursorComp, cursorProps);
          }, _this.renderPolarAxis = function(element, displayName, index) {
            var axisType = (0, _get2.default)(element, "type.axisType"), axisMap = (0, _get2.default)(_this.state, "".concat(axisType, "Map")), axisOption = axisMap[element.props["".concat(axisType, "Id")]];
            return /* @__PURE__ */ (0, _react.cloneElement)(element, _objectSpread3(_objectSpread3({}, axisOption), {}, {
              className: axisType,
              key: element.key || "".concat(displayName, "-").concat(index),
              ticks: (0, _ChartUtils.getTicksOfAxis)(axisOption, !0)
            }));
          }, _this.renderXAxis = function(element, displayName, index) {
            var xAxisMap = _this.state.xAxisMap, axisObj = xAxisMap[element.props.xAxisId];
            return _this.renderAxis(axisObj, element, displayName, index);
          }, _this.renderYAxis = function(element, displayName, index) {
            var yAxisMap = _this.state.yAxisMap, axisObj = yAxisMap[element.props.yAxisId];
            return _this.renderAxis(axisObj, element, displayName, index);
          }, _this.renderGrid = function(element) {
            var _this$state3 = _this.state, xAxisMap = _this$state3.xAxisMap, yAxisMap = _this$state3.yAxisMap, offset = _this$state3.offset, _this$props = _this.props, width = _this$props.width, height = _this$props.height, xAxis = (0, _DataUtils.getAnyElementOfObject)(xAxisMap), yAxisWithFiniteDomain = (0, _find2.default)(yAxisMap, function(axis) {
              return (0, _every2.default)(axis.domain, isFinit);
            }), yAxis = yAxisWithFiniteDomain || (0, _DataUtils.getAnyElementOfObject)(yAxisMap), props = element.props || {};
            return /* @__PURE__ */ (0, _react.cloneElement)(element, {
              key: element.key || "grid",
              x: (0, _DataUtils.isNumber)(props.x) ? props.x : offset.left,
              y: (0, _DataUtils.isNumber)(props.y) ? props.y : offset.top,
              width: (0, _DataUtils.isNumber)(props.width) ? props.width : offset.width,
              height: (0, _DataUtils.isNumber)(props.height) ? props.height : offset.height,
              xAxis,
              yAxis,
              offset,
              chartWidth: width,
              chartHeight: height,
              verticalCoordinatesGenerator: props.verticalCoordinatesGenerator || _this.verticalCoordinatesGenerator,
              horizontalCoordinatesGenerator: props.horizontalCoordinatesGenerator || _this.horizontalCoordinatesGenerator
            });
          }, _this.renderPolarGrid = function(element) {
            var _element$props = element.props, radialLines = _element$props.radialLines, polarAngles = _element$props.polarAngles, polarRadius = _element$props.polarRadius, _this$state4 = _this.state, radiusAxisMap = _this$state4.radiusAxisMap, angleAxisMap = _this$state4.angleAxisMap, radiusAxis = (0, _DataUtils.getAnyElementOfObject)(radiusAxisMap), angleAxis = (0, _DataUtils.getAnyElementOfObject)(angleAxisMap), cx = angleAxis.cx, cy = angleAxis.cy, innerRadius = angleAxis.innerRadius, outerRadius = angleAxis.outerRadius;
            return /* @__PURE__ */ (0, _react.cloneElement)(element, {
              polarAngles: (0, _isArray2.default)(polarAngles) ? polarAngles : (0, _ChartUtils.getTicksOfAxis)(angleAxis, !0).map(function(entry2) {
                return entry2.coordinate;
              }),
              polarRadius: (0, _isArray2.default)(polarRadius) ? polarRadius : (0, _ChartUtils.getTicksOfAxis)(radiusAxis, !0).map(function(entry2) {
                return entry2.coordinate;
              }),
              cx,
              cy,
              innerRadius,
              outerRadius,
              key: element.key || "polar-grid",
              radialLines
            });
          }, _this.renderLegend = function() {
            var formattedGraphicalItems = _this.state.formattedGraphicalItems, _this$props2 = _this.props, children = _this$props2.children, width = _this$props2.width, height = _this$props2.height, margin = _this.props.margin || {}, legendWidth = width - (margin.left || 0) - (margin.right || 0), props = (0, _ChartUtils.getLegendProps)({
              children,
              formattedGraphicalItems,
              legendWidth,
              legendContent
            });
            if (!props)
              return null;
            var item = props.item, otherProps = _objectWithoutProperties2(props, ["item"]);
            return /* @__PURE__ */ (0, _react.cloneElement)(item, _objectSpread3(_objectSpread3({}, otherProps), {}, {
              chartWidth: width,
              chartHeight: height,
              margin,
              ref: function(legend) {
                _this.legendInstance = legend;
              },
              onBBoxUpdate: _this.handleLegendBBoxUpdate
            }));
          }, _this.renderTooltip = function() {
            var children = _this.props.children, tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip.displayName);
            if (!tooltipItem)
              return null;
            var _this$state5 = _this.state, isTooltipActive = _this$state5.isTooltipActive, activeCoordinate = _this$state5.activeCoordinate, activePayload = _this$state5.activePayload, activeLabel = _this$state5.activeLabel, offset = _this$state5.offset;
            return /* @__PURE__ */ (0, _react.cloneElement)(tooltipItem, {
              viewBox: _objectSpread3(_objectSpread3({}, offset), {}, {
                x: offset.left,
                y: offset.top
              }),
              active: isTooltipActive,
              label: activeLabel,
              payload: isTooltipActive ? activePayload : [],
              coordinate: activeCoordinate
            });
          }, _this.renderBrush = function(element) {
            var _this$props3 = _this.props, margin = _this$props3.margin, data = _this$props3.data, _this$state6 = _this.state, offset = _this$state6.offset, dataStartIndex = _this$state6.dataStartIndex, dataEndIndex = _this$state6.dataEndIndex, updateId = _this$state6.updateId;
            return /* @__PURE__ */ (0, _react.cloneElement)(element, {
              key: element.key || "_recharts-brush",
              onChange: (0, _ChartUtils.combineEventHandlers)(_this.handleBrushChange, null, element.props.onChange),
              data,
              x: (0, _DataUtils.isNumber)(element.props.x) ? element.props.x : offset.left,
              y: (0, _DataUtils.isNumber)(element.props.y) ? element.props.y : offset.top + offset.height + offset.brushBottom - (margin.bottom || 0),
              width: (0, _DataUtils.isNumber)(element.props.width) ? element.props.width : offset.width,
              startIndex: dataStartIndex,
              endIndex: dataEndIndex,
              updateId: "brush-".concat(updateId)
            });
          }, _this.renderReferenceElement = function(element, displayName, index) {
            if (!element)
              return null;
            var _assertThisInitialize = _assertThisInitialized(_this), clipPathId = _assertThisInitialize.clipPathId, _this$state7 = _this.state, xAxisMap = _this$state7.xAxisMap, yAxisMap = _this$state7.yAxisMap, offset = _this$state7.offset, _element$props2 = element.props, xAxisId = _element$props2.xAxisId, yAxisId = _element$props2.yAxisId;
            return /* @__PURE__ */ (0, _react.cloneElement)(element, {
              key: element.key || "".concat(displayName, "-").concat(index),
              xAxis: xAxisMap[xAxisId],
              yAxis: yAxisMap[yAxisId],
              viewBox: {
                x: offset.left,
                y: offset.top,
                width: offset.width,
                height: offset.height
              },
              clipPathId
            });
          }, _this.renderActivePoints = function(_ref12) {
            var item = _ref12.item, activePoint = _ref12.activePoint, basePoint = _ref12.basePoint, childIndex = _ref12.childIndex, isRange = _ref12.isRange, result = [], key = item.props.key, _item$item$props = item.item.props, activeDot = _item$item$props.activeDot, dataKey = _item$item$props.dataKey, dotProps = _objectSpread3(_objectSpread3({
              index: childIndex,
              dataKey,
              cx: activePoint.x,
              cy: activePoint.y,
              r: 4,
              fill: (0, _ChartUtils.getMainColorOfGraphicItem)(item.item),
              strokeWidth: 2,
              stroke: "#fff",
              payload: activePoint.payload,
              value: activePoint.value,
              key: "".concat(key, "-activePoint-").concat(childIndex)
            }, (0, _types.filterProps)(activeDot)), (0, _types.adaptEventHandlers)(activeDot));
            return result.push(CategoricalChartWrapper.renderActiveDot(activeDot, dotProps)), basePoint ? result.push(CategoricalChartWrapper.renderActiveDot(activeDot, _objectSpread3(_objectSpread3({}, dotProps), {}, {
              cx: basePoint.x,
              cy: basePoint.y,
              key: "".concat(key, "-basePoint-").concat(childIndex)
            }))) : isRange && result.push(null), result;
          }, _this.renderGraphicChild = function(element, displayName, index) {
            var item = _this.filterFormatItem(element, displayName, index);
            if (!item)
              return null;
            var tooltipEventType = _this.getTooltipEventType(), _this$state8 = _this.state, isTooltipActive = _this$state8.isTooltipActive, tooltipAxis = _this$state8.tooltipAxis, activeTooltipIndex = _this$state8.activeTooltipIndex, activeLabel = _this$state8.activeLabel, children = _this.props.children, tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip.displayName), _item$props2 = item.props, points = _item$props2.points, isRange = _item$props2.isRange, baseLine = _item$props2.baseLine, _item$item$props2 = item.item.props, activeDot = _item$item$props2.activeDot, hide = _item$item$props2.hide, hasActive = !hide && isTooltipActive && tooltipItem && activeDot && activeTooltipIndex >= 0, itemEvents = {};
            tooltipEventType !== "axis" && tooltipItem && tooltipItem.props.trigger === "click" ? itemEvents = {
              onClick: (0, _ChartUtils.combineEventHandlers)(_this.handleItemMouseEnter, null, element.props.onCLick)
            } : tooltipEventType !== "axis" && (itemEvents = {
              onMouseLeave: (0, _ChartUtils.combineEventHandlers)(_this.handleItemMouseLeave, null, element.props.onMouseLeave),
              onMouseEnter: (0, _ChartUtils.combineEventHandlers)(_this.handleItemMouseEnter, null, element.props.onMouseEnter)
            });
            var graphicalItem = /* @__PURE__ */ (0, _react.cloneElement)(element, _objectSpread3(_objectSpread3({}, item.props), itemEvents));
            function findWithPayload(entry2) {
              return typeof tooltipAxis.dataKey == "function" ? tooltipAxis.dataKey(entry2.payload) : null;
            }
            if (hasActive) {
              var activePoint, basePoint;
              if (tooltipAxis.dataKey && !tooltipAxis.allowDuplicatedCategory) {
                var specifiedKey = typeof tooltipAxis.dataKey == "function" ? findWithPayload : "payload.".concat(tooltipAxis.dataKey.toString());
                activePoint = (0, _DataUtils.findEntryInArray)(points, specifiedKey, activeLabel), basePoint = isRange && baseLine && (0, _DataUtils.findEntryInArray)(baseLine, specifiedKey, activeLabel);
              } else
                activePoint = points[activeTooltipIndex], basePoint = isRange && baseLine && baseLine[activeTooltipIndex];
              if (!(0, _isNil2.default)(activePoint))
                return [graphicalItem].concat(_toConsumableArray(_this.renderActivePoints({
                  item,
                  activePoint,
                  basePoint,
                  childIndex: activeTooltipIndex,
                  isRange
                })));
            }
            return isRange ? [graphicalItem, null, null] : [graphicalItem, null];
          }, _this.renderCustomized = function(element, displayName, index) {
            return /* @__PURE__ */ (0, _react.cloneElement)(element, _objectSpread3(_objectSpread3({
              key: "recharts-customized-".concat(index)
            }, _this.props), _this.state));
          }, _this.uniqueChartId = (0, _isNil2.default)(_props.id) ? (0, _DataUtils.uniqueId)("recharts") : _props.id, _this.clipPathId = "".concat(_this.uniqueChartId, "-clip"), _props.throttleDelay && (_this.triggeredAfterMouseMove = (0, _throttle2.default)(_this.triggeredAfterMouseMove, _props.throttleDelay)), _this.state = {}, _this;
        }
        return _createClass(CategoricalChartWrapper, [{
          key: "componentDidMount",
          value: function() {
            (0, _isNil2.default)(this.props.syncId) || this.addListener();
          }
        }, {
          key: "componentDidUpdate",
          value: function(prevProps) {
            (0, _isNil2.default)(prevProps.syncId) && !(0, _isNil2.default)(this.props.syncId) && this.addListener(), !(0, _isNil2.default)(prevProps.syncId) && (0, _isNil2.default)(this.props.syncId) && this.removeListener();
          }
        }, {
          key: "componentWillUnmount",
          value: function() {
            this.clearDeferId(), (0, _isNil2.default)(this.props.syncId) || this.removeListener(), this.cancelThrottledTriggerAfterMouseMove();
          }
        }, {
          key: "cancelThrottledTriggerAfterMouseMove",
          value: function() {
            typeof this.triggeredAfterMouseMove.cancel == "function" && this.triggeredAfterMouseMove.cancel();
          }
        }, {
          key: "getTooltipEventType",
          value: function() {
            var tooltipItem = (0, _ReactUtils.findChildByType)(this.props.children, _Tooltip.Tooltip.displayName);
            if (tooltipItem && (0, _isBoolean2.default)(tooltipItem.props.shared)) {
              var eventType = tooltipItem.props.shared ? "axis" : "item";
              return validateTooltipEventTypes.indexOf(eventType) >= 0 ? eventType : defaultTooltipEventType;
            }
            return defaultTooltipEventType;
          }
        }, {
          key: "getMouseInfo",
          value: function(event) {
            if (!this.container)
              return null;
            var containerOffset = (0, _DOMUtils.getOffset)(this.container), e = (0, _DOMUtils.calculateChartCoordinate)(event, containerOffset), rangeObj = this.inRange(e.chartX, e.chartY);
            if (!rangeObj)
              return null;
            var _this$state9 = this.state, xAxisMap = _this$state9.xAxisMap, yAxisMap = _this$state9.yAxisMap, tooltipEventType = this.getTooltipEventType();
            if (tooltipEventType !== "axis" && xAxisMap && yAxisMap) {
              var xScale = (0, _DataUtils.getAnyElementOfObject)(xAxisMap).scale, yScale = (0, _DataUtils.getAnyElementOfObject)(yAxisMap).scale, xValue = xScale && xScale.invert ? xScale.invert(e.chartX) : null, yValue = yScale && yScale.invert ? yScale.invert(e.chartY) : null;
              return _objectSpread3(_objectSpread3({}, e), {}, {
                xValue,
                yValue
              });
            }
            var toolTipData = getTooltipData(this.state, this.props.data, this.props.layout, rangeObj);
            return toolTipData ? _objectSpread3(_objectSpread3({}, e), toolTipData) : null;
          }
        }, {
          key: "getCursorRectangle",
          value: function() {
            var layout = this.props.layout, _this$state10 = this.state, activeCoordinate = _this$state10.activeCoordinate, offset = _this$state10.offset, tooltipAxisBandSize = _this$state10.tooltipAxisBandSize, halfSize = tooltipAxisBandSize / 2;
            return {
              stroke: "none",
              fill: "#ccc",
              x: layout === "horizontal" ? activeCoordinate.x - halfSize : offset.left + 0.5,
              y: layout === "horizontal" ? offset.top + 0.5 : activeCoordinate.y - halfSize,
              width: layout === "horizontal" ? tooltipAxisBandSize : offset.width - 1,
              height: layout === "horizontal" ? offset.height - 1 : tooltipAxisBandSize
            };
          }
        }, {
          key: "getCursorPoints",
          value: function() {
            var layout = this.props.layout, _this$state11 = this.state, activeCoordinate = _this$state11.activeCoordinate, offset = _this$state11.offset, x1, y1, x2, y2;
            if (layout === "horizontal")
              x1 = activeCoordinate.x, x2 = x1, y1 = offset.top, y2 = offset.top + offset.height;
            else if (layout === "vertical")
              y1 = activeCoordinate.y, y2 = y1, x1 = offset.left, x2 = offset.left + offset.width;
            else if (!(0, _isNil2.default)(activeCoordinate.cx) || !(0, _isNil2.default)(activeCoordinate.cy))
              if (layout === "centric") {
                var cx = activeCoordinate.cx, cy = activeCoordinate.cy, innerRadius = activeCoordinate.innerRadius, outerRadius = activeCoordinate.outerRadius, angle = activeCoordinate.angle, innerPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, innerRadius, angle), outerPoint = (0, _PolarUtils.polarToCartesian)(cx, cy, outerRadius, angle);
                x1 = innerPoint.x, y1 = innerPoint.y, x2 = outerPoint.x, y2 = outerPoint.y;
              } else {
                var _cx = activeCoordinate.cx, _cy = activeCoordinate.cy, radius = activeCoordinate.radius, startAngle = activeCoordinate.startAngle, endAngle = activeCoordinate.endAngle, startPoint = (0, _PolarUtils.polarToCartesian)(_cx, _cy, radius, startAngle), endPoint = (0, _PolarUtils.polarToCartesian)(_cx, _cy, radius, endAngle);
                return {
                  points: [startPoint, endPoint],
                  cx: _cx,
                  cy: _cy,
                  radius,
                  startAngle,
                  endAngle
                };
              }
            return [{
              x: x1,
              y: y1
            }, {
              x: x2,
              y: y2
            }];
          }
        }, {
          key: "inRange",
          value: function(x, y) {
            var layout = this.props.layout;
            if (layout === "horizontal" || layout === "vertical") {
              var offset = this.state.offset, isInRange = x >= offset.left && x <= offset.left + offset.width && y >= offset.top && y <= offset.top + offset.height;
              return isInRange ? {
                x,
                y
              } : null;
            }
            var _this$state12 = this.state, angleAxisMap = _this$state12.angleAxisMap, radiusAxisMap = _this$state12.radiusAxisMap;
            if (angleAxisMap && radiusAxisMap) {
              var angleAxis = (0, _DataUtils.getAnyElementOfObject)(angleAxisMap);
              return (0, _PolarUtils.inRangeOfSector)({
                x,
                y
              }, angleAxis);
            }
            return null;
          }
        }, {
          key: "parseEventsOfWrapper",
          value: function() {
            var children = this.props.children, tooltipEventType = this.getTooltipEventType(), tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip.displayName), tooltipEvents = {};
            tooltipItem && tooltipEventType === "axis" && (tooltipItem.props.trigger === "click" ? tooltipEvents = {
              onClick: this.handleClick
            } : tooltipEvents = {
              onMouseEnter: this.handleMouseEnter,
              onMouseMove: this.handleMouseMove,
              onMouseLeave: this.handleMouseLeave,
              onTouchMove: this.handleTouchMove,
              onTouchStart: this.handleTouchStart,
              onTouchEnd: this.handleTouchEnd
            });
            var outerEvents = (0, _types.adaptEventHandlers)(this.props, this.handleOuterEvent);
            return _objectSpread3(_objectSpread3({}, outerEvents), tooltipEvents);
          }
        }, {
          key: "addListener",
          value: function() {
            _Events.eventCenter.on(_Events.SYNC_EVENT, this.handleReceiveSyncEvent), _Events.eventCenter.setMaxListeners && _Events.eventCenter._maxListeners && _Events.eventCenter.setMaxListeners(_Events.eventCenter._maxListeners + 1);
          }
        }, {
          key: "removeListener",
          value: function() {
            _Events.eventCenter.removeListener(_Events.SYNC_EVENT, this.handleReceiveSyncEvent), _Events.eventCenter.setMaxListeners && _Events.eventCenter._maxListeners && _Events.eventCenter.setMaxListeners(_Events.eventCenter._maxListeners - 1);
          }
        }, {
          key: "triggerSyncEvent",
          value: function(data) {
            var syncId = this.props.syncId;
            (0, _isNil2.default)(syncId) || _Events.eventCenter.emit(_Events.SYNC_EVENT, syncId, this.uniqueChartId, data);
          }
        }, {
          key: "applySyncEvent",
          value: function(data) {
            var _this$props4 = this.props, layout = _this$props4.layout, syncMethod = _this$props4.syncMethod, updateId = this.state.updateId, dataStartIndex = data.dataStartIndex, dataEndIndex = data.dataEndIndex;
            if (!(0, _isNil2.default)(data.dataStartIndex) || !(0, _isNil2.default)(data.dataEndIndex))
              this.setState(_objectSpread3({
                dataStartIndex,
                dataEndIndex
              }, updateStateOfAxisMapsOffsetAndStackGroups({
                props: this.props,
                dataStartIndex,
                dataEndIndex,
                updateId
              }, this.state)));
            else if ((0, _isNil2.default)(data.activeTooltipIndex))
              this.setState(data);
            else {
              var chartX = data.chartX, chartY = data.chartY, activeTooltipIndex = data.activeTooltipIndex, _this$state13 = this.state, offset = _this$state13.offset, tooltipTicks = _this$state13.tooltipTicks;
              if (!offset)
                return;
              if (typeof syncMethod == "function")
                activeTooltipIndex = syncMethod(tooltipTicks, data);
              else if (syncMethod === "value") {
                activeTooltipIndex = -1;
                for (var i = 0; i < tooltipTicks.length; i++)
                  if (tooltipTicks[i].value === data.activeLabel) {
                    activeTooltipIndex = i;
                    break;
                  }
              }
              var viewBox = _objectSpread3(_objectSpread3({}, offset), {}, {
                x: offset.left,
                y: offset.top
              }), validateChartX = Math.min(chartX, viewBox.x + viewBox.width), validateChartY = Math.min(chartY, viewBox.y + viewBox.height), activeLabel = tooltipTicks[activeTooltipIndex] && tooltipTicks[activeTooltipIndex].value, activePayload = getTooltipContent(this.state, this.props.data, activeTooltipIndex), activeCoordinate = tooltipTicks[activeTooltipIndex] ? {
                x: layout === "horizontal" ? tooltipTicks[activeTooltipIndex].coordinate : validateChartX,
                y: layout === "horizontal" ? validateChartY : tooltipTicks[activeTooltipIndex].coordinate
              } : originCoordinate;
              this.setState(_objectSpread3(_objectSpread3({}, data), {}, {
                activeLabel,
                activeCoordinate,
                activePayload,
                activeTooltipIndex
              }));
            }
          }
        }, {
          key: "filterFormatItem",
          value: function(item, displayName, childIndex) {
            for (var formattedGraphicalItems = this.state.formattedGraphicalItems, i = 0, len = formattedGraphicalItems.length; i < len; i++) {
              var entry2 = formattedGraphicalItems[i];
              if (entry2.item === item || entry2.props.key === item.key || displayName === (0, _ReactUtils.getDisplayName)(entry2.item.type) && childIndex === entry2.childIndex)
                return entry2;
            }
            return null;
          }
        }, {
          key: "renderAxis",
          value: function(axisOptions, element, displayName, index) {
            var _this$props5 = this.props, width = _this$props5.width, height = _this$props5.height;
            return /* @__PURE__ */ _react.default.createElement(_CartesianAxis.CartesianAxis, _extends({}, axisOptions, {
              className: "recharts-".concat(axisOptions.axisType, " ").concat(axisOptions.axisType),
              key: element.key || "".concat(displayName, "-").concat(index),
              viewBox: {
                x: 0,
                y: 0,
                width,
                height
              },
              ticksGenerator: this.axesTicksGenerator
            }));
          }
        }, {
          key: "renderClipPath",
          value: function() {
            var clipPathId = this.clipPathId, _this$state$offset = this.state.offset, left = _this$state$offset.left, top = _this$state$offset.top, height = _this$state$offset.height, width = _this$state$offset.width;
            return /* @__PURE__ */ _react.default.createElement("defs", null, /* @__PURE__ */ _react.default.createElement("clipPath", {
              id: clipPathId
            }, /* @__PURE__ */ _react.default.createElement("rect", {
              x: left,
              y: top,
              height,
              width
            })));
          }
        }, {
          key: "getXScales",
          value: function() {
            var xAxisMap = this.state.xAxisMap;
            return xAxisMap ? Object.entries(xAxisMap).reduce(function(res, _ref13) {
              var _ref14 = _slicedToArray(_ref13, 2), axisId = _ref14[0], axisProps = _ref14[1];
              return _objectSpread3(_objectSpread3({}, res), {}, _defineProperty3({}, axisId, axisProps.scale));
            }, {}) : null;
          }
        }, {
          key: "getYScales",
          value: function() {
            var yAxisMap = this.state.yAxisMap;
            return yAxisMap ? Object.entries(yAxisMap).reduce(function(res, _ref15) {
              var _ref16 = _slicedToArray(_ref15, 2), axisId = _ref16[0], axisProps = _ref16[1];
              return _objectSpread3(_objectSpread3({}, res), {}, _defineProperty3({}, axisId, axisProps.scale));
            }, {}) : null;
          }
        }, {
          key: "getXScaleByAxisId",
          value: function(axisId) {
            var _this$state$xAxisMap, _this$state$xAxisMap$;
            return (_this$state$xAxisMap = this.state.xAxisMap) === null || _this$state$xAxisMap === void 0 || (_this$state$xAxisMap$ = _this$state$xAxisMap[axisId]) === null || _this$state$xAxisMap$ === void 0 ? void 0 : _this$state$xAxisMap$.scale;
          }
        }, {
          key: "getYScaleByAxisId",
          value: function(axisId) {
            var _this$state$yAxisMap, _this$state$yAxisMap$;
            return (_this$state$yAxisMap = this.state.yAxisMap) === null || _this$state$yAxisMap === void 0 || (_this$state$yAxisMap$ = _this$state$yAxisMap[axisId]) === null || _this$state$yAxisMap$ === void 0 ? void 0 : _this$state$yAxisMap$.scale;
          }
        }, {
          key: "getItemByXY",
          value: function(chartXY) {
            var formattedGraphicalItems = this.state.formattedGraphicalItems;
            if (formattedGraphicalItems && formattedGraphicalItems.length)
              for (var i = 0, len = formattedGraphicalItems.length; i < len; i++) {
                var graphicalItem = formattedGraphicalItems[i], props = graphicalItem.props, item = graphicalItem.item, itemDisplayName = (0, _ReactUtils.getDisplayName)(item.type);
                if (itemDisplayName === "Bar") {
                  var activeBarItem = (props.data || []).find(function(entry2) {
                    return (0, _Rectangle.isInRectangle)(chartXY, entry2);
                  });
                  if (activeBarItem)
                    return {
                      graphicalItem,
                      payload: activeBarItem
                    };
                } else if (itemDisplayName === "RadialBar") {
                  var _activeBarItem = (props.data || []).find(function(entry2) {
                    return (0, _PolarUtils.inRangeOfSector)(chartXY, entry2);
                  });
                  if (_activeBarItem)
                    return {
                      graphicalItem,
                      payload: _activeBarItem
                    };
                }
              }
            return null;
          }
        }, {
          key: "render",
          value: function() {
            var _this2 = this;
            if (!(0, _ReactUtils.validateWidthHeight)(this))
              return null;
            var _this$props6 = this.props, children = _this$props6.children, className = _this$props6.className, width = _this$props6.width, height = _this$props6.height, style = _this$props6.style, compact = _this$props6.compact, title = _this$props6.title, desc = _this$props6.desc, others = _objectWithoutProperties2(_this$props6, ["children", "className", "width", "height", "style", "compact", "title", "desc"]), attrs = (0, _types.filterProps)(others), map = {
              CartesianGrid: {
                handler: this.renderGrid,
                once: !0
              },
              ReferenceArea: {
                handler: this.renderReferenceElement
              },
              ReferenceLine: {
                handler: this.renderReferenceElement
              },
              ReferenceDot: {
                handler: this.renderReferenceElement
              },
              XAxis: {
                handler: this.renderXAxis
              },
              YAxis: {
                handler: this.renderYAxis
              },
              Brush: {
                handler: this.renderBrush,
                once: !0
              },
              Bar: {
                handler: this.renderGraphicChild
              },
              Line: {
                handler: this.renderGraphicChild
              },
              Area: {
                handler: this.renderGraphicChild
              },
              Radar: {
                handler: this.renderGraphicChild
              },
              RadialBar: {
                handler: this.renderGraphicChild
              },
              Scatter: {
                handler: this.renderGraphicChild
              },
              Pie: {
                handler: this.renderGraphicChild
              },
              Funnel: {
                handler: this.renderGraphicChild
              },
              Tooltip: {
                handler: this.renderCursor,
                once: !0
              },
              PolarGrid: {
                handler: this.renderPolarGrid,
                once: !0
              },
              PolarAngleAxis: {
                handler: this.renderPolarAxis
              },
              PolarRadiusAxis: {
                handler: this.renderPolarAxis
              },
              Customized: {
                handler: this.renderCustomized
              }
            };
            if (compact)
              return /* @__PURE__ */ _react.default.createElement(_Surface.Surface, _extends({}, attrs, {
                width,
                height,
                title,
                desc
              }), this.renderClipPath(), (0, _ReactUtils.renderByOrder)(children, map));
            var events = this.parseEventsOfWrapper();
            return /* @__PURE__ */ _react.default.createElement("div", _extends({
              className: (0, _classnames.default)("recharts-wrapper", className),
              style: _objectSpread3({
                position: "relative",
                cursor: "default",
                width,
                height
              }, style)
            }, events, {
              ref: function(node) {
                _this2.container = node;
              },
              role: "region"
            }), /* @__PURE__ */ _react.default.createElement(_Surface.Surface, _extends({}, attrs, {
              width,
              height,
              title,
              desc
            }), this.renderClipPath(), (0, _ReactUtils.renderByOrder)(children, map)), this.renderLegend(), this.renderTooltip());
          }
        }]), CategoricalChartWrapper;
      }(_react.Component), _class.displayName = chartName, _class.defaultProps = _objectSpread3({
        layout: "horizontal",
        stackOffset: "none",
        barCategoryGap: "10%",
        barGap: 4,
        margin: {
          top: 5,
          right: 5,
          bottom: 5,
          left: 5
        },
        reverseStackOrder: !1,
        syncMethod: "index"
      }, defaultProps), _class.getDerivedStateFromProps = function(nextProps, prevState) {
        var data = nextProps.data, children = nextProps.children, width = nextProps.width, height = nextProps.height, layout = nextProps.layout, stackOffset = nextProps.stackOffset, margin = nextProps.margin;
        if ((0, _isNil2.default)(prevState.updateId)) {
          var defaultState = createDefaultState(nextProps);
          return _objectSpread3(_objectSpread3(_objectSpread3({}, defaultState), {}, {
            updateId: 0
          }, updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread3(_objectSpread3({
            props: nextProps
          }, defaultState), {}, {
            updateId: 0
          }), prevState)), {}, {
            prevData: data,
            prevWidth: width,
            prevHeight: height,
            prevLayout: layout,
            prevStackOffset: stackOffset,
            prevMargin: margin,
            prevChildren: children
          });
        }
        if (data !== prevState.prevData || width !== prevState.prevWidth || height !== prevState.prevHeight || layout !== prevState.prevLayout || stackOffset !== prevState.prevStackOffset || !(0, _ShallowEqual.shallowEqual)(margin, prevState.prevMargin)) {
          var _defaultState = createDefaultState(nextProps), keepFromPrevState = {
            chartX: prevState.chartX,
            chartY: prevState.chartY,
            isTooltipActive: prevState.isTooltipActive
          }, updatesToState = _objectSpread3(_objectSpread3({}, getTooltipData(prevState, data, layout)), {}, {
            updateId: prevState.updateId + 1
          }), newState = _objectSpread3(_objectSpread3(_objectSpread3({}, _defaultState), keepFromPrevState), updatesToState);
          return _objectSpread3(_objectSpread3(_objectSpread3({}, newState), updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread3({
            props: nextProps
          }, newState), prevState)), {}, {
            prevData: data,
            prevWidth: width,
            prevHeight: height,
            prevLayout: layout,
            prevStackOffset: stackOffset,
            prevMargin: margin,
            prevChildren: children
          });
        }
        if (!(0, _ReactUtils.isChildrenEqual)(children, prevState.prevChildren)) {
          var hasGlobalData = !(0, _isNil2.default)(data), newUpdateId = hasGlobalData ? prevState.updateId : prevState.updateId + 1;
          return _objectSpread3(_objectSpread3({
            updateId: newUpdateId
          }, updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread3(_objectSpread3({
            props: nextProps
          }, prevState), {}, {
            updateId: newUpdateId
          }), prevState)), {}, {
            prevChildren: children
          });
        }
        return null;
      }, _class.renderActiveDot = function(option, props) {
        var dot;
        return /* @__PURE__ */ (0, _react.isValidElement)(option) ? dot = /* @__PURE__ */ (0, _react.cloneElement)(option, props) : (0, _isFunction2.default)(option) ? dot = option(props) : dot = /* @__PURE__ */ _react.default.createElement(_Dot.Dot, props), /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
          className: "recharts-active-dot",
          key: props.key
        }, dot);
      }, _temp;
    };
    exports.generateCategoricalChart = generateCategoricalChart;
  }
});

// node_modules/recharts/lib/chart/LineChart.js
var require_LineChart = __commonJS({
  "node_modules/recharts/lib/chart/LineChart.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.LineChart = void 0;
    var _generateCategoricalChart = require_generateCategoricalChart(), _Line = require_Line(), _XAxis = require_XAxis(), _YAxis = require_YAxis(), _CartesianUtils = require_CartesianUtils(), LineChart = (0, _generateCategoricalChart.generateCategoricalChart)({
      chartName: "LineChart",
      GraphicalChild: _Line.Line,
      axisComponents: [{
        axisType: "xAxis",
        AxisComp: _XAxis.XAxis
      }, {
        axisType: "yAxis",
        AxisComp: _YAxis.YAxis
      }],
      formatAxisMap: _CartesianUtils.formatAxisMap
    });
    exports.LineChart = LineChart;
  }
});

// node_modules/recharts/lib/chart/BarChart.js
var require_BarChart = __commonJS({
  "node_modules/recharts/lib/chart/BarChart.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.BarChart = void 0;
    var _generateCategoricalChart = require_generateCategoricalChart(), _Bar = require_Bar(), _XAxis = require_XAxis(), _YAxis = require_YAxis(), _CartesianUtils = require_CartesianUtils(), BarChart = (0, _generateCategoricalChart.generateCategoricalChart)({
      chartName: "BarChart",
      GraphicalChild: _Bar.Bar,
      defaultTooltipEventType: "axis",
      validateTooltipEventTypes: ["axis", "item"],
      axisComponents: [{
        axisType: "xAxis",
        AxisComp: _XAxis.XAxis
      }, {
        axisType: "yAxis",
        AxisComp: _YAxis.YAxis
      }],
      formatAxisMap: _CartesianUtils.formatAxisMap
    });
    exports.BarChart = BarChart;
  }
});

// node_modules/recharts/lib/chart/PieChart.js
var require_PieChart = __commonJS({
  "node_modules/recharts/lib/chart/PieChart.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.PieChart = void 0;
    var _generateCategoricalChart = require_generateCategoricalChart(), _PolarAngleAxis = require_PolarAngleAxis(), _PolarRadiusAxis = require_PolarRadiusAxis(), _PolarUtils = require_PolarUtils(), _Pie = require_Pie(), PieChart = (0, _generateCategoricalChart.generateCategoricalChart)({
      chartName: "PieChart",
      GraphicalChild: _Pie.Pie,
      validateTooltipEventTypes: ["item"],
      defaultTooltipEventType: "item",
      legendContent: "children",
      axisComponents: [{
        axisType: "angleAxis",
        AxisComp: _PolarAngleAxis.PolarAngleAxis
      }, {
        axisType: "radiusAxis",
        AxisComp: _PolarRadiusAxis.PolarRadiusAxis
      }],
      formatAxisMap: _PolarUtils.formatAxisMap,
      defaultProps: {
        layout: "centric",
        startAngle: 0,
        endAngle: 360,
        cx: "50%",
        cy: "50%",
        innerRadius: 0,
        outerRadius: "80%"
      }
    });
    exports.PieChart = PieChart;
  }
});

// node_modules/recharts/lib/util/Constants.js
var require_Constants = __commonJS({
  "node_modules/recharts/lib/util/Constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.COLOR_PANEL = void 0;
    var COLOR_PANEL = ["#1890FF", "#66B5FF", "#41D9C7", "#2FC25B", "#6EDB8F", "#9AE65C", "#FACC14", "#E6965C", "#57AD71", "#223273", "#738AE6", "#7564CC", "#8543E0", "#A877ED", "#5C8EE6", "#13C2C2", "#70E0E0", "#5CA3E6", "#3436C7", "#8082FF", "#DD81E6", "#F04864", "#FA7D92", "#D598D9"];
    exports.COLOR_PANEL = COLOR_PANEL;
  }
});

// node_modules/recharts/lib/chart/Treemap.js
var require_Treemap = __commonJS({
  "node_modules/recharts/lib/chart/Treemap.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Treemap = void 0;
    var _get2 = _interopRequireDefault(require("lodash/get")), _omit2 = _interopRequireDefault(require("lodash/omit")), _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _isNaN2 = _interopRequireDefault(require("lodash/isNaN")), _classnames = _interopRequireDefault(require("classnames")), _react = _interopRequireWildcard(require("react")), _reactSmooth = _interopRequireDefault(require("react-smooth")), _Tooltip = require_Tooltip(), _Layer = require_Layer(), _Surface = require_Surface(), _Polygon = require_Polygon(), _Rectangle = require_Rectangle(), _ChartUtils = require_ChartUtils(), _Constants = require_Constants(), _DataUtils = require_DataUtils(), _DOMUtils = require_DOMUtils(), _Global = require_Global(), _ReactUtils = require_ReactUtils(), _types = require_types();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose2(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source, key) || (target[key] = source[key]));
      }
      return target;
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    var NODE_VALUE_KEY = "value", computeNode = function computeNode2(_ref) {
      var _objectSpread22, depth = _ref.depth, node = _ref.node, index = _ref.index, valueKey = _ref.valueKey, children = node.children, childDepth = depth + 1, computedChildren = children && children.length ? children.map(function(child, i) {
        return computeNode2({
          depth: childDepth,
          node: child,
          index: i,
          valueKey
        });
      }) : null, nodeValue;
      return children && children.length ? nodeValue = computedChildren.reduce(function(result, child) {
        return result + child[NODE_VALUE_KEY];
      }, 0) : nodeValue = (0, _isNaN2.default)(node[valueKey]) || node[valueKey] <= 0 ? 0 : node[valueKey], _objectSpread3(_objectSpread3({}, node), {}, (_objectSpread22 = {
        children: computedChildren
      }, _defineProperty3(_objectSpread22, NODE_VALUE_KEY, nodeValue), _defineProperty3(_objectSpread22, "depth", depth), _defineProperty3(_objectSpread22, "index", index), _objectSpread22));
    }, filterRect = function(node) {
      return {
        x: node.x,
        y: node.y,
        width: node.width,
        height: node.height
      };
    }, getAreaOfChildren = function(children, areaValueRatio) {
      var ratio = areaValueRatio < 0 ? 0 : areaValueRatio;
      return children.map(function(child) {
        var area = child[NODE_VALUE_KEY] * ratio;
        return _objectSpread3(_objectSpread3({}, child), {}, {
          area: (0, _isNaN2.default)(area) || area <= 0 ? 0 : area
        });
      });
    }, getWorstScore = function(row, parentSize, aspectRatio) {
      var parentArea = parentSize * parentSize, rowArea = row.area * row.area, _row$reduce = row.reduce(function(result, child) {
        return {
          min: Math.min(result.min, child.area),
          max: Math.max(result.max, child.area)
        };
      }, {
        min: 1 / 0,
        max: 0
      }), min = _row$reduce.min, max = _row$reduce.max;
      return rowArea ? Math.max(parentArea * max * aspectRatio / rowArea, rowArea / (parentArea * min * aspectRatio)) : 1 / 0;
    }, horizontalPosition = function(row, parentSize, parentRect, isFlush) {
      var rowHeight = parentSize ? Math.round(row.area / parentSize) : 0;
      (isFlush || rowHeight > parentRect.height) && (rowHeight = parentRect.height);
      for (var curX = parentRect.x, child, _i = 0, len = row.length; _i < len; _i++)
        child = row[_i], child.x = curX, child.y = parentRect.y, child.height = rowHeight, child.width = Math.min(rowHeight ? Math.round(child.area / rowHeight) : 0, parentRect.x + parentRect.width - curX), curX += child.width;
      return child.z = !0, child.width += parentRect.x + parentRect.width - curX, _objectSpread3(_objectSpread3({}, parentRect), {}, {
        y: parentRect.y + rowHeight,
        height: parentRect.height - rowHeight
      });
    }, verticalPosition = function(row, parentSize, parentRect, isFlush) {
      var rowWidth = parentSize ? Math.round(row.area / parentSize) : 0;
      (isFlush || rowWidth > parentRect.width) && (rowWidth = parentRect.width);
      for (var curY = parentRect.y, child, _i2 = 0, len = row.length; _i2 < len; _i2++)
        child = row[_i2], child.x = parentRect.x, child.y = curY, child.width = rowWidth, child.height = Math.min(rowWidth ? Math.round(child.area / rowWidth) : 0, parentRect.y + parentRect.height - curY), curY += child.height;
      return child && (child.z = !1, child.height += parentRect.y + parentRect.height - curY), _objectSpread3(_objectSpread3({}, parentRect), {}, {
        x: parentRect.x + rowWidth,
        width: parentRect.width - rowWidth
      });
    }, position = function(row, parentSize, parentRect, isFlush) {
      return parentSize === parentRect.width ? horizontalPosition(row, parentSize, parentRect, isFlush) : verticalPosition(row, parentSize, parentRect, isFlush);
    }, squarify = function squarify2(node, aspectRatio) {
      var children = node.children;
      if (children && children.length) {
        var rect = filterRect(node), row = [], best = 1 / 0, child, score, size = Math.min(rect.width, rect.height), scaleChildren = getAreaOfChildren(children, rect.width * rect.height / node[NODE_VALUE_KEY]), tempChildren = scaleChildren.slice();
        for (row.area = 0; tempChildren.length > 0; )
          row.push(child = tempChildren[0]), row.area += child.area, score = getWorstScore(row, size, aspectRatio), score <= best ? (tempChildren.shift(), best = score) : (row.area -= row.pop().area, rect = position(row, size, rect, !1), size = Math.min(rect.width, rect.height), row.length = row.area = 0, best = 1 / 0);
        return row.length && (rect = position(row, size, rect, !0), row.length = row.area = 0), _objectSpread3(_objectSpread3({}, node), {}, {
          children: scaleChildren.map(function(c) {
            return squarify2(c, aspectRatio);
          })
        });
      }
      return node;
    }, defaultState = {
      isTooltipActive: !1,
      isAnimationFinished: !1,
      activeNode: null,
      formatRoot: null,
      currentRoot: null,
      nestIndex: []
    }, Treemap = /* @__PURE__ */ function(_PureComponent) {
      _inherits(Treemap2, _PureComponent);
      var _super = _createSuper(Treemap2);
      function Treemap2() {
        var _this;
        _classCallCheck(this, Treemap2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        return _this = _super.call.apply(_super, [this].concat(args)), _this.state = _objectSpread3({}, defaultState), _this.handleAnimationEnd = function() {
          var onAnimationEnd = _this.props.onAnimationEnd;
          _this.setState({
            isAnimationFinished: !0
          }), (0, _isFunction2.default)(onAnimationEnd) && onAnimationEnd();
        }, _this.handleAnimationStart = function() {
          var onAnimationStart = _this.props.onAnimationStart;
          _this.setState({
            isAnimationFinished: !1
          }), (0, _isFunction2.default)(onAnimationStart) && onAnimationStart();
        }, _this;
      }
      return _createClass(Treemap2, [{
        key: "handleMouseEnter",
        value: function(node, e) {
          var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, children = _this$props.children, tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip.displayName);
          tooltipItem ? this.setState({
            isTooltipActive: !0,
            activeNode: node
          }, function() {
            onMouseEnter && onMouseEnter(node, e);
          }) : onMouseEnter && onMouseEnter(node, e);
        }
      }, {
        key: "handleMouseLeave",
        value: function(node, e) {
          var _this$props2 = this.props, onMouseLeave = _this$props2.onMouseLeave, children = _this$props2.children, tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip.displayName);
          tooltipItem ? this.setState({
            isTooltipActive: !1,
            activeNode: null
          }, function() {
            onMouseLeave && onMouseLeave(node, e);
          }) : onMouseLeave && onMouseLeave(node, e);
        }
      }, {
        key: "handleClick",
        value: function(node) {
          var _this$props3 = this.props, onClick = _this$props3.onClick, type = _this$props3.type;
          if (type === "nest" && node.children) {
            var _this$props4 = this.props, width = _this$props4.width, height = _this$props4.height, dataKey = _this$props4.dataKey, aspectRatio = _this$props4.aspectRatio, root = computeNode({
              depth: 0,
              node: _objectSpread3(_objectSpread3({}, node), {}, {
                x: 0,
                y: 0,
                width,
                height
              }),
              index: 0,
              valueKey: dataKey
            }), formatRoot = squarify(root, aspectRatio), nestIndex = this.state.nestIndex;
            nestIndex.push(node), this.setState({
              formatRoot,
              currentRoot: root,
              nestIndex
            });
          }
          onClick && onClick(node);
        }
      }, {
        key: "handleNestIndex",
        value: function(node, i) {
          var nestIndex = this.state.nestIndex, _this$props5 = this.props, width = _this$props5.width, height = _this$props5.height, dataKey = _this$props5.dataKey, aspectRatio = _this$props5.aspectRatio, root = computeNode({
            depth: 0,
            node: _objectSpread3(_objectSpread3({}, node), {}, {
              x: 0,
              y: 0,
              width,
              height
            }),
            index: 0,
            valueKey: dataKey
          }), formatRoot = squarify(root, aspectRatio);
          nestIndex = nestIndex.slice(0, i + 1), this.setState({
            formatRoot,
            currentRoot: node,
            nestIndex
          });
        }
      }, {
        key: "renderItem",
        value: function(content, nodeProps, isLeaf) {
          var _this2 = this, _this$props6 = this.props, isAnimationActive = _this$props6.isAnimationActive, animationBegin = _this$props6.animationBegin, animationDuration = _this$props6.animationDuration, animationEasing = _this$props6.animationEasing, isUpdateAnimationActive = _this$props6.isUpdateAnimationActive, type = _this$props6.type, animationId = _this$props6.animationId, colorPanel = _this$props6.colorPanel, isAnimationFinished = this.state.isAnimationFinished, width = nodeProps.width, height = nodeProps.height, x = nodeProps.x, y = nodeProps.y, depth = nodeProps.depth, translateX = parseInt("".concat((Math.random() * 2 - 1) * width), 10), event = {};
          return (isLeaf || type === "nest") && (event = {
            onMouseEnter: this.handleMouseEnter.bind(this, nodeProps),
            onMouseLeave: this.handleMouseLeave.bind(this, nodeProps),
            onClick: this.handleClick.bind(this, nodeProps)
          }), isAnimationActive ? /* @__PURE__ */ _react.default.createElement(_reactSmooth.default, {
            begin: animationBegin,
            duration: animationDuration,
            isActive: isAnimationActive,
            easing: animationEasing,
            key: "treemap-".concat(animationId),
            from: {
              x,
              y,
              width,
              height
            },
            to: {
              x,
              y,
              width,
              height
            },
            onAnimationStart: this.handleAnimationStart,
            onAnimationEnd: this.handleAnimationEnd
          }, function(_ref2) {
            var currX = _ref2.x, currY = _ref2.y, currWidth = _ref2.width, currHeight = _ref2.height;
            return /* @__PURE__ */ _react.default.createElement(_reactSmooth.default, {
              from: "translate(".concat(translateX, "px, ").concat(translateX, "px)"),
              to: "translate(0, 0)",
              attributeName: "transform",
              begin: animationBegin,
              easing: animationEasing,
              isActive: isAnimationActive,
              duration: animationDuration
            }, /* @__PURE__ */ _react.default.createElement(_Layer.Layer, event, function() {
              return depth > 2 && !isAnimationFinished ? null : _this2.constructor.renderContentItem(content, _objectSpread3(_objectSpread3({}, nodeProps), {}, {
                isAnimationActive,
                isUpdateAnimationActive: !isUpdateAnimationActive,
                width: currWidth,
                height: currHeight,
                x: currX,
                y: currY
              }), type, colorPanel);
            }()));
          }) : /* @__PURE__ */ _react.default.createElement(_Layer.Layer, event, this.constructor.renderContentItem(content, _objectSpread3(_objectSpread3({}, nodeProps), {}, {
            isAnimationActive: !1,
            isUpdateAnimationActive: !1,
            width,
            height,
            x,
            y
          }), type, colorPanel));
        }
      }, {
        key: "renderNode",
        value: function(root, node, i) {
          var _this3 = this, _this$props7 = this.props, content = _this$props7.content, type = _this$props7.type, nodeProps = _objectSpread3(_objectSpread3(_objectSpread3({}, (0, _types.filterProps)(this.props)), node), {}, {
            root
          }), isLeaf = !node.children || !node.children.length, currentRoot = this.state.currentRoot, isCurrentRootChild = (currentRoot.children || []).filter(function(item) {
            return item.depth === node.depth && item.name === node.name;
          });
          return !isCurrentRootChild.length && root.depth && type === "nest" ? null : /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            key: "recharts-treemap-node-".concat(i),
            className: "recharts-treemap-depth-".concat(node.depth)
          }, this.renderItem(content, nodeProps, isLeaf), node.children && node.children.length ? node.children.map(function(child, index) {
            return _this3.renderNode(node, child, index);
          }) : null);
        }
      }, {
        key: "renderAllNodes",
        value: function() {
          var formatRoot = this.state.formatRoot;
          return formatRoot ? this.renderNode(formatRoot, formatRoot, 0) : null;
        }
      }, {
        key: "renderTooltip",
        value: function() {
          var _this$props8 = this.props, children = _this$props8.children, nameKey = _this$props8.nameKey, tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip.displayName);
          if (!tooltipItem)
            return null;
          var _this$props9 = this.props, width = _this$props9.width, height = _this$props9.height, _this$state = this.state, isTooltipActive = _this$state.isTooltipActive, activeNode = _this$state.activeNode, viewBox = {
            x: 0,
            y: 0,
            width,
            height
          }, coordinate = activeNode ? {
            x: activeNode.x + activeNode.width / 2,
            y: activeNode.y + activeNode.height / 2
          } : null, payload = isTooltipActive && activeNode ? [{
            payload: activeNode,
            name: (0, _ChartUtils.getValueByDataKey)(activeNode, nameKey, ""),
            value: (0, _ChartUtils.getValueByDataKey)(activeNode, NODE_VALUE_KEY)
          }] : [];
          return /* @__PURE__ */ _react.default.cloneElement(tooltipItem, {
            viewBox,
            active: isTooltipActive,
            coordinate,
            label: "",
            payload
          });
        }
      }, {
        key: "renderNestIndex",
        value: function() {
          var _this4 = this, _this$props10 = this.props, nameKey = _this$props10.nameKey, nestIndexContent = _this$props10.nestIndexContent, nestIndex = this.state.nestIndex;
          return /* @__PURE__ */ _react.default.createElement("div", {
            className: "recharts-treemap-nest-index-wrapper",
            style: {
              marginTop: "8px",
              textAlign: "center"
            }
          }, nestIndex.map(function(item, i) {
            var name = (0, _get2.default)(item, nameKey, "root"), content = null;
            return /* @__PURE__ */ _react.default.isValidElement(nestIndexContent) && (content = /* @__PURE__ */ _react.default.cloneElement(nestIndexContent, item, i)), (0, _isFunction2.default)(nestIndexContent) ? content = nestIndexContent(item, i) : content = name, /* @__PURE__ */ _react.default.createElement("div", {
              onClick: _this4.handleNestIndex.bind(_this4, item, i),
              key: "nest-index-".concat((0, _DataUtils.uniqueId)()),
              className: "recharts-treemap-nest-index-box",
              style: {
                cursor: "pointer",
                display: "inline-block",
                padding: "0 7px",
                background: "#000",
                color: "#fff",
                marginRight: "3px"
              }
            }, content);
          }));
        }
      }, {
        key: "render",
        value: function() {
          if (!(0, _ReactUtils.validateWidthHeight)(this))
            return null;
          var _this$props11 = this.props, width = _this$props11.width, height = _this$props11.height, className = _this$props11.className, style = _this$props11.style, children = _this$props11.children, type = _this$props11.type, others = _objectWithoutProperties2(_this$props11, ["width", "height", "className", "style", "children", "type"]), attrs = (0, _types.filterProps)(others);
          return /* @__PURE__ */ _react.default.createElement("div", {
            className: (0, _classnames.default)("recharts-wrapper", className),
            style: _objectSpread3(_objectSpread3({}, style), {}, {
              position: "relative",
              cursor: "default",
              width,
              height
            }),
            role: "region"
          }, /* @__PURE__ */ _react.default.createElement(_Surface.Surface, _extends({}, attrs, {
            width,
            height: type === "nest" ? height - 30 : height
          }), this.renderAllNodes(), (0, _ReactUtils.filterSvgElements)(children)), this.renderTooltip(), type === "nest" && this.renderNestIndex());
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function(nextProps, prevState) {
          if (nextProps.data !== prevState.prevData || nextProps.type !== prevState.prevType || nextProps.width !== prevState.prevWidth || nextProps.height !== prevState.prevHeight || nextProps.dataKey !== prevState.prevDataKey || nextProps.aspectRatio !== prevState.prevAspectRatio) {
            var root = computeNode({
              depth: 0,
              node: {
                children: nextProps.data,
                x: 0,
                y: 0,
                width: nextProps.width,
                height: nextProps.height
              },
              index: 0,
              valueKey: nextProps.dataKey
            }), formatRoot = squarify(root, nextProps.aspectRatio);
            return _objectSpread3(_objectSpread3({}, prevState), {}, {
              formatRoot,
              currentRoot: root,
              nestIndex: [root],
              prevAspectRatio: nextProps.aspectRatio,
              prevData: nextProps.data,
              prevWidth: nextProps.width,
              prevHeight: nextProps.height,
              prevDataKey: nextProps.dataKey,
              prevType: nextProps.type
            });
          }
          return null;
        }
      }, {
        key: "renderContentItem",
        value: function(content, nodeProps, type, colorPanel) {
          if (/* @__PURE__ */ _react.default.isValidElement(content))
            return /* @__PURE__ */ _react.default.cloneElement(content, nodeProps);
          if ((0, _isFunction2.default)(content))
            return content(nodeProps);
          var x = nodeProps.x, y = nodeProps.y, width = nodeProps.width, height = nodeProps.height, index = nodeProps.index, arrow = null;
          width > 10 && height > 10 && nodeProps.children && type === "nest" && (arrow = /* @__PURE__ */ _react.default.createElement(_Polygon.Polygon, {
            points: [{
              x: x + 2,
              y: y + height / 2
            }, {
              x: x + 6,
              y: y + height / 2 + 3
            }, {
              x: x + 2,
              y: y + height / 2 + 6
            }]
          }));
          var text = null, nameSize = (0, _DOMUtils.getStringSize)(nodeProps.name);
          width > 20 && height > 20 && nameSize.width < width && nameSize.height < height && (text = /* @__PURE__ */ _react.default.createElement("text", {
            x: x + 8,
            y: y + height / 2 + 7,
            fontSize: 14
          }, nodeProps.name));
          var colors = colorPanel || _Constants.COLOR_PANEL;
          return /* @__PURE__ */ _react.default.createElement("g", null, /* @__PURE__ */ _react.default.createElement(_Rectangle.Rectangle, _extends({
            fill: nodeProps.depth < 2 ? colors[index % colors.length] : "rgba(255,255,255,0)",
            stroke: "#fff"
          }, (0, _omit2.default)(nodeProps, "children"), {
            role: "img"
          })), arrow, text);
        }
      }]), Treemap2;
    }(_react.PureComponent);
    exports.Treemap = Treemap;
    Treemap.displayName = "Treemap";
    Treemap.defaultProps = {
      aspectRatio: 0.5 * (1 + Math.sqrt(5)),
      dataKey: "value",
      type: "flat",
      isAnimationActive: !_Global.Global.isSsr,
      isUpdateAnimationActive: !_Global.Global.isSsr,
      animationBegin: 0,
      animationDuration: 1500,
      animationEasing: "linear"
    };
  }
});

// node_modules/recharts/lib/chart/Sankey.js
var require_Sankey = __commonJS({
  "node_modules/recharts/lib/chart/Sankey.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Sankey = void 0;
    var _get2 = _interopRequireDefault(require("lodash/get")), _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _sumBy2 = _interopRequireDefault(require("lodash/sumBy")), _min2 = _interopRequireDefault(require("lodash/min")), _maxBy2 = _interopRequireDefault(require("lodash/maxBy")), _react = _interopRequireWildcard(require("react")), _classnames = _interopRequireDefault(require("classnames")), _Surface = require_Surface(), _Layer = require_Layer(), _Tooltip = require_Tooltip(), _Rectangle = require_Rectangle(), _ShallowEqual = require_ShallowEqual(), _ReactUtils = require_ReactUtils(), _ChartUtils = require_ChartUtils(), _types = require_types();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose2(source, excluded), key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++)
          key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source, key) || (target[key] = source[key]));
      }
      return target;
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {}, sourceKeys = Object.keys(source), key, i;
      for (i = 0; i < sourceKeys.length; i++)
        key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
      return target;
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    var defaultCoordinateOfTooltip = {
      x: 0,
      y: 0
    }, interpolationGenerator = function(a, b) {
      var ka = +a, kb = b - ka;
      return function(t) {
        return ka + kb * t;
      };
    }, centerY = function(node) {
      return node.y + node.dy / 2;
    }, getValue = function(entry2) {
      return entry2 && entry2.value || 0;
    }, getSumOfIds = function(links2, ids) {
      return ids.reduce(function(result, id) {
        return result + getValue(links2[id]);
      }, 0);
    }, getSumWithWeightedSource = function(tree, links2, ids) {
      return ids.reduce(function(result, id) {
        var link = links2[id], sourceNode = tree[link.source];
        return result + centerY(sourceNode) * getValue(links2[id]);
      }, 0);
    }, getSumWithWeightedTarget = function(tree, links2, ids) {
      return ids.reduce(function(result, id) {
        var link = links2[id], targetNode = tree[link.target];
        return result + centerY(targetNode) * getValue(links2[id]);
      }, 0);
    }, ascendingY = function(a, b) {
      return a.y - b.y;
    }, searchTargetsAndSources = function(links2, id) {
      for (var sourceNodes = [], sourceLinks = [], targetNodes = [], targetLinks = [], i = 0, len = links2.length; i < len; i++) {
        var link = links2[i];
        link.source === id && (targetNodes.push(link.target), targetLinks.push(i)), link.target === id && (sourceNodes.push(link.source), sourceLinks.push(i));
      }
      return {
        sourceNodes,
        sourceLinks,
        targetLinks,
        targetNodes
      };
    }, updateDepthOfTargets = function updateDepthOfTargets2(tree, curNode) {
      for (var targetNodes = curNode.targetNodes, i = 0, len = targetNodes.length; i < len; i++) {
        var target = tree[targetNodes[i]];
        target && (target.depth = Math.max(curNode.depth + 1, target.depth), updateDepthOfTargets2(tree, target));
      }
    }, getNodesTree = function(_ref, width, nodeWidth) {
      for (var nodes = _ref.nodes, links2 = _ref.links, tree = nodes.map(function(entry2, index) {
        var result = searchTargetsAndSources(links2, index);
        return _objectSpread3(_objectSpread3(_objectSpread3({}, entry2), result), {}, {
          value: Math.max(getSumOfIds(links2, result.sourceLinks), getSumOfIds(links2, result.targetLinks)),
          depth: 0
        });
      }), i = 0, len = tree.length; i < len; i++) {
        var node = tree[i];
        node.sourceNodes.length || updateDepthOfTargets(tree, node);
      }
      var maxDepth = (0, _maxBy2.default)(tree, function(entry2) {
        return entry2.depth;
      }).depth;
      if (maxDepth >= 1)
        for (var childWidth = (width - nodeWidth) / maxDepth, _i = 0, _len = tree.length; _i < _len; _i++) {
          var _node = tree[_i];
          _node.targetNodes.length || (_node.depth = maxDepth), _node.x = _node.depth * childWidth, _node.dx = nodeWidth;
        }
      return {
        tree,
        maxDepth
      };
    }, getDepthTree = function(tree) {
      for (var result = [], i = 0, len = tree.length; i < len; i++) {
        var node = tree[i];
        result[node.depth] || (result[node.depth] = []), result[node.depth].push(node);
      }
      return result;
    }, updateYOfTree = function(depthTree, height, nodePadding, links2) {
      for (var yRatio = (0, _min2.default)(depthTree.map(function(nodes) {
        return (height - (nodes.length - 1) * nodePadding) / (0, _sumBy2.default)(nodes, getValue);
      })), d = 0, maxDepth = depthTree.length; d < maxDepth; d++)
        for (var i = 0, len = depthTree[d].length; i < len; i++) {
          var node = depthTree[d][i];
          node.y = i, node.dy = node.value * yRatio;
        }
      return links2.map(function(link) {
        return _objectSpread3(_objectSpread3({}, link), {}, {
          dy: getValue(link) * yRatio
        });
      });
    }, resolveCollisions = function(depthTree, height, nodePadding) {
      for (var i = 0, len = depthTree.length; i < len; i++) {
        var nodes = depthTree[i], n = nodes.length;
        nodes.sort(ascendingY);
        for (var y0 = 0, j = 0; j < n; j++) {
          var node = nodes[j], dy = y0 - node.y;
          dy > 0 && (node.y += dy), y0 = node.y + node.dy + nodePadding;
        }
        y0 = height + nodePadding;
        for (var _j = n - 1; _j >= 0; _j--) {
          var _node2 = nodes[_j], _dy = _node2.y + _node2.dy + nodePadding - y0;
          if (_dy > 0)
            _node2.y -= _dy, y0 = _node2.y;
          else
            break;
        }
      }
    }, relaxLeftToRight = function(tree, depthTree, links2, alpha) {
      for (var i = 0, maxDepth = depthTree.length; i < maxDepth; i++)
        for (var nodes = depthTree[i], j = 0, len = nodes.length; j < len; j++) {
          var node = nodes[j];
          if (node.sourceLinks.length) {
            var sourceSum = getSumOfIds(links2, node.sourceLinks), weightedSum = getSumWithWeightedSource(tree, links2, node.sourceLinks), y = weightedSum / sourceSum;
            node.y += (y - centerY(node)) * alpha;
          }
        }
    }, relaxRightToLeft = function(tree, depthTree, links2, alpha) {
      for (var i = depthTree.length - 1; i >= 0; i--)
        for (var nodes = depthTree[i], j = 0, len = nodes.length; j < len; j++) {
          var node = nodes[j];
          if (node.targetLinks.length) {
            var targetSum = getSumOfIds(links2, node.targetLinks), weightedSum = getSumWithWeightedTarget(tree, links2, node.targetLinks), y = weightedSum / targetSum;
            node.y += (y - centerY(node)) * alpha;
          }
        }
    }, updateYOfLinks = function(tree, links2) {
      for (var i = 0, len = tree.length; i < len; i++) {
        var node = tree[i], sy = 0, ty = 0;
        node.targetLinks.sort(function(a, b) {
          return tree[links2[a].target].y - tree[links2[b].target].y;
        }), node.sourceLinks.sort(function(a, b) {
          return tree[links2[a].source].y - tree[links2[b].source].y;
        });
        for (var j = 0, tLen = node.targetLinks.length; j < tLen; j++) {
          var link = links2[node.targetLinks[j]];
          link && (link.sy = sy, sy += link.dy);
        }
        for (var _j2 = 0, sLen = node.sourceLinks.length; _j2 < sLen; _j2++) {
          var _link = links2[node.sourceLinks[_j2]];
          _link && (_link.ty = ty, ty += _link.dy);
        }
      }
    }, computeData = function(_ref2) {
      var data = _ref2.data, width = _ref2.width, height = _ref2.height, iterations = _ref2.iterations, nodeWidth = _ref2.nodeWidth, nodePadding = _ref2.nodePadding, links2 = data.links, _getNodesTree = getNodesTree(data, width, nodeWidth), tree = _getNodesTree.tree, depthTree = getDepthTree(tree), newLinks = updateYOfTree(depthTree, height, nodePadding, links2);
      resolveCollisions(depthTree, height, nodePadding);
      for (var alpha = 1, i = 1; i <= iterations; i++)
        relaxRightToLeft(tree, depthTree, newLinks, alpha *= 0.99), resolveCollisions(depthTree, height, nodePadding), relaxLeftToRight(tree, depthTree, newLinks, alpha), resolveCollisions(depthTree, height, nodePadding);
      return updateYOfLinks(tree, newLinks), {
        nodes: tree,
        links: newLinks
      };
    }, getCoordinateOfTooltip = function(el, type) {
      return type === "node" ? {
        x: el.x + el.width / 2,
        y: el.y + el.height / 2
      } : {
        x: (el.sourceX + el.targetX) / 2,
        y: (el.sourceY + el.targetY) / 2
      };
    }, getPayloadOfTooltip = function(el, type, nameKey) {
      var payload = el.payload;
      if (type === "node")
        return [{
          payload: el,
          name: (0, _ChartUtils.getValueByDataKey)(payload, nameKey, ""),
          value: (0, _ChartUtils.getValueByDataKey)(payload, "value")
        }];
      if (payload.source && payload.target) {
        var sourceName = (0, _ChartUtils.getValueByDataKey)(payload.source, nameKey, ""), targetName = (0, _ChartUtils.getValueByDataKey)(payload.target, nameKey, "");
        return [{
          payload: el,
          name: "".concat(sourceName, " - ").concat(targetName),
          value: (0, _ChartUtils.getValueByDataKey)(payload, "value")
        }];
      }
      return [];
    }, Sankey = /* @__PURE__ */ function(_PureComponent) {
      _inherits(Sankey2, _PureComponent);
      var _super = _createSuper(Sankey2);
      function Sankey2() {
        var _this;
        _classCallCheck(this, Sankey2);
        for (var _len2 = arguments.length, args = new Array(_len2), _key = 0; _key < _len2; _key++)
          args[_key] = arguments[_key];
        return _this = _super.call.apply(_super, [this].concat(args)), _this.state = {
          activeElement: null,
          activeElementType: null,
          isTooltipActive: !1,
          nodes: [],
          links: []
        }, _this;
      }
      return _createClass(Sankey2, [{
        key: "handleMouseEnter",
        value: function(el, type, e) {
          var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, children = _this$props.children, tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip.displayName);
          tooltipItem ? this.setState(function(prev) {
            return tooltipItem.props.trigger === "hover" ? _objectSpread3(_objectSpread3({}, prev), {}, {
              activeElement: el,
              activeElementType: type,
              isTooltipActive: !0
            }) : prev;
          }, function() {
            onMouseEnter && onMouseEnter(el, type, e);
          }) : onMouseEnter && onMouseEnter(el, type, e);
        }
      }, {
        key: "handleMouseLeave",
        value: function(el, type, e) {
          var _this$props2 = this.props, onMouseLeave = _this$props2.onMouseLeave, children = _this$props2.children, tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip.displayName);
          tooltipItem ? this.setState(function(prev) {
            return tooltipItem.props.trigger === "hover" ? _objectSpread3(_objectSpread3({}, prev), {}, {
              activeElement: void 0,
              activeElementType: void 0,
              isTooltipActive: !1
            }) : prev;
          }, function() {
            onMouseLeave && onMouseLeave(el, type, e);
          }) : onMouseLeave && onMouseLeave(el, type, e);
        }
      }, {
        key: "handleClick",
        value: function(el, type, e) {
          var _this$props3 = this.props, onClick = _this$props3.onClick, children = _this$props3.children, tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip.displayName);
          tooltipItem && tooltipItem.props.trigger === "click" && (this.state.isTooltipActive ? this.setState(function(prev) {
            return _objectSpread3(_objectSpread3({}, prev), {}, {
              activeElement: void 0,
              activeElementType: void 0,
              isTooltipActive: !1
            });
          }) : this.setState(function(prev) {
            return _objectSpread3(_objectSpread3({}, prev), {}, {
              activeElement: el,
              activeElementType: type,
              isTooltipActive: !0
            });
          })), onClick && onClick(el, type, e);
        }
      }, {
        key: "renderLinks",
        value: function(links2, nodes) {
          var _this2 = this, _this$props4 = this.props, linkCurvature = _this$props4.linkCurvature, linkContent = _this$props4.link, margin = _this$props4.margin, top = (0, _get2.default)(margin, "top") || 0, left = (0, _get2.default)(margin, "left") || 0;
          return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: "recharts-sankey-links",
            key: "recharts-sankey-links"
          }, links2.map(function(link, i) {
            var sourceRelativeY = link.sy, targetRelativeY = link.ty, linkWidth = link.dy, source = nodes[link.source], target = nodes[link.target], sourceX = source.x + source.dx + left, targetX = target.x + left, interpolationFunc = interpolationGenerator(sourceX, targetX), sourceControlX = interpolationFunc(linkCurvature), targetControlX = interpolationFunc(1 - linkCurvature), sourceY = source.y + sourceRelativeY + linkWidth / 2 + top, targetY = target.y + targetRelativeY + linkWidth / 2 + top, linkProps = _objectSpread3({
              sourceX,
              targetX,
              sourceY,
              targetY,
              sourceControlX,
              targetControlX,
              sourceRelativeY,
              targetRelativeY,
              linkWidth,
              index: i,
              payload: _objectSpread3(_objectSpread3({}, link), {}, {
                source,
                target
              })
            }, (0, _types.filterProps)(linkContent)), events = {
              onMouseEnter: _this2.handleMouseEnter.bind(_this2, linkProps, "link"),
              onMouseLeave: _this2.handleMouseLeave.bind(_this2, linkProps, "link"),
              onClick: _this2.handleClick.bind(_this2, linkProps, "link")
            };
            return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, _extends({
              key: "link".concat(i)
            }, events), _this2.constructor.renderLinkItem(linkContent, linkProps));
          }));
        }
      }, {
        key: "renderNodes",
        value: function(nodes) {
          var _this3 = this, _this$props5 = this.props, nodeContent = _this$props5.node, margin = _this$props5.margin, top = (0, _get2.default)(margin, "top") || 0, left = (0, _get2.default)(margin, "left") || 0;
          return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: "recharts-sankey-nodes",
            key: "recharts-sankey-nodes"
          }, nodes.map(function(node, i) {
            var x = node.x, y = node.y, dx = node.dx, dy = node.dy, nodeProps = _objectSpread3(_objectSpread3({}, (0, _types.filterProps)(nodeContent)), {}, {
              x: x + left,
              y: y + top,
              width: dx,
              height: dy,
              index: i,
              payload: node
            }), events = {
              onMouseEnter: _this3.handleMouseEnter.bind(_this3, nodeProps, "node"),
              onMouseLeave: _this3.handleMouseLeave.bind(_this3, nodeProps, "node"),
              onClick: _this3.handleClick.bind(_this3, nodeProps, "node")
            };
            return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, _extends({
              key: "node".concat(i)
            }, events), _this3.constructor.renderNodeItem(nodeContent, nodeProps));
          }));
        }
      }, {
        key: "renderTooltip",
        value: function() {
          var _this$props6 = this.props, children = _this$props6.children, width = _this$props6.width, height = _this$props6.height, nameKey = _this$props6.nameKey, tooltipItem = (0, _ReactUtils.findChildByType)(children, _Tooltip.Tooltip.displayName);
          if (!tooltipItem)
            return null;
          var _this$state = this.state, isTooltipActive = _this$state.isTooltipActive, activeElement = _this$state.activeElement, activeElementType = _this$state.activeElementType, viewBox = {
            x: 0,
            y: 0,
            width,
            height
          }, coordinate = activeElement ? getCoordinateOfTooltip(activeElement, activeElementType) : defaultCoordinateOfTooltip, payload = activeElement ? getPayloadOfTooltip(activeElement, activeElementType, nameKey) : [];
          return /* @__PURE__ */ _react.default.cloneElement(tooltipItem, {
            viewBox,
            active: isTooltipActive,
            coordinate,
            label: "",
            payload
          });
        }
      }, {
        key: "render",
        value: function() {
          if (!(0, _ReactUtils.validateWidthHeight)(this))
            return null;
          var _this$props7 = this.props, width = _this$props7.width, height = _this$props7.height, className = _this$props7.className, style = _this$props7.style, children = _this$props7.children, others = _objectWithoutProperties2(_this$props7, ["width", "height", "className", "style", "children"]), _this$state2 = this.state, links2 = _this$state2.links, nodes = _this$state2.nodes, attrs = (0, _types.filterProps)(others);
          return /* @__PURE__ */ _react.default.createElement("div", {
            className: (0, _classnames.default)("recharts-wrapper", className),
            style: _objectSpread3(_objectSpread3({}, style), {}, {
              position: "relative",
              cursor: "default",
              width,
              height
            }),
            role: "region"
          }, /* @__PURE__ */ _react.default.createElement(_Surface.Surface, _extends({}, attrs, {
            width,
            height
          }), (0, _ReactUtils.filterSvgElements)(children), this.renderLinks(links2, nodes), this.renderNodes(nodes)), this.renderTooltip());
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function(nextProps, prevState) {
          var data = nextProps.data, width = nextProps.width, height = nextProps.height, margin = nextProps.margin, iterations = nextProps.iterations, nodeWidth = nextProps.nodeWidth, nodePadding = nextProps.nodePadding;
          if (data !== prevState.prevData || width !== prevState.prevWidth || height !== prevState.prevHeight || !(0, _ShallowEqual.shallowEqual)(margin, prevState.prevMargin) || iterations !== prevState.prevIterations || nodeWidth !== prevState.prevNodeWidth || nodePadding !== prevState.prevNodePadding) {
            var contentWidth = width - (margin && margin.left || 0) - (margin && margin.right || 0), contentHeight = height - (margin && margin.top || 0) - (margin && margin.bottom || 0), _computeData = computeData({
              data,
              width: contentWidth,
              height: contentHeight,
              iterations,
              nodeWidth,
              nodePadding
            }), links2 = _computeData.links, nodes = _computeData.nodes;
            return _objectSpread3(_objectSpread3({}, prevState), {}, {
              nodes,
              links: links2,
              prevData: data,
              prevWidth: iterations,
              prevHeight: height,
              prevMargin: margin,
              prevNodePadding: nodePadding,
              prevNodeWidth: nodeWidth,
              prevIterations: iterations
            });
          }
          return null;
        }
      }, {
        key: "renderLinkItem",
        value: function(option, props) {
          if (/* @__PURE__ */ _react.default.isValidElement(option))
            return /* @__PURE__ */ _react.default.cloneElement(option, props);
          if ((0, _isFunction2.default)(option))
            return option(props);
          var sourceX = props.sourceX, sourceY = props.sourceY, sourceControlX = props.sourceControlX, targetX = props.targetX, targetY = props.targetY, targetControlX = props.targetControlX, linkWidth = props.linkWidth, others = _objectWithoutProperties2(props, ["sourceX", "sourceY", "sourceControlX", "targetX", "targetY", "targetControlX", "linkWidth"]);
          return /* @__PURE__ */ _react.default.createElement("path", _extends({
            className: "recharts-sankey-link",
            d: `
          M`.concat(sourceX, ",").concat(sourceY, `
          C`).concat(sourceControlX, ",").concat(sourceY, " ").concat(targetControlX, ",").concat(targetY, " ").concat(targetX, ",").concat(targetY, `
        `),
            fill: "none",
            stroke: "#333",
            strokeWidth: linkWidth,
            strokeOpacity: "0.2"
          }, (0, _types.filterProps)(others)));
        }
      }, {
        key: "renderNodeItem",
        value: function(option, props) {
          return /* @__PURE__ */ _react.default.isValidElement(option) ? /* @__PURE__ */ _react.default.cloneElement(option, props) : (0, _isFunction2.default)(option) ? option(props) : /* @__PURE__ */ _react.default.createElement(_Rectangle.Rectangle, _extends({
            className: "recharts-sankey-node",
            fill: "#0088fe",
            fillOpacity: "0.8"
          }, (0, _types.filterProps)(props), {
            role: "img"
          }));
        }
      }]), Sankey2;
    }(_react.PureComponent);
    exports.Sankey = Sankey;
    Sankey.displayName = "Sankey";
    Sankey.defaultProps = {
      nameKey: "name",
      dataKey: "value",
      nodePadding: 10,
      nodeWidth: 10,
      linkCurvature: 0.5,
      iterations: 32,
      margin: {
        top: 5,
        right: 5,
        bottom: 5,
        left: 5
      }
    };
  }
});

// node_modules/recharts/lib/chart/RadarChart.js
var require_RadarChart = __commonJS({
  "node_modules/recharts/lib/chart/RadarChart.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.RadarChart = void 0;
    var _generateCategoricalChart = require_generateCategoricalChart(), _Radar = require_Radar(), _PolarAngleAxis = require_PolarAngleAxis(), _PolarRadiusAxis = require_PolarRadiusAxis(), _PolarUtils = require_PolarUtils(), RadarChart = (0, _generateCategoricalChart.generateCategoricalChart)({
      chartName: "RadarChart",
      GraphicalChild: _Radar.Radar,
      axisComponents: [{
        axisType: "angleAxis",
        AxisComp: _PolarAngleAxis.PolarAngleAxis
      }, {
        axisType: "radiusAxis",
        AxisComp: _PolarRadiusAxis.PolarRadiusAxis
      }],
      formatAxisMap: _PolarUtils.formatAxisMap,
      defaultProps: {
        layout: "centric",
        startAngle: 90,
        endAngle: -270,
        cx: "50%",
        cy: "50%",
        innerRadius: 0,
        outerRadius: "80%"
      }
    });
    exports.RadarChart = RadarChart;
  }
});

// node_modules/recharts/lib/chart/ScatterChart.js
var require_ScatterChart = __commonJS({
  "node_modules/recharts/lib/chart/ScatterChart.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.ScatterChart = void 0;
    var _generateCategoricalChart = require_generateCategoricalChart(), _Scatter = require_Scatter(), _XAxis = require_XAxis(), _YAxis = require_YAxis(), _ZAxis = require_ZAxis(), _CartesianUtils = require_CartesianUtils(), ScatterChart = (0, _generateCategoricalChart.generateCategoricalChart)({
      chartName: "ScatterChart",
      GraphicalChild: _Scatter.Scatter,
      defaultTooltipEventType: "item",
      validateTooltipEventTypes: ["item"],
      axisComponents: [{
        axisType: "xAxis",
        AxisComp: _XAxis.XAxis
      }, {
        axisType: "yAxis",
        AxisComp: _YAxis.YAxis
      }, {
        axisType: "zAxis",
        AxisComp: _ZAxis.ZAxis
      }],
      formatAxisMap: _CartesianUtils.formatAxisMap
    });
    exports.ScatterChart = ScatterChart;
  }
});

// node_modules/recharts/lib/chart/AreaChart.js
var require_AreaChart = __commonJS({
  "node_modules/recharts/lib/chart/AreaChart.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.AreaChart = void 0;
    var _generateCategoricalChart = require_generateCategoricalChart(), _Area = require_Area(), _XAxis = require_XAxis(), _YAxis = require_YAxis(), _CartesianUtils = require_CartesianUtils(), AreaChart = (0, _generateCategoricalChart.generateCategoricalChart)({
      chartName: "AreaChart",
      GraphicalChild: _Area.Area,
      axisComponents: [{
        axisType: "xAxis",
        AxisComp: _XAxis.XAxis
      }, {
        axisType: "yAxis",
        AxisComp: _YAxis.YAxis
      }],
      formatAxisMap: _CartesianUtils.formatAxisMap
    });
    exports.AreaChart = AreaChart;
  }
});

// node_modules/recharts/lib/chart/RadialBarChart.js
var require_RadialBarChart = __commonJS({
  "node_modules/recharts/lib/chart/RadialBarChart.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.RadialBarChart = void 0;
    var _generateCategoricalChart = require_generateCategoricalChart(), _PolarAngleAxis = require_PolarAngleAxis(), _PolarRadiusAxis = require_PolarRadiusAxis(), _PolarUtils = require_PolarUtils(), _RadialBar = require_RadialBar(), RadialBarChart2 = (0, _generateCategoricalChart.generateCategoricalChart)({
      chartName: "RadialBarChart",
      GraphicalChild: _RadialBar.RadialBar,
      legendContent: "children",
      defaultTooltipEventType: "axis",
      validateTooltipEventTypes: ["axis", "item"],
      axisComponents: [{
        axisType: "angleAxis",
        AxisComp: _PolarAngleAxis.PolarAngleAxis
      }, {
        axisType: "radiusAxis",
        AxisComp: _PolarRadiusAxis.PolarRadiusAxis
      }],
      formatAxisMap: _PolarUtils.formatAxisMap,
      defaultProps: {
        layout: "radial",
        startAngle: 0,
        endAngle: 360,
        cx: "50%",
        cy: "50%",
        innerRadius: 0,
        outerRadius: "80%"
      }
    });
    exports.RadialBarChart = RadialBarChart2;
  }
});

// node_modules/recharts/lib/chart/ComposedChart.js
var require_ComposedChart = __commonJS({
  "node_modules/recharts/lib/chart/ComposedChart.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.ComposedChart = void 0;
    var _generateCategoricalChart = require_generateCategoricalChart(), _Area = require_Area(), _Bar = require_Bar(), _Line = require_Line(), _Scatter = require_Scatter(), _XAxis = require_XAxis(), _YAxis = require_YAxis(), _ZAxis = require_ZAxis(), _CartesianUtils = require_CartesianUtils(), ComposedChart = (0, _generateCategoricalChart.generateCategoricalChart)({
      chartName: "ComposedChart",
      GraphicalChild: [_Line.Line, _Area.Area, _Bar.Bar, _Scatter.Scatter],
      axisComponents: [{
        axisType: "xAxis",
        AxisComp: _XAxis.XAxis
      }, {
        axisType: "yAxis",
        AxisComp: _YAxis.YAxis
      }, {
        axisType: "zAxis",
        AxisComp: _ZAxis.ZAxis
      }],
      formatAxisMap: _CartesianUtils.formatAxisMap
    });
    exports.ComposedChart = ComposedChart;
  }
});

// node_modules/recharts/lib/shape/Trapezoid.js
var require_Trapezoid = __commonJS({
  "node_modules/recharts/lib/shape/Trapezoid.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Trapezoid = void 0;
    var _react = _interopRequireWildcard(require("react")), _classnames = _interopRequireDefault(require("classnames")), _reactSmooth = _interopRequireDefault(require("react-smooth")), _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var getTrapezoidPath = function(x, y, upperWidth, lowerWidth, height) {
      var widthGap = upperWidth - lowerWidth, path;
      return path = "M ".concat(x, ",").concat(y), path += "L ".concat(x + upperWidth, ",").concat(y), path += "L ".concat(x + upperWidth - widthGap / 2, ",").concat(y + height), path += "L ".concat(x + upperWidth - widthGap / 2 - lowerWidth, ",").concat(y + height), path += "L ".concat(x, ",").concat(y, " Z"), path;
    }, Trapezoid = /* @__PURE__ */ function(_PureComponent) {
      _inherits(Trapezoid2, _PureComponent);
      var _super = _createSuper(Trapezoid2);
      function Trapezoid2() {
        var _this;
        _classCallCheck(this, Trapezoid2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        return _this = _super.call.apply(_super, [this].concat(args)), _this.state = {
          totalLength: -1
        }, _this.node = void 0, _this;
      }
      return _createClass(Trapezoid2, [{
        key: "componentDidMount",
        value: function() {
          if (this.node && this.node.getTotalLength)
            try {
              var totalLength = this.node.getTotalLength();
              totalLength && this.setState({
                totalLength
              });
            } catch {
            }
        }
      }, {
        key: "render",
        value: function() {
          var _this2 = this, _this$props = this.props, x = _this$props.x, y = _this$props.y, upperWidth = _this$props.upperWidth, lowerWidth = _this$props.lowerWidth, height = _this$props.height, className = _this$props.className, totalLength = this.state.totalLength, _this$props2 = this.props, animationEasing = _this$props2.animationEasing, animationDuration = _this$props2.animationDuration, animationBegin = _this$props2.animationBegin, isUpdateAnimationActive = _this$props2.isUpdateAnimationActive;
          if (x !== +x || y !== +y || upperWidth !== +upperWidth || lowerWidth !== +lowerWidth || height !== +height || upperWidth === 0 && lowerWidth === 0 || height === 0)
            return null;
          var layerClass = (0, _classnames.default)("recharts-trapezoid", className);
          return isUpdateAnimationActive ? /* @__PURE__ */ _react.default.createElement(_reactSmooth.default, {
            canBegin: totalLength > 0,
            from: {
              upperWidth: 0,
              lowerWidth: 0,
              height,
              x,
              y
            },
            to: {
              upperWidth,
              lowerWidth,
              height,
              x,
              y
            },
            duration: animationDuration,
            animationEasing,
            isActive: isUpdateAnimationActive
          }, function(_ref) {
            var currUpperWidth = _ref.upperWidth, currLowerWidth = _ref.lowerWidth, currHeight = _ref.height, currX = _ref.x, currY = _ref.y;
            return /* @__PURE__ */ _react.default.createElement(_reactSmooth.default, {
              canBegin: totalLength > 0,
              from: "0px ".concat(totalLength === -1 ? 1 : totalLength, "px"),
              to: "".concat(totalLength, "px 0px"),
              attributeName: "strokeDasharray",
              begin: animationBegin,
              duration: animationDuration,
              easing: animationEasing
            }, /* @__PURE__ */ _react.default.createElement("path", _extends({}, (0, _types.filterProps)(_this2.props, !0), {
              className: layerClass,
              d: getTrapezoidPath(currX, currY, currUpperWidth, currLowerWidth, currHeight),
              ref: function(node) {
                _this2.node = node;
              }
            })));
          }) : /* @__PURE__ */ _react.default.createElement("g", null, /* @__PURE__ */ _react.default.createElement("path", _extends({}, (0, _types.filterProps)(this.props, !0), {
            className: layerClass,
            d: getTrapezoidPath(x, y, upperWidth, lowerWidth, height)
          })));
        }
      }]), Trapezoid2;
    }(_react.PureComponent);
    exports.Trapezoid = Trapezoid;
    Trapezoid.defaultProps = {
      x: 0,
      y: 0,
      upperWidth: 0,
      lowerWidth: 0,
      height: 0,
      isUpdateAnimationActive: !1,
      animationBegin: 0,
      animationDuration: 1500,
      animationEasing: "ease"
    };
  }
});

// node_modules/recharts/lib/numberAxis/Funnel.js
var require_Funnel = __commonJS({
  "node_modules/recharts/lib/numberAxis/Funnel.js"(exports) {
    "use strict";
    function _typeof2(obj) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof2 = function(obj2) {
        return typeof obj2;
      } : _typeof2 = function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.Funnel = void 0;
    var _isEqual2 = _interopRequireDefault(require("lodash/isEqual")), _isPlainObject2 = _interopRequireDefault(require("lodash/isPlainObject")), _isFunction2 = _interopRequireDefault(require("lodash/isFunction")), _omit2 = _interopRequireDefault(require("lodash/omit")), _isString2 = _interopRequireDefault(require("lodash/isString")), _isNumber2 = _interopRequireDefault(require("lodash/isNumber")), _react = _interopRequireWildcard(require("react")), _reactSmooth = _interopRequireDefault(require("react-smooth")), _classnames = _interopRequireDefault(require("classnames")), _Layer = require_Layer(), _Trapezoid = require_Trapezoid(), _LabelList = require_LabelList(), _Cell = require_Cell(), _ReactUtils = require_ReactUtils(), _Global = require_Global(), _DataUtils = require_DataUtils(), _ChartUtils = require_ChartUtils(), _types = require_types();
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache;
      }, cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || _typeof2(obj) !== "object" && typeof obj != "function")
        return { default: obj };
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj))
        return cache.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!!o) {
        if (typeof o == "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
    }
    function _arrayLikeToArray(arr, len) {
      (len == null || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(arr)))) {
        var _arr = [], _n = !0, _d = !1, _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return != null && _i.return();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _extends() {
      return _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    function ownKeys3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys3(Object(source), !0).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty3(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: !0, configurable: !0 } }), superClass && _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      return _setPrototypeOf = Object.setPrototypeOf || function(o2, p2) {
        return o2.__proto__ = p2, o2;
      }, _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else
          result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      return call && (_typeof2(call) === "object" || typeof call == "function") ? call : _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function _getPrototypeOf(o) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, _getPrototypeOf(o);
    }
    var Funnel = /* @__PURE__ */ function(_PureComponent) {
      _inherits(Funnel2, _PureComponent);
      var _super = _createSuper(Funnel2);
      function Funnel2() {
        var _this;
        _classCallCheck(this, Funnel2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        return _this = _super.call.apply(_super, [this].concat(args)), _this.state = {
          isAnimationFinished: !1
        }, _this.handleAnimationEnd = function() {
          var onAnimationEnd = _this.props.onAnimationEnd;
          _this.setState({
            isAnimationFinished: !0
          }), (0, _isFunction2.default)(onAnimationEnd) && onAnimationEnd();
        }, _this.handleAnimationStart = function() {
          var onAnimationStart = _this.props.onAnimationStart;
          _this.setState({
            isAnimationFinished: !1
          }), (0, _isFunction2.default)(onAnimationStart) && onAnimationStart();
        }, _this;
      }
      return _createClass(Funnel2, [{
        key: "isActiveIndex",
        value: function(i) {
          var activeIndex = this.props.activeIndex;
          return Array.isArray(activeIndex) ? activeIndex.indexOf(i) !== -1 : i === activeIndex;
        }
      }, {
        key: "renderTrapezoidsStatically",
        value: function(trapezoids) {
          var _this2 = this, activeShape = this.props.activeShape;
          return trapezoids.map(function(entry2, i) {
            var trapezoidOptions = _this2.isActiveIndex(i) ? activeShape : null, trapezoidProps = _objectSpread3(_objectSpread3({}, entry2), {}, {
              stroke: entry2.stroke
            });
            return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, _extends({
              className: "recharts-funnel-trapezoid"
            }, (0, _types.adaptEventsOfChild)(_this2.props, entry2, i), {
              key: "trapezoid-".concat(i),
              role: "img"
            }), Funnel2.renderTrapezoidItem(trapezoidOptions, trapezoidProps));
          });
        }
      }, {
        key: "renderTrapezoidsWithAnimation",
        value: function() {
          var _this3 = this, _this$props = this.props, trapezoids = _this$props.trapezoids, isAnimationActive = _this$props.isAnimationActive, animationBegin = _this$props.animationBegin, animationDuration = _this$props.animationDuration, animationEasing = _this$props.animationEasing, animationId = _this$props.animationId, prevTrapezoids = this.state.prevTrapezoids;
          return /* @__PURE__ */ _react.default.createElement(_reactSmooth.default, {
            begin: animationBegin,
            duration: animationDuration,
            isActive: isAnimationActive,
            easing: animationEasing,
            from: {
              t: 0
            },
            to: {
              t: 1
            },
            key: "funnel-".concat(animationId),
            onAnimationStart: this.handleAnimationStart,
            onAnimationEnd: this.handleAnimationEnd
          }, function(_ref) {
            var t = _ref.t, stepData = trapezoids.map(function(entry2, index) {
              var prev = prevTrapezoids && prevTrapezoids[index];
              if (prev) {
                var _interpolatorX = (0, _DataUtils.interpolateNumber)(prev.x, entry2.x), _interpolatorY = (0, _DataUtils.interpolateNumber)(prev.y, entry2.y), _interpolatorUpperWidth = (0, _DataUtils.interpolateNumber)(prev.upperWidth, entry2.upperWidth), _interpolatorLowerWidth = (0, _DataUtils.interpolateNumber)(prev.lowerWidth, entry2.lowerWidth), _interpolatorHeight = (0, _DataUtils.interpolateNumber)(prev.height, entry2.height);
                return _objectSpread3(_objectSpread3({}, entry2), {}, {
                  x: _interpolatorX(t),
                  y: _interpolatorY(t),
                  upperWidth: _interpolatorUpperWidth(t),
                  lowerWidth: _interpolatorLowerWidth(t),
                  height: _interpolatorHeight(t)
                });
              }
              var interpolatorX = (0, _DataUtils.interpolateNumber)(entry2.x + entry2.upperWidth / 2, entry2.x), interpolatorY = (0, _DataUtils.interpolateNumber)(entry2.y + entry2.height / 2, entry2.y), interpolatorUpperWidth = (0, _DataUtils.interpolateNumber)(0, entry2.upperWidth), interpolatorLowerWidth = (0, _DataUtils.interpolateNumber)(0, entry2.lowerWidth), interpolatorHeight = (0, _DataUtils.interpolateNumber)(0, entry2.height);
              return _objectSpread3(_objectSpread3({}, entry2), {}, {
                x: interpolatorX(t),
                y: interpolatorY(t),
                upperWidth: interpolatorUpperWidth(t),
                lowerWidth: interpolatorLowerWidth(t),
                height: interpolatorHeight(t)
              });
            });
            return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, null, _this3.renderTrapezoidsStatically(stepData));
          });
        }
      }, {
        key: "renderTrapezoids",
        value: function() {
          var _this$props2 = this.props, trapezoids = _this$props2.trapezoids, isAnimationActive = _this$props2.isAnimationActive, prevTrapezoids = this.state.prevTrapezoids;
          return isAnimationActive && trapezoids && trapezoids.length && (!prevTrapezoids || !(0, _isEqual2.default)(prevTrapezoids, trapezoids)) ? this.renderTrapezoidsWithAnimation() : this.renderTrapezoidsStatically(trapezoids);
        }
      }, {
        key: "render",
        value: function() {
          var _this$props3 = this.props, hide = _this$props3.hide, trapezoids = _this$props3.trapezoids, className = _this$props3.className, isAnimationActive = _this$props3.isAnimationActive, isAnimationFinished = this.state.isAnimationFinished;
          if (hide || !trapezoids || !trapezoids.length)
            return null;
          var layerClass = (0, _classnames.default)("recharts-trapezoids", className);
          return /* @__PURE__ */ _react.default.createElement(_Layer.Layer, {
            className: layerClass
          }, this.renderTrapezoids(), (!isAnimationActive || isAnimationFinished) && _LabelList.LabelList.renderCallByParent(this.props, trapezoids));
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function(nextProps, prevState) {
          return nextProps.animationId !== prevState.prevAnimationId ? {
            prevAnimationId: nextProps.animationId,
            curTrapezoids: nextProps.trapezoids,
            prevTrapezoids: prevState.curTrapezoids
          } : nextProps.trapezoids !== prevState.curTrapezoids ? {
            curTrapezoids: nextProps.trapezoids
          } : null;
        }
      }, {
        key: "renderTrapezoidItem",
        value: function(option, props) {
          return /* @__PURE__ */ _react.default.isValidElement(option) ? /* @__PURE__ */ _react.default.cloneElement(option, props) : (0, _isFunction2.default)(option) ? option(props) : (0, _isPlainObject2.default)(option) ? /* @__PURE__ */ _react.default.createElement(_Trapezoid.Trapezoid, _extends({}, props, option)) : /* @__PURE__ */ _react.default.createElement(_Trapezoid.Trapezoid, props);
        }
      }]), Funnel2;
    }(_react.PureComponent);
    exports.Funnel = Funnel;
    Funnel.displayName = "Funnel";
    Funnel.defaultProps = {
      stroke: "#fff",
      fill: "#808080",
      legendType: "rect",
      labelLine: !0,
      hide: !1,
      isAnimationActive: !_Global.Global.isSsr,
      animationBegin: 400,
      animationDuration: 1500,
      animationEasing: "ease",
      nameKey: "name",
      lastShapeType: "triangle"
    };
    Funnel.getRealFunnelData = function(item) {
      var _item$props = item.props, data = _item$props.data, children = _item$props.children, presentationProps = (0, _types.filterProps)(item.props), cells = (0, _ReactUtils.findAllByType)(children, _Cell.Cell.displayName);
      return data && data.length ? data.map(function(entry2, index) {
        return _objectSpread3(_objectSpread3(_objectSpread3({
          payload: entry2
        }, presentationProps), entry2), cells && cells[index] && cells[index].props);
      }) : cells && cells.length ? cells.map(function(cell) {
        return _objectSpread3(_objectSpread3({}, presentationProps), cell.props);
      }) : [];
    };
    Funnel.getRealWidthHeight = function(item, offset) {
      var customWidth = item.props.width, width = offset.width, height = offset.height, left = offset.left, right = offset.right, top = offset.top, bottom = offset.bottom, realHeight = height, realWidth = width;
      return (0, _isNumber2.default)(customWidth) ? realWidth = customWidth : (0, _isString2.default)(customWidth) && (realWidth = realWidth * parseFloat(customWidth) / 100), {
        realWidth: realWidth - left - right - 50,
        realHeight: realHeight - bottom - top,
        offsetX: (width - realWidth) / 2,
        offsetY: (height - realHeight) / 2
      };
    };
    Funnel.getComposedData = function(_ref2) {
      var item = _ref2.item, offset = _ref2.offset, funnelData = Funnel.getRealFunnelData(item), _item$props2 = item.props, dataKey = _item$props2.dataKey, nameKey = _item$props2.nameKey, tooltipType = _item$props2.tooltipType, lastShapeType = _item$props2.lastShapeType, reversed = _item$props2.reversed, left = offset.left, top = offset.top, _Funnel$getRealWidthH = Funnel.getRealWidthHeight(item, offset), realHeight = _Funnel$getRealWidthH.realHeight, realWidth = _Funnel$getRealWidthH.realWidth, offsetX = _Funnel$getRealWidthH.offsetX, offsetY = _Funnel$getRealWidthH.offsetY, maxValue = Math.max.apply(null, funnelData.map(function(entry2) {
        return (0, _ChartUtils.getValueByDataKey)(entry2, dataKey, 0);
      })), len = funnelData.length, rowHeight = realHeight / len, parentViewBox = {
        x: offset.left,
        y: offset.top,
        width: offset.width,
        height: offset.height
      }, trapezoids = funnelData.map(function(entry2, i) {
        var rawVal = (0, _ChartUtils.getValueByDataKey)(entry2, dataKey, 0), name = (0, _ChartUtils.getValueByDataKey)(entry2, nameKey, i), val = rawVal, nextVal;
        if (i !== len - 1) {
          if (nextVal = (0, _ChartUtils.getValueByDataKey)(funnelData[i + 1], dataKey, 0), nextVal instanceof Array) {
            var _nextVal = nextVal, _nextVal2 = _slicedToArray(_nextVal, 1);
            nextVal = _nextVal2[0];
          }
        } else if (rawVal instanceof Array && rawVal.length === 2) {
          var _rawVal = _slicedToArray(rawVal, 2);
          val = _rawVal[0], nextVal = _rawVal[1];
        } else
          lastShapeType === "rectangle" ? nextVal = val : nextVal = 0;
        var x = (maxValue - val) * realWidth / (2 * maxValue) + top + 25 + offsetX, y = rowHeight * i + left + offsetY, upperWidth = val / maxValue * realWidth, lowerWidth = nextVal / maxValue * realWidth, tooltipPayload = [{
          name,
          value: val,
          payload: entry2,
          dataKey,
          type: tooltipType
        }], tooltipPosition = {
          x: x + upperWidth / 2,
          y: y + rowHeight / 2
        };
        return _objectSpread3(_objectSpread3({
          x,
          y,
          width: Math.max(upperWidth, lowerWidth),
          upperWidth,
          lowerWidth,
          height: rowHeight,
          name,
          val,
          tooltipPayload,
          tooltipPosition
        }, (0, _omit2.default)(entry2, "width")), {}, {
          payload: entry2,
          parentViewBox,
          labelViewBox: {
            x: x + (upperWidth - lowerWidth) / 4,
            y,
            width: Math.abs(upperWidth - lowerWidth) / 2 + Math.min(upperWidth, lowerWidth),
            height: rowHeight
          }
        });
      });
      return reversed && (trapezoids = trapezoids.map(function(entry2, index) {
        var newY = entry2.y - index * rowHeight + (len - 1 - index) * rowHeight;
        return _objectSpread3(_objectSpread3({}, entry2), {}, {
          upperWidth: entry2.lowerWidth,
          lowerWidth: entry2.upperWidth,
          x: entry2.x - (entry2.lowerWidth - entry2.upperWidth) / 2,
          y: entry2.y - index * rowHeight + (len - 1 - index) * rowHeight,
          tooltipPosition: _objectSpread3(_objectSpread3({}, entry2.tooltipPosition), {}, {
            y: newY + rowHeight / 2
          }),
          labelViewBox: _objectSpread3(_objectSpread3({}, entry2.labelViewBox), {}, {
            y: newY
          })
        });
      })), {
        trapezoids,
        data: funnelData
      };
    };
  }
});

// node_modules/recharts/lib/chart/FunnelChart.js
var require_FunnelChart = __commonJS({
  "node_modules/recharts/lib/chart/FunnelChart.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.FunnelChart = void 0;
    var _generateCategoricalChart = require_generateCategoricalChart(), _Funnel = require_Funnel(), FunnelChart = (0, _generateCategoricalChart.generateCategoricalChart)({
      chartName: "FunnelChart",
      GraphicalChild: _Funnel.Funnel,
      validateTooltipEventTypes: ["item"],
      defaultTooltipEventType: "item",
      axisComponents: [],
      defaultProps: {
        layout: "centric"
      }
    });
    exports.FunnelChart = FunnelChart;
  }
});

// node_modules/recharts/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/recharts/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    Object.defineProperty(exports, "Surface", {
      enumerable: !0,
      get: function() {
        return _Surface.Surface;
      }
    });
    Object.defineProperty(exports, "Layer", {
      enumerable: !0,
      get: function() {
        return _Layer.Layer;
      }
    });
    Object.defineProperty(exports, "Legend", {
      enumerable: !0,
      get: function() {
        return _Legend.Legend;
      }
    });
    Object.defineProperty(exports, "Tooltip", {
      enumerable: !0,
      get: function() {
        return _Tooltip.Tooltip;
      }
    });
    Object.defineProperty(exports, "ResponsiveContainer", {
      enumerable: !0,
      get: function() {
        return _ResponsiveContainer.ResponsiveContainer;
      }
    });
    Object.defineProperty(exports, "Cell", {
      enumerable: !0,
      get: function() {
        return _Cell.Cell;
      }
    });
    Object.defineProperty(exports, "Text", {
      enumerable: !0,
      get: function() {
        return _Text.Text;
      }
    });
    Object.defineProperty(exports, "Label", {
      enumerable: !0,
      get: function() {
        return _Label.Label;
      }
    });
    Object.defineProperty(exports, "LabelList", {
      enumerable: !0,
      get: function() {
        return _LabelList.LabelList;
      }
    });
    Object.defineProperty(exports, "Customized", {
      enumerable: !0,
      get: function() {
        return _Customized.Customized;
      }
    });
    Object.defineProperty(exports, "Sector", {
      enumerable: !0,
      get: function() {
        return _Sector.Sector;
      }
    });
    Object.defineProperty(exports, "Curve", {
      enumerable: !0,
      get: function() {
        return _Curve.Curve;
      }
    });
    Object.defineProperty(exports, "Rectangle", {
      enumerable: !0,
      get: function() {
        return _Rectangle.Rectangle;
      }
    });
    Object.defineProperty(exports, "Polygon", {
      enumerable: !0,
      get: function() {
        return _Polygon.Polygon;
      }
    });
    Object.defineProperty(exports, "Dot", {
      enumerable: !0,
      get: function() {
        return _Dot.Dot;
      }
    });
    Object.defineProperty(exports, "Cross", {
      enumerable: !0,
      get: function() {
        return _Cross.Cross;
      }
    });
    Object.defineProperty(exports, "Symbols", {
      enumerable: !0,
      get: function() {
        return _Symbols.Symbols;
      }
    });
    Object.defineProperty(exports, "PolarGrid", {
      enumerable: !0,
      get: function() {
        return _PolarGrid.PolarGrid;
      }
    });
    Object.defineProperty(exports, "PolarRadiusAxis", {
      enumerable: !0,
      get: function() {
        return _PolarRadiusAxis.PolarRadiusAxis;
      }
    });
    Object.defineProperty(exports, "PolarAngleAxis", {
      enumerable: !0,
      get: function() {
        return _PolarAngleAxis.PolarAngleAxis;
      }
    });
    Object.defineProperty(exports, "Pie", {
      enumerable: !0,
      get: function() {
        return _Pie.Pie;
      }
    });
    Object.defineProperty(exports, "Radar", {
      enumerable: !0,
      get: function() {
        return _Radar.Radar;
      }
    });
    Object.defineProperty(exports, "RadialBar", {
      enumerable: !0,
      get: function() {
        return _RadialBar.RadialBar;
      }
    });
    Object.defineProperty(exports, "Brush", {
      enumerable: !0,
      get: function() {
        return _Brush.Brush;
      }
    });
    Object.defineProperty(exports, "ReferenceLine", {
      enumerable: !0,
      get: function() {
        return _ReferenceLine.ReferenceLine;
      }
    });
    Object.defineProperty(exports, "ReferenceDot", {
      enumerable: !0,
      get: function() {
        return _ReferenceDot.ReferenceDot;
      }
    });
    Object.defineProperty(exports, "ReferenceArea", {
      enumerable: !0,
      get: function() {
        return _ReferenceArea.ReferenceArea;
      }
    });
    Object.defineProperty(exports, "CartesianAxis", {
      enumerable: !0,
      get: function() {
        return _CartesianAxis.CartesianAxis;
      }
    });
    Object.defineProperty(exports, "CartesianGrid", {
      enumerable: !0,
      get: function() {
        return _CartesianGrid.CartesianGrid;
      }
    });
    Object.defineProperty(exports, "Line", {
      enumerable: !0,
      get: function() {
        return _Line.Line;
      }
    });
    Object.defineProperty(exports, "Area", {
      enumerable: !0,
      get: function() {
        return _Area.Area;
      }
    });
    Object.defineProperty(exports, "Bar", {
      enumerable: !0,
      get: function() {
        return _Bar.Bar;
      }
    });
    Object.defineProperty(exports, "Scatter", {
      enumerable: !0,
      get: function() {
        return _Scatter.Scatter;
      }
    });
    Object.defineProperty(exports, "XAxis", {
      enumerable: !0,
      get: function() {
        return _XAxis.XAxis;
      }
    });
    Object.defineProperty(exports, "YAxis", {
      enumerable: !0,
      get: function() {
        return _YAxis.YAxis;
      }
    });
    Object.defineProperty(exports, "ZAxis", {
      enumerable: !0,
      get: function() {
        return _ZAxis.ZAxis;
      }
    });
    Object.defineProperty(exports, "ErrorBar", {
      enumerable: !0,
      get: function() {
        return _ErrorBar.ErrorBar;
      }
    });
    Object.defineProperty(exports, "LineChart", {
      enumerable: !0,
      get: function() {
        return _LineChart.LineChart;
      }
    });
    Object.defineProperty(exports, "BarChart", {
      enumerable: !0,
      get: function() {
        return _BarChart.BarChart;
      }
    });
    Object.defineProperty(exports, "PieChart", {
      enumerable: !0,
      get: function() {
        return _PieChart.PieChart;
      }
    });
    Object.defineProperty(exports, "Treemap", {
      enumerable: !0,
      get: function() {
        return _Treemap.Treemap;
      }
    });
    Object.defineProperty(exports, "Sankey", {
      enumerable: !0,
      get: function() {
        return _Sankey.Sankey;
      }
    });
    Object.defineProperty(exports, "RadarChart", {
      enumerable: !0,
      get: function() {
        return _RadarChart.RadarChart;
      }
    });
    Object.defineProperty(exports, "ScatterChart", {
      enumerable: !0,
      get: function() {
        return _ScatterChart.ScatterChart;
      }
    });
    Object.defineProperty(exports, "AreaChart", {
      enumerable: !0,
      get: function() {
        return _AreaChart.AreaChart;
      }
    });
    Object.defineProperty(exports, "RadialBarChart", {
      enumerable: !0,
      get: function() {
        return _RadialBarChart.RadialBarChart;
      }
    });
    Object.defineProperty(exports, "ComposedChart", {
      enumerable: !0,
      get: function() {
        return _ComposedChart.ComposedChart;
      }
    });
    Object.defineProperty(exports, "Funnel", {
      enumerable: !0,
      get: function() {
        return _Funnel.Funnel;
      }
    });
    Object.defineProperty(exports, "FunnelChart", {
      enumerable: !0,
      get: function() {
        return _FunnelChart.FunnelChart;
      }
    });
    Object.defineProperty(exports, "Trapezoid", {
      enumerable: !0,
      get: function() {
        return _Trapezoid.Trapezoid;
      }
    });
    Object.defineProperty(exports, "Global", {
      enumerable: !0,
      get: function() {
        return _Global.Global;
      }
    });
    var _Surface = require_Surface(), _Layer = require_Layer(), _Legend = require_Legend(), _Tooltip = require_Tooltip(), _ResponsiveContainer = require_ResponsiveContainer(), _Cell = require_Cell(), _Text = require_Text(), _Label = require_Label(), _LabelList = require_LabelList(), _Customized = require_Customized(), _Sector = require_Sector(), _Curve = require_Curve(), _Rectangle = require_Rectangle(), _Polygon = require_Polygon(), _Dot = require_Dot(), _Cross = require_Cross(), _Symbols = require_Symbols(), _PolarGrid = require_PolarGrid(), _PolarRadiusAxis = require_PolarRadiusAxis(), _PolarAngleAxis = require_PolarAngleAxis(), _Pie = require_Pie(), _Radar = require_Radar(), _RadialBar = require_RadialBar(), _Brush = require_Brush(), _ReferenceLine = require_ReferenceLine(), _ReferenceDot = require_ReferenceDot(), _ReferenceArea = require_ReferenceArea(), _CartesianAxis = require_CartesianAxis(), _CartesianGrid = require_CartesianGrid(), _Line = require_Line(), _Area = require_Area(), _Bar = require_Bar(), _Scatter = require_Scatter(), _XAxis = require_XAxis(), _YAxis = require_YAxis(), _ZAxis = require_ZAxis(), _ErrorBar = require_ErrorBar(), _LineChart = require_LineChart(), _BarChart = require_BarChart(), _PieChart = require_PieChart(), _Treemap = require_Treemap(), _Sankey = require_Sankey(), _RadarChart = require_RadarChart(), _ScatterChart = require_ScatterChart(), _AreaChart = require_AreaChart(), _RadialBarChart = require_RadialBarChart(), _ComposedChart = require_ComposedChart(), _Funnel = require_Funnel(), _FunnelChart = require_FunnelChart(), _Trapezoid = require_Trapezoid(), _Global = require_Global();
  }
});

// node_modules/konva/cmj/Global.js
var require_Global2 = __commonJS({
  "node_modules/konva/cmj/Global.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports._registerNode = exports.Konva = exports.glob = void 0;
    var PI_OVER_1802 = Math.PI / 180;
    function detectBrowser2() {
      return typeof window < "u" && ({}.toString.call(window) === "[object Window]" || {}.toString.call(window) === "[object global]");
    }
    exports.glob = typeof global < "u" ? global : typeof window < "u" ? window : typeof WorkerGlobalScope < "u" ? self : {};
    exports.Konva = {
      _global: exports.glob,
      version: "8.3.14",
      isBrowser: detectBrowser2(),
      isUnminified: /param/.test(function(param) {
      }.toString()),
      dblClickWindow: 400,
      getAngle(angle) {
        return exports.Konva.angleDeg ? angle * PI_OVER_1802 : angle;
      },
      enableTrace: !1,
      pointerEventsEnabled: !0,
      autoDrawEnabled: !0,
      hitOnDragEnabled: !1,
      capturePointerEventsEnabled: !1,
      _mouseListenClick: !1,
      _touchListenClick: !1,
      _pointerListenClick: !1,
      _mouseInDblClickWindow: !1,
      _touchInDblClickWindow: !1,
      _pointerInDblClickWindow: !1,
      _mouseDblClickPointerId: null,
      _touchDblClickPointerId: null,
      _pointerDblClickPointerId: null,
      pixelRatio: typeof window < "u" && window.devicePixelRatio || 1,
      dragDistance: 3,
      angleDeg: !0,
      showWarnings: !0,
      dragButtons: [0, 1],
      isDragging() {
        return exports.Konva.DD.isDragging;
      },
      isDragReady() {
        return !!exports.Konva.DD.node;
      },
      releaseCanvasOnDestroy: !0,
      document: exports.glob.document,
      _injectGlobal(Konva3) {
        exports.glob.Konva = Konva3;
      }
    };
    var _registerNode2 = (NodeClass) => {
      exports.Konva[NodeClass.prototype.getClassName()] = NodeClass;
    };
    exports._registerNode = _registerNode2;
    exports.Konva._injectGlobal(exports.Konva);
  }
});

// node_modules/konva/cmj/Util.js
var require_Util = __commonJS({
  "node_modules/konva/cmj/Util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Util = exports.Transform = void 0;
    var Global_1 = require_Global2(), Transform2 = class {
      constructor(m = [1, 0, 0, 1, 0, 0]) {
        this.dirty = !1, this.m = m && m.slice() || [1, 0, 0, 1, 0, 0];
      }
      reset() {
        this.m[0] = 1, this.m[1] = 0, this.m[2] = 0, this.m[3] = 1, this.m[4] = 0, this.m[5] = 0;
      }
      copy() {
        return new Transform2(this.m);
      }
      copyInto(tr) {
        tr.m[0] = this.m[0], tr.m[1] = this.m[1], tr.m[2] = this.m[2], tr.m[3] = this.m[3], tr.m[4] = this.m[4], tr.m[5] = this.m[5];
      }
      point(point) {
        var m = this.m;
        return {
          x: m[0] * point.x + m[2] * point.y + m[4],
          y: m[1] * point.x + m[3] * point.y + m[5]
        };
      }
      translate(x, y) {
        return this.m[4] += this.m[0] * x + this.m[2] * y, this.m[5] += this.m[1] * x + this.m[3] * y, this;
      }
      scale(sx, sy) {
        return this.m[0] *= sx, this.m[1] *= sx, this.m[2] *= sy, this.m[3] *= sy, this;
      }
      rotate(rad) {
        var c = Math.cos(rad), s = Math.sin(rad), m11 = this.m[0] * c + this.m[2] * s, m12 = this.m[1] * c + this.m[3] * s, m21 = this.m[0] * -s + this.m[2] * c, m22 = this.m[1] * -s + this.m[3] * c;
        return this.m[0] = m11, this.m[1] = m12, this.m[2] = m21, this.m[3] = m22, this;
      }
      getTranslation() {
        return {
          x: this.m[4],
          y: this.m[5]
        };
      }
      skew(sx, sy) {
        var m11 = this.m[0] + this.m[2] * sy, m12 = this.m[1] + this.m[3] * sy, m21 = this.m[2] + this.m[0] * sx, m22 = this.m[3] + this.m[1] * sx;
        return this.m[0] = m11, this.m[1] = m12, this.m[2] = m21, this.m[3] = m22, this;
      }
      multiply(matrix) {
        var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1], m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1], m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3], m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3], dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4], dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];
        return this.m[0] = m11, this.m[1] = m12, this.m[2] = m21, this.m[3] = m22, this.m[4] = dx, this.m[5] = dy, this;
      }
      invert() {
        var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]), m0 = this.m[3] * d, m1 = -this.m[1] * d, m2 = -this.m[2] * d, m3 = this.m[0] * d, m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]), m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
        return this.m[0] = m0, this.m[1] = m1, this.m[2] = m2, this.m[3] = m3, this.m[4] = m4, this.m[5] = m5, this;
      }
      getMatrix() {
        return this.m;
      }
      decompose() {
        var a = this.m[0], b = this.m[1], c = this.m[2], d = this.m[3], e = this.m[4], f = this.m[5], delta = a * d - b * c;
        let result = {
          x: e,
          y: f,
          rotation: 0,
          scaleX: 0,
          scaleY: 0,
          skewX: 0,
          skewY: 0
        };
        if (a != 0 || b != 0) {
          var r = Math.sqrt(a * a + b * b);
          result.rotation = b > 0 ? Math.acos(a / r) : -Math.acos(a / r), result.scaleX = r, result.scaleY = delta / r, result.skewX = (a * c + b * d) / delta, result.skewY = 0;
        } else if (c != 0 || d != 0) {
          var s = Math.sqrt(c * c + d * d);
          result.rotation = Math.PI / 2 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s)), result.scaleX = delta / s, result.scaleY = s, result.skewX = 0, result.skewY = (a * c + b * d) / delta;
        }
        return result.rotation = exports.Util._getRotation(result.rotation), result;
      }
    };
    exports.Transform = Transform2;
    var OBJECT_ARRAY2 = "[object Array]", OBJECT_NUMBER2 = "[object Number]", OBJECT_STRING2 = "[object String]", OBJECT_BOOLEAN2 = "[object Boolean]", PI_OVER_DEG1802 = Math.PI / 180, DEG180_OVER_PI2 = 180 / Math.PI, HASH3 = "#", EMPTY_STRING2 = "", ZERO2 = "0", KONVA_WARNING2 = "Konva warning: ", KONVA_ERROR2 = "Konva error: ", RGB_PAREN2 = "rgb(", COLORS2 = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 132, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 255, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 203],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [119, 128, 144],
      slategrey: [119, 128, 144],
      snow: [255, 255, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      transparent: [255, 255, 255, 0],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 5]
    }, RGB_REGEX2 = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/, animQueue2 = [], req2 = typeof requestAnimationFrame < "u" && requestAnimationFrame || function(f) {
      setTimeout(f, 60);
    };
    exports.Util = {
      _isElement(obj) {
        return !!(obj && obj.nodeType == 1);
      },
      _isFunction(obj) {
        return !!(obj && obj.constructor && obj.call && obj.apply);
      },
      _isPlainObject(obj) {
        return !!obj && obj.constructor === Object;
      },
      _isArray(obj) {
        return Object.prototype.toString.call(obj) === OBJECT_ARRAY2;
      },
      _isNumber(obj) {
        return Object.prototype.toString.call(obj) === OBJECT_NUMBER2 && !isNaN(obj) && isFinite(obj);
      },
      _isString(obj) {
        return Object.prototype.toString.call(obj) === OBJECT_STRING2;
      },
      _isBoolean(obj) {
        return Object.prototype.toString.call(obj) === OBJECT_BOOLEAN2;
      },
      isObject(val) {
        return val instanceof Object;
      },
      isValidSelector(selector) {
        if (typeof selector != "string")
          return !1;
        var firstChar = selector[0];
        return firstChar === "#" || firstChar === "." || firstChar === firstChar.toUpperCase();
      },
      _sign(number) {
        return number === 0 || number > 0 ? 1 : -1;
      },
      requestAnimFrame(callback) {
        animQueue2.push(callback), animQueue2.length === 1 && req2(function() {
          let queue = animQueue2;
          animQueue2 = [], queue.forEach(function(cb) {
            cb();
          });
        });
      },
      createCanvasElement() {
        var canvas = document.createElement("canvas");
        try {
          canvas.style = canvas.style || {};
        } catch {
        }
        return canvas;
      },
      createImageElement() {
        return document.createElement("img");
      },
      _isInDocument(el) {
        for (; el = el.parentNode; )
          if (el == document)
            return !0;
        return !1;
      },
      _urlToImage(url, callback) {
        var imageObj = exports.Util.createImageElement();
        imageObj.onload = function() {
          callback(imageObj);
        }, imageObj.src = url;
      },
      _rgbToHex(r, g, b) {
        return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
      },
      _hexToRgb(hex) {
        hex = hex.replace(HASH3, EMPTY_STRING2);
        var bigint = parseInt(hex, 16);
        return {
          r: bigint >> 16 & 255,
          g: bigint >> 8 & 255,
          b: bigint & 255
        };
      },
      getRandomColor() {
        for (var randColor = (Math.random() * 16777215 << 0).toString(16); randColor.length < 6; )
          randColor = ZERO2 + randColor;
        return HASH3 + randColor;
      },
      getRGB(color) {
        var rgb;
        return color in COLORS2 ? (rgb = COLORS2[color], {
          r: rgb[0],
          g: rgb[1],
          b: rgb[2]
        }) : color[0] === HASH3 ? this._hexToRgb(color.substring(1)) : color.substr(0, 4) === RGB_PAREN2 ? (rgb = RGB_REGEX2.exec(color.replace(/ /g, "")), {
          r: parseInt(rgb[1], 10),
          g: parseInt(rgb[2], 10),
          b: parseInt(rgb[3], 10)
        }) : {
          r: 0,
          g: 0,
          b: 0
        };
      },
      colorToRGBA(str) {
        return str = str || "black", exports.Util._namedColorToRBA(str) || exports.Util._hex3ColorToRGBA(str) || exports.Util._hex6ColorToRGBA(str) || exports.Util._rgbColorToRGBA(str) || exports.Util._rgbaColorToRGBA(str) || exports.Util._hslColorToRGBA(str);
      },
      _namedColorToRBA(str) {
        var c = COLORS2[str.toLowerCase()];
        return c ? {
          r: c[0],
          g: c[1],
          b: c[2],
          a: 1
        } : null;
      },
      _rgbColorToRGBA(str) {
        if (str.indexOf("rgb(") === 0) {
          str = str.match(/rgb\(([^)]+)\)/)[1];
          var parts = str.split(/ *, */).map(Number);
          return {
            r: parts[0],
            g: parts[1],
            b: parts[2],
            a: 1
          };
        }
      },
      _rgbaColorToRGBA(str) {
        if (str.indexOf("rgba(") === 0) {
          str = str.match(/rgba\(([^)]+)\)/)[1];
          var parts = str.split(/ *, */).map((n, index) => n.slice(-1) === "%" ? index === 3 ? parseInt(n) / 100 : parseInt(n) / 100 * 255 : Number(n));
          return {
            r: parts[0],
            g: parts[1],
            b: parts[2],
            a: parts[3]
          };
        }
      },
      _hex6ColorToRGBA(str) {
        if (str[0] === "#" && str.length === 7)
          return {
            r: parseInt(str.slice(1, 3), 16),
            g: parseInt(str.slice(3, 5), 16),
            b: parseInt(str.slice(5, 7), 16),
            a: 1
          };
      },
      _hex3ColorToRGBA(str) {
        if (str[0] === "#" && str.length === 4)
          return {
            r: parseInt(str[1] + str[1], 16),
            g: parseInt(str[2] + str[2], 16),
            b: parseInt(str[3] + str[3], 16),
            a: 1
          };
      },
      _hslColorToRGBA(str) {
        if (/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.test(str)) {
          let [_, ...hsl] = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(str), h = Number(hsl[0]) / 360, s = Number(hsl[1]) / 100, l = Number(hsl[2]) / 100, t2, t3, val;
          if (s === 0)
            return val = l * 255, {
              r: Math.round(val),
              g: Math.round(val),
              b: Math.round(val),
              a: 1
            };
          l < 0.5 ? t2 = l * (1 + s) : t2 = l + s - l * s;
          let t1 = 2 * l - t2, rgb = [0, 0, 0];
          for (let i = 0; i < 3; i++)
            t3 = h + 1 / 3 * -(i - 1), t3 < 0 && t3++, t3 > 1 && t3--, 6 * t3 < 1 ? val = t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? val = t2 : 3 * t3 < 2 ? val = t1 + (t2 - t1) * (2 / 3 - t3) * 6 : val = t1, rgb[i] = val * 255;
          return {
            r: Math.round(rgb[0]),
            g: Math.round(rgb[1]),
            b: Math.round(rgb[2]),
            a: 1
          };
        }
      },
      haveIntersection(r1, r2) {
        return !(r2.x > r1.x + r1.width || r2.x + r2.width < r1.x || r2.y > r1.y + r1.height || r2.y + r2.height < r1.y);
      },
      cloneObject(obj) {
        var retObj = {};
        for (var key in obj)
          this._isPlainObject(obj[key]) ? retObj[key] = this.cloneObject(obj[key]) : this._isArray(obj[key]) ? retObj[key] = this.cloneArray(obj[key]) : retObj[key] = obj[key];
        return retObj;
      },
      cloneArray(arr) {
        return arr.slice(0);
      },
      degToRad(deg) {
        return deg * PI_OVER_DEG1802;
      },
      radToDeg(rad) {
        return rad * DEG180_OVER_PI2;
      },
      _degToRad(deg) {
        return exports.Util.warn("Util._degToRad is removed. Please use public Util.degToRad instead."), exports.Util.degToRad(deg);
      },
      _radToDeg(rad) {
        return exports.Util.warn("Util._radToDeg is removed. Please use public Util.radToDeg instead."), exports.Util.radToDeg(rad);
      },
      _getRotation(radians) {
        return Global_1.Konva.angleDeg ? exports.Util.radToDeg(radians) : radians;
      },
      _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      },
      throw(str) {
        throw new Error(KONVA_ERROR2 + str);
      },
      error(str) {
        console.error(KONVA_ERROR2 + str);
      },
      warn(str) {
        !Global_1.Konva.showWarnings || console.warn(KONVA_WARNING2 + str);
      },
      each(obj, func) {
        for (var key in obj)
          func(key, obj[key]);
      },
      _inRange(val, left, right) {
        return left <= val && val < right;
      },
      _getProjectionToSegment(x1, y1, x2, y2, x3, y3) {
        var x, y, dist, pd2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
        if (pd2 == 0)
          x = x1, y = y1, dist = (x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2);
        else {
          var u = ((x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1)) / pd2;
          u < 0 ? (x = x1, y = y1, dist = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3)) : u > 1 ? (x = x2, y = y2, dist = (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3)) : (x = x1 + u * (x2 - x1), y = y1 + u * (y2 - y1), dist = (x - x3) * (x - x3) + (y - y3) * (y - y3));
        }
        return [x, y, dist];
      },
      _getProjectionToLine(pt, line, isClosed) {
        var pc = exports.Util.cloneObject(pt), dist = Number.MAX_VALUE;
        return line.forEach(function(p1, i) {
          if (!(!isClosed && i === line.length - 1)) {
            var p2 = line[(i + 1) % line.length], proj = exports.Util._getProjectionToSegment(p1.x, p1.y, p2.x, p2.y, pt.x, pt.y), px = proj[0], py = proj[1], pdist = proj[2];
            pdist < dist && (pc.x = px, pc.y = py, dist = pdist);
          }
        }), pc;
      },
      _prepareArrayForTween(startArray, endArray, isClosed) {
        var n, start = [], end = [];
        if (startArray.length > endArray.length) {
          var temp = endArray;
          endArray = startArray, startArray = temp;
        }
        for (n = 0; n < startArray.length; n += 2)
          start.push({
            x: startArray[n],
            y: startArray[n + 1]
          });
        for (n = 0; n < endArray.length; n += 2)
          end.push({
            x: endArray[n],
            y: endArray[n + 1]
          });
        var newStart = [];
        return end.forEach(function(point) {
          var pr = exports.Util._getProjectionToLine(point, start, isClosed);
          newStart.push(pr.x), newStart.push(pr.y);
        }), newStart;
      },
      _prepareToStringify(obj) {
        var desc;
        obj.visitedByCircularReferenceRemoval = !0;
        for (var key in obj)
          if (!!(obj.hasOwnProperty(key) && obj[key] && typeof obj[key] == "object")) {
            if (desc = Object.getOwnPropertyDescriptor(obj, key), obj[key].visitedByCircularReferenceRemoval || exports.Util._isElement(obj[key]))
              if (desc.configurable)
                delete obj[key];
              else
                return null;
            else if (exports.Util._prepareToStringify(obj[key]) === null)
              if (desc.configurable)
                delete obj[key];
              else
                return null;
          }
        return delete obj.visitedByCircularReferenceRemoval, obj;
      },
      _assign(target, source) {
        for (var key in source)
          target[key] = source[key];
        return target;
      },
      _getFirstPointerId(evt) {
        return evt.touches ? evt.changedTouches[0].identifier : evt.pointerId || 999;
      },
      releaseCanvas(...canvases) {
        !Global_1.Konva.releaseCanvasOnDestroy || canvases.forEach((c) => {
          c.width = 0, c.height = 0;
        });
      }
    };
  }
});

// node_modules/konva/cmj/Validators.js
var require_Validators = __commonJS({
  "node_modules/konva/cmj/Validators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getComponentValidator = exports.getBooleanValidator = exports.getNumberArrayValidator = exports.getFunctionValidator = exports.getStringOrGradientValidator = exports.getStringValidator = exports.getNumberOrAutoValidator = exports.getNumberOrArrayOfNumbersValidator = exports.getNumberValidator = exports.alphaComponent = exports.RGBComponent = void 0;
    var Global_1 = require_Global2(), Util_1 = require_Util();
    function _formatValue2(val) {
      return Util_1.Util._isString(val) ? '"' + val + '"' : Object.prototype.toString.call(val) === "[object Number]" || Util_1.Util._isBoolean(val) ? val : Object.prototype.toString.call(val);
    }
    function RGBComponent(val) {
      return val > 255 ? 255 : val < 0 ? 0 : Math.round(val);
    }
    exports.RGBComponent = RGBComponent;
    function alphaComponent(val) {
      return val > 1 ? 1 : val < 1e-4 ? 1e-4 : val;
    }
    exports.alphaComponent = alphaComponent;
    function getNumberValidator2() {
      if (Global_1.Konva.isUnminified)
        return function(val, attr) {
          return Util_1.Util._isNumber(val) || Util_1.Util.warn(_formatValue2(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a number.'), val;
        };
    }
    exports.getNumberValidator = getNumberValidator2;
    function getNumberOrArrayOfNumbersValidator(noOfElements) {
      if (Global_1.Konva.isUnminified)
        return function(val, attr) {
          let isNumber = Util_1.Util._isNumber(val), isValidArray = Util_1.Util._isArray(val) && val.length == noOfElements;
          return !isNumber && !isValidArray && Util_1.Util.warn(_formatValue2(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a number or Array<number>(' + noOfElements + ")"), val;
        };
    }
    exports.getNumberOrArrayOfNumbersValidator = getNumberOrArrayOfNumbersValidator;
    function getNumberOrAutoValidator2() {
      if (Global_1.Konva.isUnminified)
        return function(val, attr) {
          var isNumber = Util_1.Util._isNumber(val), isAuto = val === "auto";
          return isNumber || isAuto || Util_1.Util.warn(_formatValue2(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a number or "auto".'), val;
        };
    }
    exports.getNumberOrAutoValidator = getNumberOrAutoValidator2;
    function getStringValidator2() {
      if (Global_1.Konva.isUnminified)
        return function(val, attr) {
          return Util_1.Util._isString(val) || Util_1.Util.warn(_formatValue2(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a string.'), val;
        };
    }
    exports.getStringValidator = getStringValidator2;
    function getStringOrGradientValidator2() {
      if (Global_1.Konva.isUnminified)
        return function(val, attr) {
          let isString = Util_1.Util._isString(val), isGradient = Object.prototype.toString.call(val) === "[object CanvasGradient]" || val && val.addColorStop;
          return isString || isGradient || Util_1.Util.warn(_formatValue2(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a string or a native gradient.'), val;
        };
    }
    exports.getStringOrGradientValidator = getStringOrGradientValidator2;
    function getFunctionValidator() {
      if (Global_1.Konva.isUnminified)
        return function(val, attr) {
          return Util_1.Util._isFunction(val) || Util_1.Util.warn(_formatValue2(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a function.'), val;
        };
    }
    exports.getFunctionValidator = getFunctionValidator;
    function getNumberArrayValidator() {
      if (Global_1.Konva.isUnminified)
        return function(val, attr) {
          let TypedArray = Int8Array ? Object.getPrototypeOf(Int8Array) : null;
          return TypedArray && val instanceof TypedArray || (Util_1.Util._isArray(val) ? val.forEach(function(item) {
            Util_1.Util._isNumber(item) || Util_1.Util.warn('"' + attr + '" attribute has non numeric element ' + item + ". Make sure that all elements are numbers.");
          }) : Util_1.Util.warn(_formatValue2(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a array of numbers.')), val;
        };
    }
    exports.getNumberArrayValidator = getNumberArrayValidator;
    function getBooleanValidator2() {
      if (Global_1.Konva.isUnminified)
        return function(val, attr) {
          var isBool = val === !0 || val === !1;
          return isBool || Util_1.Util.warn(_formatValue2(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a boolean.'), val;
        };
    }
    exports.getBooleanValidator = getBooleanValidator2;
    function getComponentValidator2(components2) {
      if (Global_1.Konva.isUnminified)
        return function(val, attr) {
          return val == null || Util_1.Util.isObject(val) || Util_1.Util.warn(_formatValue2(val) + ' is a not valid value for "' + attr + '" attribute. The value should be an object with properties ' + components2), val;
        };
    }
    exports.getComponentValidator = getComponentValidator2;
  }
});

// node_modules/konva/cmj/Factory.js
var require_Factory = __commonJS({
  "node_modules/konva/cmj/Factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Factory = void 0;
    var Util_1 = require_Util(), Validators_1 = require_Validators(), GET2 = "get", SET3 = "set";
    exports.Factory = {
      addGetterSetter(constructor, attr, def, validator, after) {
        exports.Factory.addGetter(constructor, attr, def), exports.Factory.addSetter(constructor, attr, validator, after), exports.Factory.addOverloadedGetterSetter(constructor, attr);
      },
      addGetter(constructor, attr, def) {
        var method = GET2 + Util_1.Util._capitalize(attr);
        constructor.prototype[method] = constructor.prototype[method] || function() {
          var val = this.attrs[attr];
          return val === void 0 ? def : val;
        };
      },
      addSetter(constructor, attr, validator, after) {
        var method = SET3 + Util_1.Util._capitalize(attr);
        constructor.prototype[method] || exports.Factory.overWriteSetter(constructor, attr, validator, after);
      },
      overWriteSetter(constructor, attr, validator, after) {
        var method = SET3 + Util_1.Util._capitalize(attr);
        constructor.prototype[method] = function(val) {
          return validator && val !== void 0 && val !== null && (val = validator.call(this, val, attr)), this._setAttr(attr, val), after && after.call(this), this;
        };
      },
      addComponentsGetterSetter(constructor, attr, components2, validator, after) {
        var len = components2.length, capitalize = Util_1.Util._capitalize, getter = GET2 + capitalize(attr), setter = SET3 + capitalize(attr), n, component;
        constructor.prototype[getter] = function() {
          var ret = {};
          for (n = 0; n < len; n++)
            component = components2[n], ret[component] = this.getAttr(attr + capitalize(component));
          return ret;
        };
        var basicValidator = (0, Validators_1.getComponentValidator)(components2);
        constructor.prototype[setter] = function(val) {
          var oldVal = this.attrs[attr], key;
          validator && (val = validator.call(this, val)), basicValidator && basicValidator.call(this, val, attr);
          for (key in val)
            !val.hasOwnProperty(key) || this._setAttr(attr + capitalize(key), val[key]);
          return val || components2.forEach((component2) => {
            this._setAttr(attr + capitalize(component2), void 0);
          }), this._fireChangeEvent(attr, oldVal, val), after && after.call(this), this;
        }, exports.Factory.addOverloadedGetterSetter(constructor, attr);
      },
      addOverloadedGetterSetter(constructor, attr) {
        var capitalizedAttr = Util_1.Util._capitalize(attr), setter = SET3 + capitalizedAttr, getter = GET2 + capitalizedAttr;
        constructor.prototype[attr] = function() {
          return arguments.length ? (this[setter](arguments[0]), this) : this[getter]();
        };
      },
      addDeprecatedGetterSetter(constructor, attr, def, validator) {
        Util_1.Util.error("Adding deprecated " + attr);
        var method = GET2 + Util_1.Util._capitalize(attr), message = attr + " property is deprecated and will be removed soon. Look at Konva change log for more information.";
        constructor.prototype[method] = function() {
          Util_1.Util.error(message);
          var val = this.attrs[attr];
          return val === void 0 ? def : val;
        }, exports.Factory.addSetter(constructor, attr, validator, function() {
          Util_1.Util.error(message);
        }), exports.Factory.addOverloadedGetterSetter(constructor, attr);
      },
      backCompat(constructor, methods) {
        Util_1.Util.each(methods, function(oldMethodName, newMethodName) {
          var method = constructor.prototype[newMethodName], oldGetter = GET2 + Util_1.Util._capitalize(oldMethodName), oldSetter = SET3 + Util_1.Util._capitalize(oldMethodName);
          function deprecated() {
            method.apply(this, arguments), Util_1.Util.error('"' + oldMethodName + '" method is deprecated and will be removed soon. Use ""' + newMethodName + '" instead.');
          }
          constructor.prototype[oldMethodName] = deprecated, constructor.prototype[oldGetter] = deprecated, constructor.prototype[oldSetter] = deprecated;
        });
      },
      afterSetFilter() {
        this._filterUpToDate = !1;
      }
    };
  }
});

// node_modules/konva/cmj/Context.js
var require_Context = __commonJS({
  "node_modules/konva/cmj/Context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.HitContext = exports.SceneContext = exports.Context = void 0;
    var Util_1 = require_Util(), Global_1 = require_Global2();
    function simplifyArray2(arr) {
      var retArr = [], len = arr.length, util = Util_1.Util, n, val;
      for (n = 0; n < len; n++)
        val = arr[n], util._isNumber(val) ? val = Math.round(val * 1e3) / 1e3 : util._isString(val) || (val = val + ""), retArr.push(val);
      return retArr;
    }
    var COMMA2 = ",", OPEN_PAREN2 = "(", CLOSE_PAREN2 = ")", OPEN_PAREN_BRACKET2 = "([", CLOSE_BRACKET_PAREN2 = "])", SEMICOLON2 = ";", DOUBLE_PAREN2 = "()", EQUALS2 = "=", CONTEXT_METHODS2 = [
      "arc",
      "arcTo",
      "beginPath",
      "bezierCurveTo",
      "clearRect",
      "clip",
      "closePath",
      "createLinearGradient",
      "createPattern",
      "createRadialGradient",
      "drawImage",
      "ellipse",
      "fill",
      "fillText",
      "getImageData",
      "createImageData",
      "lineTo",
      "moveTo",
      "putImageData",
      "quadraticCurveTo",
      "rect",
      "restore",
      "rotate",
      "save",
      "scale",
      "setLineDash",
      "setTransform",
      "stroke",
      "strokeText",
      "transform",
      "translate"
    ], CONTEXT_PROPERTIES2 = [
      "fillStyle",
      "strokeStyle",
      "shadowColor",
      "shadowBlur",
      "shadowOffsetX",
      "shadowOffsetY",
      "lineCap",
      "lineDashOffset",
      "lineJoin",
      "lineWidth",
      "miterLimit",
      "font",
      "textAlign",
      "textBaseline",
      "globalAlpha",
      "globalCompositeOperation",
      "imageSmoothingEnabled"
    ], traceArrMax2 = 100, Context2 = class {
      constructor(canvas) {
        this.canvas = canvas, Global_1.Konva.enableTrace && (this.traceArr = [], this._enableTrace());
      }
      fillShape(shape) {
        shape.fillEnabled() && this._fill(shape);
      }
      _fill(shape) {
      }
      strokeShape(shape) {
        shape.hasStroke() && this._stroke(shape);
      }
      _stroke(shape) {
      }
      fillStrokeShape(shape) {
        shape.attrs.fillAfterStrokeEnabled ? (this.strokeShape(shape), this.fillShape(shape)) : (this.fillShape(shape), this.strokeShape(shape));
      }
      getTrace(relaxed, rounded) {
        var traceArr = this.traceArr, len = traceArr.length, str = "", n, trace, method, args;
        for (n = 0; n < len; n++)
          trace = traceArr[n], method = trace.method, method ? (args = trace.args, str += method, relaxed ? str += DOUBLE_PAREN2 : Util_1.Util._isArray(args[0]) ? str += OPEN_PAREN_BRACKET2 + args.join(COMMA2) + CLOSE_BRACKET_PAREN2 : (rounded && (args = args.map((a) => typeof a == "number" ? Math.floor(a) : a)), str += OPEN_PAREN2 + args.join(COMMA2) + CLOSE_PAREN2)) : (str += trace.property, relaxed || (str += EQUALS2 + trace.val)), str += SEMICOLON2;
        return str;
      }
      clearTrace() {
        this.traceArr = [];
      }
      _trace(str) {
        var traceArr = this.traceArr, len;
        traceArr.push(str), len = traceArr.length, len >= traceArrMax2 && traceArr.shift();
      }
      reset() {
        var pixelRatio = this.getCanvas().getPixelRatio();
        this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);
      }
      getCanvas() {
        return this.canvas;
      }
      clear(bounds) {
        var canvas = this.getCanvas();
        bounds ? this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0) : this.clearRect(0, 0, canvas.getWidth() / canvas.pixelRatio, canvas.getHeight() / canvas.pixelRatio);
      }
      _applyLineCap(shape) {
        var lineCap = shape.getLineCap();
        lineCap && this.setAttr("lineCap", lineCap);
      }
      _applyOpacity(shape) {
        var absOpacity = shape.getAbsoluteOpacity();
        absOpacity !== 1 && this.setAttr("globalAlpha", absOpacity);
      }
      _applyLineJoin(shape) {
        var lineJoin = shape.attrs.lineJoin;
        lineJoin && this.setAttr("lineJoin", lineJoin);
      }
      setAttr(attr, val) {
        this._context[attr] = val;
      }
      arc(a0, a1, a2, a3, a4, a5) {
        this._context.arc(a0, a1, a2, a3, a4, a5);
      }
      arcTo(a0, a1, a2, a3, a4) {
        this._context.arcTo(a0, a1, a2, a3, a4);
      }
      beginPath() {
        this._context.beginPath();
      }
      bezierCurveTo(a0, a1, a2, a3, a4, a5) {
        this._context.bezierCurveTo(a0, a1, a2, a3, a4, a5);
      }
      clearRect(a0, a1, a2, a3) {
        this._context.clearRect(a0, a1, a2, a3);
      }
      clip() {
        this._context.clip();
      }
      closePath() {
        this._context.closePath();
      }
      createImageData(a0, a1) {
        var a = arguments;
        if (a.length === 2)
          return this._context.createImageData(a0, a1);
        if (a.length === 1)
          return this._context.createImageData(a0);
      }
      createLinearGradient(a0, a1, a2, a3) {
        return this._context.createLinearGradient(a0, a1, a2, a3);
      }
      createPattern(a0, a1) {
        return this._context.createPattern(a0, a1);
      }
      createRadialGradient(a0, a1, a2, a3, a4, a5) {
        return this._context.createRadialGradient(a0, a1, a2, a3, a4, a5);
      }
      drawImage(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        var a = arguments, _context = this._context;
        a.length === 3 ? _context.drawImage(a0, a1, a2) : a.length === 5 ? _context.drawImage(a0, a1, a2, a3, a4) : a.length === 9 && _context.drawImage(a0, a1, a2, a3, a4, a5, a6, a7, a8);
      }
      ellipse(a0, a1, a2, a3, a4, a5, a6, a7) {
        this._context.ellipse(a0, a1, a2, a3, a4, a5, a6, a7);
      }
      isPointInPath(x, y) {
        return this._context.isPointInPath(x, y);
      }
      fill(path2d) {
        path2d ? this._context.fill(path2d) : this._context.fill();
      }
      fillRect(x, y, width, height) {
        this._context.fillRect(x, y, width, height);
      }
      strokeRect(x, y, width, height) {
        this._context.strokeRect(x, y, width, height);
      }
      fillText(text, x, y, maxWidth) {
        maxWidth ? this._context.fillText(text, x, y, maxWidth) : this._context.fillText(text, x, y);
      }
      measureText(text) {
        return this._context.measureText(text);
      }
      getImageData(a0, a1, a2, a3) {
        return this._context.getImageData(a0, a1, a2, a3);
      }
      lineTo(a0, a1) {
        this._context.lineTo(a0, a1);
      }
      moveTo(a0, a1) {
        this._context.moveTo(a0, a1);
      }
      rect(a0, a1, a2, a3) {
        this._context.rect(a0, a1, a2, a3);
      }
      putImageData(a0, a1, a2) {
        this._context.putImageData(a0, a1, a2);
      }
      quadraticCurveTo(a0, a1, a2, a3) {
        this._context.quadraticCurveTo(a0, a1, a2, a3);
      }
      restore() {
        this._context.restore();
      }
      rotate(a0) {
        this._context.rotate(a0);
      }
      save() {
        this._context.save();
      }
      scale(a0, a1) {
        this._context.scale(a0, a1);
      }
      setLineDash(a0) {
        this._context.setLineDash ? this._context.setLineDash(a0) : "mozDash" in this._context ? this._context.mozDash = a0 : "webkitLineDash" in this._context && (this._context.webkitLineDash = a0);
      }
      getLineDash() {
        return this._context.getLineDash();
      }
      setTransform(a0, a1, a2, a3, a4, a5) {
        this._context.setTransform(a0, a1, a2, a3, a4, a5);
      }
      stroke(path2d) {
        path2d ? this._context.stroke(path2d) : this._context.stroke();
      }
      strokeText(a0, a1, a2, a3) {
        this._context.strokeText(a0, a1, a2, a3);
      }
      transform(a0, a1, a2, a3, a4, a5) {
        this._context.transform(a0, a1, a2, a3, a4, a5);
      }
      translate(a0, a1) {
        this._context.translate(a0, a1);
      }
      _enableTrace() {
        var that = this, len = CONTEXT_METHODS2.length, origSetter = this.setAttr, n, args, func = function(methodName) {
          var origMethod = that[methodName], ret;
          that[methodName] = function() {
            return args = simplifyArray2(Array.prototype.slice.call(arguments, 0)), ret = origMethod.apply(that, arguments), that._trace({
              method: methodName,
              args
            }), ret;
          };
        };
        for (n = 0; n < len; n++)
          func(CONTEXT_METHODS2[n]);
        that.setAttr = function() {
          origSetter.apply(that, arguments);
          var prop = arguments[0], val = arguments[1];
          (prop === "shadowOffsetX" || prop === "shadowOffsetY" || prop === "shadowBlur") && (val = val / this.canvas.getPixelRatio()), that._trace({
            property: prop,
            val
          });
        };
      }
      _applyGlobalCompositeOperation(node) {
        let op = node.attrs.globalCompositeOperation;
        var def = !op || op === "source-over";
        def || this.setAttr("globalCompositeOperation", op);
      }
    };
    exports.Context = Context2;
    CONTEXT_PROPERTIES2.forEach(function(prop) {
      Object.defineProperty(Context2.prototype, prop, {
        get() {
          return this._context[prop];
        },
        set(val) {
          this._context[prop] = val;
        }
      });
    });
    var SceneContext2 = class extends Context2 {
      constructor(canvas) {
        super(canvas), this._context = canvas._canvas.getContext("2d");
      }
      _fillColor(shape) {
        var fill = shape.fill();
        this.setAttr("fillStyle", fill), shape._fillFunc(this);
      }
      _fillPattern(shape) {
        this.setAttr("fillStyle", shape._getFillPattern()), shape._fillFunc(this);
      }
      _fillLinearGradient(shape) {
        var grd = shape._getLinearGradient();
        grd && (this.setAttr("fillStyle", grd), shape._fillFunc(this));
      }
      _fillRadialGradient(shape) {
        var grd = shape._getRadialGradient();
        grd && (this.setAttr("fillStyle", grd), shape._fillFunc(this));
      }
      _fill(shape) {
        var hasColor = shape.fill(), fillPriority = shape.getFillPriority();
        if (hasColor && fillPriority === "color") {
          this._fillColor(shape);
          return;
        }
        var hasPattern = shape.getFillPatternImage();
        if (hasPattern && fillPriority === "pattern") {
          this._fillPattern(shape);
          return;
        }
        var hasLinearGradient = shape.getFillLinearGradientColorStops();
        if (hasLinearGradient && fillPriority === "linear-gradient") {
          this._fillLinearGradient(shape);
          return;
        }
        var hasRadialGradient = shape.getFillRadialGradientColorStops();
        if (hasRadialGradient && fillPriority === "radial-gradient") {
          this._fillRadialGradient(shape);
          return;
        }
        hasColor ? this._fillColor(shape) : hasPattern ? this._fillPattern(shape) : hasLinearGradient ? this._fillLinearGradient(shape) : hasRadialGradient && this._fillRadialGradient(shape);
      }
      _strokeLinearGradient(shape) {
        var start = shape.getStrokeLinearGradientStartPoint(), end = shape.getStrokeLinearGradientEndPoint(), colorStops = shape.getStrokeLinearGradientColorStops(), grd = this.createLinearGradient(start.x, start.y, end.x, end.y);
        if (colorStops) {
          for (var n = 0; n < colorStops.length; n += 2)
            grd.addColorStop(colorStops[n], colorStops[n + 1]);
          this.setAttr("strokeStyle", grd);
        }
      }
      _stroke(shape) {
        var dash = shape.dash(), strokeScaleEnabled = shape.getStrokeScaleEnabled();
        if (shape.hasStroke()) {
          if (!strokeScaleEnabled) {
            this.save();
            var pixelRatio = this.getCanvas().getPixelRatio();
            this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
          }
          this._applyLineCap(shape), dash && shape.dashEnabled() && (this.setLineDash(dash), this.setAttr("lineDashOffset", shape.dashOffset())), this.setAttr("lineWidth", shape.strokeWidth()), shape.getShadowForStrokeEnabled() || this.setAttr("shadowColor", "rgba(0,0,0,0)");
          var hasLinearGradient = shape.getStrokeLinearGradientColorStops();
          hasLinearGradient ? this._strokeLinearGradient(shape) : this.setAttr("strokeStyle", shape.stroke()), shape._strokeFunc(this), strokeScaleEnabled || this.restore();
        }
      }
      _applyShadow(shape) {
        var _a, _b, _c, color = (_a = shape.getShadowRGBA()) !== null && _a !== void 0 ? _a : "black", blur = (_b = shape.getShadowBlur()) !== null && _b !== void 0 ? _b : 5, offset = (_c = shape.getShadowOffset()) !== null && _c !== void 0 ? _c : {
          x: 0,
          y: 0
        }, scale = shape.getAbsoluteScale(), ratio = this.canvas.getPixelRatio(), scaleX = scale.x * ratio, scaleY = scale.y * ratio;
        this.setAttr("shadowColor", color), this.setAttr("shadowBlur", blur * Math.min(Math.abs(scaleX), Math.abs(scaleY))), this.setAttr("shadowOffsetX", offset.x * scaleX), this.setAttr("shadowOffsetY", offset.y * scaleY);
      }
    };
    exports.SceneContext = SceneContext2;
    var HitContext2 = class extends Context2 {
      constructor(canvas) {
        super(canvas), this._context = canvas._canvas.getContext("2d", {
          willReadFrequently: !0
        });
      }
      _fill(shape) {
        this.save(), this.setAttr("fillStyle", shape.colorKey), shape._fillFuncHit(this), this.restore();
      }
      strokeShape(shape) {
        shape.hasHitStroke() && this._stroke(shape);
      }
      _stroke(shape) {
        if (shape.hasHitStroke()) {
          var strokeScaleEnabled = shape.getStrokeScaleEnabled();
          if (!strokeScaleEnabled) {
            this.save();
            var pixelRatio = this.getCanvas().getPixelRatio();
            this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
          }
          this._applyLineCap(shape);
          var hitStrokeWidth = shape.hitStrokeWidth(), strokeWidth = hitStrokeWidth === "auto" ? shape.strokeWidth() : hitStrokeWidth;
          this.setAttr("lineWidth", strokeWidth), this.setAttr("strokeStyle", shape.colorKey), shape._strokeFuncHit(this), strokeScaleEnabled || this.restore();
        }
      }
    };
    exports.HitContext = HitContext2;
  }
});

// node_modules/konva/cmj/Canvas.js
var require_Canvas = __commonJS({
  "node_modules/konva/cmj/Canvas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.HitCanvas = exports.SceneCanvas = exports.Canvas = void 0;
    var Util_1 = require_Util(), Context_1 = require_Context(), Global_1 = require_Global2(), Factory_1 = require_Factory(), Validators_1 = require_Validators(), _pixelRatio2;
    function getDevicePixelRatio2() {
      if (_pixelRatio2)
        return _pixelRatio2;
      var canvas = Util_1.Util.createCanvasElement(), context = canvas.getContext("2d");
      return _pixelRatio2 = function() {
        var devicePixelRatio = Global_1.Konva._global.devicePixelRatio || 1, backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
        return devicePixelRatio / backingStoreRatio;
      }(), Util_1.Util.releaseCanvas(canvas), _pixelRatio2;
    }
    var Canvas2 = class {
      constructor(config) {
        this.pixelRatio = 1, this.width = 0, this.height = 0, this.isCache = !1;
        var conf = config || {}, pixelRatio = conf.pixelRatio || Global_1.Konva.pixelRatio || getDevicePixelRatio2();
        this.pixelRatio = pixelRatio, this._canvas = Util_1.Util.createCanvasElement(), this._canvas.style.padding = "0", this._canvas.style.margin = "0", this._canvas.style.border = "0", this._canvas.style.background = "transparent", this._canvas.style.position = "absolute", this._canvas.style.top = "0", this._canvas.style.left = "0";
      }
      getContext() {
        return this.context;
      }
      getPixelRatio() {
        return this.pixelRatio;
      }
      setPixelRatio(pixelRatio) {
        var previousRatio = this.pixelRatio;
        this.pixelRatio = pixelRatio, this.setSize(this.getWidth() / previousRatio, this.getHeight() / previousRatio);
      }
      setWidth(width) {
        this.width = this._canvas.width = width * this.pixelRatio, this._canvas.style.width = width + "px";
        var pixelRatio = this.pixelRatio, _context = this.getContext()._context;
        _context.scale(pixelRatio, pixelRatio);
      }
      setHeight(height) {
        this.height = this._canvas.height = height * this.pixelRatio, this._canvas.style.height = height + "px";
        var pixelRatio = this.pixelRatio, _context = this.getContext()._context;
        _context.scale(pixelRatio, pixelRatio);
      }
      getWidth() {
        return this.width;
      }
      getHeight() {
        return this.height;
      }
      setSize(width, height) {
        this.setWidth(width || 0), this.setHeight(height || 0);
      }
      toDataURL(mimeType, quality) {
        try {
          return this._canvas.toDataURL(mimeType, quality);
        } catch {
          try {
            return this._canvas.toDataURL();
          } catch (err) {
            return Util_1.Util.error("Unable to get data URL. " + err.message + " For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html."), "";
          }
        }
      }
    };
    exports.Canvas = Canvas2;
    Factory_1.Factory.addGetterSetter(Canvas2, "pixelRatio", void 0, (0, Validators_1.getNumberValidator)());
    var SceneCanvas2 = class extends Canvas2 {
      constructor(config = { width: 0, height: 0 }) {
        super(config), this.context = new Context_1.SceneContext(this), this.setSize(config.width, config.height);
      }
    };
    exports.SceneCanvas = SceneCanvas2;
    var HitCanvas2 = class extends Canvas2 {
      constructor(config = { width: 0, height: 0 }) {
        super(config), this.hitCanvas = !0, this.context = new Context_1.HitContext(this), this.setSize(config.width, config.height);
      }
    };
    exports.HitCanvas = HitCanvas2;
  }
});

// node_modules/konva/cmj/DragAndDrop.js
var require_DragAndDrop = __commonJS({
  "node_modules/konva/cmj/DragAndDrop.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.DD = void 0;
    var Global_1 = require_Global2(), Util_1 = require_Util();
    exports.DD = {
      get isDragging() {
        var flag = !1;
        return exports.DD._dragElements.forEach((elem) => {
          elem.dragStatus === "dragging" && (flag = !0);
        }), flag;
      },
      justDragged: !1,
      get node() {
        var node;
        return exports.DD._dragElements.forEach((elem) => {
          node = elem.node;
        }), node;
      },
      _dragElements: /* @__PURE__ */ new Map(),
      _drag(evt) {
        let nodesToFireEvents = [];
        exports.DD._dragElements.forEach((elem, key) => {
          let { node } = elem, stage = node.getStage();
          stage.setPointersPositions(evt), elem.pointerId === void 0 && (elem.pointerId = Util_1.Util._getFirstPointerId(evt));
          let pos = stage._changedPointerPositions.find((pos2) => pos2.id === elem.pointerId);
          if (!!pos) {
            if (elem.dragStatus !== "dragging") {
              var dragDistance = node.dragDistance(), distance = Math.max(Math.abs(pos.x - elem.startPointerPos.x), Math.abs(pos.y - elem.startPointerPos.y));
              if (distance < dragDistance || (node.startDrag({ evt }), !node.isDragging()))
                return;
            }
            node._setDragPosition(evt, elem), nodesToFireEvents.push(node);
          }
        }), nodesToFireEvents.forEach((node) => {
          node.fire("dragmove", {
            type: "dragmove",
            target: node,
            evt
          }, !0);
        });
      },
      _endDragBefore(evt) {
        let drawNodes = [];
        exports.DD._dragElements.forEach((elem) => {
          let { node } = elem, stage = node.getStage();
          if (evt && stage.setPointersPositions(evt), !stage._changedPointerPositions.find((pos2) => pos2.id === elem.pointerId))
            return;
          (elem.dragStatus === "dragging" || elem.dragStatus === "stopped") && (exports.DD.justDragged = !0, Global_1.Konva._mouseListenClick = !1, Global_1.Konva._touchListenClick = !1, Global_1.Konva._pointerListenClick = !1, elem.dragStatus = "stopped");
          let drawNode = elem.node.getLayer() || elem.node instanceof Global_1.Konva.Stage && elem.node;
          drawNode && drawNodes.indexOf(drawNode) === -1 && drawNodes.push(drawNode);
        }), drawNodes.forEach((drawNode) => {
          drawNode.draw();
        });
      },
      _endDragAfter(evt) {
        exports.DD._dragElements.forEach((elem, key) => {
          elem.dragStatus === "stopped" && elem.node.fire("dragend", {
            type: "dragend",
            target: elem.node,
            evt
          }, !0), elem.dragStatus !== "dragging" && exports.DD._dragElements.delete(key);
        });
      }
    };
    Global_1.Konva.isBrowser && (window.addEventListener("mouseup", exports.DD._endDragBefore, !0), window.addEventListener("touchend", exports.DD._endDragBefore, !0), window.addEventListener("mousemove", exports.DD._drag), window.addEventListener("touchmove", exports.DD._drag), window.addEventListener("mouseup", exports.DD._endDragAfter, !1), window.addEventListener("touchend", exports.DD._endDragAfter, !1));
  }
});

// node_modules/konva/cmj/Node.js
var require_Node = __commonJS({
  "node_modules/konva/cmj/Node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Node = void 0;
    var Util_1 = require_Util(), Factory_1 = require_Factory(), Canvas_1 = require_Canvas(), Global_1 = require_Global2(), DragAndDrop_1 = require_DragAndDrop(), Validators_1 = require_Validators(), ABSOLUTE_OPACITY2 = "absoluteOpacity", ALL_LISTENERS2 = "allEventListeners", ABSOLUTE_TRANSFORM2 = "absoluteTransform", ABSOLUTE_SCALE2 = "absoluteScale", CANVAS2 = "canvas", CHANGE2 = "Change", CHILDREN2 = "children", KONVA2 = "konva", LISTENING2 = "listening", MOUSEENTER3 = "mouseenter", MOUSELEAVE3 = "mouseleave", SET3 = "set", SHAPE2 = "Shape", SPACE2 = " ", STAGE3 = "stage", TRANSFORM2 = "transform", UPPER_STAGE2 = "Stage", VISIBLE2 = "visible", TRANSFORM_CHANGE_STR2 = [
      "xChange.konva",
      "yChange.konva",
      "scaleXChange.konva",
      "scaleYChange.konva",
      "skewXChange.konva",
      "skewYChange.konva",
      "rotationChange.konva",
      "offsetXChange.konva",
      "offsetYChange.konva",
      "transformsEnabledChange.konva"
    ].join(SPACE2), idCounter3 = 1, Node2 = class {
      constructor(config) {
        this._id = idCounter3++, this.eventListeners = {}, this.attrs = {}, this.index = 0, this._allEventListeners = null, this.parent = null, this._cache = /* @__PURE__ */ new Map(), this._attachedDepsListeners = /* @__PURE__ */ new Map(), this._lastPos = null, this._batchingTransformChange = !1, this._needClearTransformCache = !1, this._filterUpToDate = !1, this._isUnderCache = !1, this._dragEventId = null, this._shouldFireChangeEvents = !1, this.setAttrs(config), this._shouldFireChangeEvents = !0;
      }
      hasChildren() {
        return !1;
      }
      _clearCache(attr) {
        (attr === TRANSFORM2 || attr === ABSOLUTE_TRANSFORM2) && this._cache.get(attr) ? this._cache.get(attr).dirty = !0 : attr ? this._cache.delete(attr) : this._cache.clear();
      }
      _getCache(attr, privateGetter) {
        var cache = this._cache.get(attr), isTransform = attr === TRANSFORM2 || attr === ABSOLUTE_TRANSFORM2, invalid = cache === void 0 || isTransform && cache.dirty === !0;
        return invalid && (cache = privateGetter.call(this), this._cache.set(attr, cache)), cache;
      }
      _calculate(name, deps, getter) {
        if (!this._attachedDepsListeners.get(name)) {
          let depsString = deps.map((dep) => dep + "Change.konva").join(SPACE2);
          this.on(depsString, () => {
            this._clearCache(name);
          }), this._attachedDepsListeners.set(name, !0);
        }
        return this._getCache(name, getter);
      }
      _getCanvasCache() {
        return this._cache.get(CANVAS2);
      }
      _clearSelfAndDescendantCache(attr) {
        this._clearCache(attr), attr === ABSOLUTE_TRANSFORM2 && this.fire("absoluteTransformChange");
      }
      clearCache() {
        if (this._cache.has(CANVAS2)) {
          let { scene, filter, hit } = this._cache.get(CANVAS2);
          Util_1.Util.releaseCanvas(scene, filter, hit), this._cache.delete(CANVAS2);
        }
        return this._clearSelfAndDescendantCache(), this._requestDraw(), this;
      }
      cache(config) {
        var conf = config || {}, rect = {};
        (conf.x === void 0 || conf.y === void 0 || conf.width === void 0 || conf.height === void 0) && (rect = this.getClientRect({
          skipTransform: !0,
          relativeTo: this.getParent()
        }));
        var width = Math.ceil(conf.width || rect.width), height = Math.ceil(conf.height || rect.height), pixelRatio = conf.pixelRatio, x = conf.x === void 0 ? Math.floor(rect.x) : conf.x, y = conf.y === void 0 ? Math.floor(rect.y) : conf.y, offset = conf.offset || 0, drawBorder = conf.drawBorder || !1, hitCanvasPixelRatio = conf.hitCanvasPixelRatio || 1;
        if (!width || !height) {
          Util_1.Util.error("Can not cache the node. Width or height of the node equals 0. Caching is skipped.");
          return;
        }
        width += offset * 2 + 1, height += offset * 2 + 1, x -= offset, y -= offset;
        var cachedSceneCanvas = new Canvas_1.SceneCanvas({
          pixelRatio,
          width,
          height
        }), cachedFilterCanvas = new Canvas_1.SceneCanvas({
          pixelRatio,
          width: 0,
          height: 0
        }), cachedHitCanvas = new Canvas_1.HitCanvas({
          pixelRatio: hitCanvasPixelRatio,
          width,
          height
        }), sceneContext = cachedSceneCanvas.getContext(), hitContext = cachedHitCanvas.getContext();
        return cachedHitCanvas.isCache = !0, cachedSceneCanvas.isCache = !0, this._cache.delete(CANVAS2), this._filterUpToDate = !1, conf.imageSmoothingEnabled === !1 && (cachedSceneCanvas.getContext()._context.imageSmoothingEnabled = !1, cachedFilterCanvas.getContext()._context.imageSmoothingEnabled = !1), sceneContext.save(), hitContext.save(), sceneContext.translate(-x, -y), hitContext.translate(-x, -y), this._isUnderCache = !0, this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY2), this._clearSelfAndDescendantCache(ABSOLUTE_SCALE2), this.drawScene(cachedSceneCanvas, this), this.drawHit(cachedHitCanvas, this), this._isUnderCache = !1, sceneContext.restore(), hitContext.restore(), drawBorder && (sceneContext.save(), sceneContext.beginPath(), sceneContext.rect(0, 0, width, height), sceneContext.closePath(), sceneContext.setAttr("strokeStyle", "red"), sceneContext.setAttr("lineWidth", 5), sceneContext.stroke(), sceneContext.restore()), this._cache.set(CANVAS2, {
          scene: cachedSceneCanvas,
          filter: cachedFilterCanvas,
          hit: cachedHitCanvas,
          x,
          y
        }), this._requestDraw(), this;
      }
      isCached() {
        return this._cache.has(CANVAS2);
      }
      getClientRect(config) {
        throw new Error('abstract "getClientRect" method call');
      }
      _transformedRect(rect, top) {
        var points = [
          { x: rect.x, y: rect.y },
          { x: rect.x + rect.width, y: rect.y },
          { x: rect.x + rect.width, y: rect.y + rect.height },
          { x: rect.x, y: rect.y + rect.height }
        ], minX, minY, maxX, maxY, trans = this.getAbsoluteTransform(top);
        return points.forEach(function(point) {
          var transformed = trans.point(point);
          minX === void 0 && (minX = maxX = transformed.x, minY = maxY = transformed.y), minX = Math.min(minX, transformed.x), minY = Math.min(minY, transformed.y), maxX = Math.max(maxX, transformed.x), maxY = Math.max(maxY, transformed.y);
        }), {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
      }
      _drawCachedSceneCanvas(context) {
        context.save(), context._applyOpacity(this), context._applyGlobalCompositeOperation(this);
        let canvasCache = this._getCanvasCache();
        context.translate(canvasCache.x, canvasCache.y);
        var cacheCanvas = this._getCachedSceneCanvas(), ratio = cacheCanvas.pixelRatio;
        context.drawImage(cacheCanvas._canvas, 0, 0, cacheCanvas.width / ratio, cacheCanvas.height / ratio), context.restore();
      }
      _drawCachedHitCanvas(context) {
        var canvasCache = this._getCanvasCache(), hitCanvas = canvasCache.hit;
        context.save(), context.translate(canvasCache.x, canvasCache.y), context.drawImage(hitCanvas._canvas, 0, 0, hitCanvas.width / hitCanvas.pixelRatio, hitCanvas.height / hitCanvas.pixelRatio), context.restore();
      }
      _getCachedSceneCanvas() {
        var filters = this.filters(), cachedCanvas = this._getCanvasCache(), sceneCanvas = cachedCanvas.scene, filterCanvas = cachedCanvas.filter, filterContext = filterCanvas.getContext(), len, imageData, n, filter;
        if (filters) {
          if (!this._filterUpToDate) {
            var ratio = sceneCanvas.pixelRatio;
            filterCanvas.setSize(sceneCanvas.width / sceneCanvas.pixelRatio, sceneCanvas.height / sceneCanvas.pixelRatio);
            try {
              for (len = filters.length, filterContext.clear(), filterContext.drawImage(sceneCanvas._canvas, 0, 0, sceneCanvas.getWidth() / ratio, sceneCanvas.getHeight() / ratio), imageData = filterContext.getImageData(0, 0, filterCanvas.getWidth(), filterCanvas.getHeight()), n = 0; n < len; n++) {
                if (filter = filters[n], typeof filter != "function") {
                  Util_1.Util.error("Filter should be type of function, but got " + typeof filter + " instead. Please check correct filters");
                  continue;
                }
                filter.call(this, imageData), filterContext.putImageData(imageData, 0, 0);
              }
            } catch (e) {
              Util_1.Util.error("Unable to apply filter. " + e.message + " This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.");
            }
            this._filterUpToDate = !0;
          }
          return filterCanvas;
        }
        return sceneCanvas;
      }
      on(evtStr, handler) {
        if (this._cache && this._cache.delete(ALL_LISTENERS2), arguments.length === 3)
          return this._delegate.apply(this, arguments);
        var events = evtStr.split(SPACE2), len = events.length, n, event, parts, baseEvent, name;
        for (n = 0; n < len; n++)
          event = events[n], parts = event.split("."), baseEvent = parts[0], name = parts[1] || "", this.eventListeners[baseEvent] || (this.eventListeners[baseEvent] = []), this.eventListeners[baseEvent].push({
            name,
            handler
          });
        return this;
      }
      off(evtStr, callback) {
        var events = (evtStr || "").split(SPACE2), len = events.length, n, t, event, parts, baseEvent, name;
        if (this._cache && this._cache.delete(ALL_LISTENERS2), !evtStr)
          for (t in this.eventListeners)
            this._off(t);
        for (n = 0; n < len; n++)
          if (event = events[n], parts = event.split("."), baseEvent = parts[0], name = parts[1], baseEvent)
            this.eventListeners[baseEvent] && this._off(baseEvent, name, callback);
          else
            for (t in this.eventListeners)
              this._off(t, name, callback);
        return this;
      }
      dispatchEvent(evt) {
        var e = {
          target: this,
          type: evt.type,
          evt
        };
        return this.fire(evt.type, e), this;
      }
      addEventListener(type, handler) {
        return this.on(type, function(evt) {
          handler.call(this, evt.evt);
        }), this;
      }
      removeEventListener(type) {
        return this.off(type), this;
      }
      _delegate(event, selector, handler) {
        var stopNode = this;
        this.on(event, function(evt) {
          for (var targets = evt.target.findAncestors(selector, !0, stopNode), i = 0; i < targets.length; i++)
            evt = Util_1.Util.cloneObject(evt), evt.currentTarget = targets[i], handler.call(targets[i], evt);
        });
      }
      remove() {
        return this.isDragging() && this.stopDrag(), DragAndDrop_1.DD._dragElements.delete(this._id), this._remove(), this;
      }
      _clearCaches() {
        this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM2), this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY2), this._clearSelfAndDescendantCache(ABSOLUTE_SCALE2), this._clearSelfAndDescendantCache(STAGE3), this._clearSelfAndDescendantCache(VISIBLE2), this._clearSelfAndDescendantCache(LISTENING2);
      }
      _remove() {
        this._clearCaches();
        var parent = this.getParent();
        parent && parent.children && (parent.children.splice(this.index, 1), parent._setChildrenIndices(), this.parent = null);
      }
      destroy() {
        return this.remove(), this.clearCache(), this;
      }
      getAttr(attr) {
        var method = "get" + Util_1.Util._capitalize(attr);
        return Util_1.Util._isFunction(this[method]) ? this[method]() : this.attrs[attr];
      }
      getAncestors() {
        for (var parent = this.getParent(), ancestors = []; parent; )
          ancestors.push(parent), parent = parent.getParent();
        return ancestors;
      }
      getAttrs() {
        return this.attrs || {};
      }
      setAttrs(config) {
        return this._batchTransformChanges(() => {
          var key, method;
          if (!config)
            return this;
          for (key in config)
            key !== CHILDREN2 && (method = SET3 + Util_1.Util._capitalize(key), Util_1.Util._isFunction(this[method]) ? this[method](config[key]) : this._setAttr(key, config[key]));
        }), this;
      }
      isListening() {
        return this._getCache(LISTENING2, this._isListening);
      }
      _isListening(relativeTo) {
        if (!this.listening())
          return !1;
        let parent = this.getParent();
        return parent && parent !== relativeTo && this !== relativeTo ? parent._isListening(relativeTo) : !0;
      }
      isVisible() {
        return this._getCache(VISIBLE2, this._isVisible);
      }
      _isVisible(relativeTo) {
        if (!this.visible())
          return !1;
        let parent = this.getParent();
        return parent && parent !== relativeTo && this !== relativeTo ? parent._isVisible(relativeTo) : !0;
      }
      shouldDrawHit(top, skipDragCheck = !1) {
        if (top)
          return this._isVisible(top) && this._isListening(top);
        var layer = this.getLayer(), layerUnderDrag = !1;
        DragAndDrop_1.DD._dragElements.forEach((elem) => {
          elem.dragStatus === "dragging" && (elem.node.nodeType === "Stage" || elem.node.getLayer() === layer) && (layerUnderDrag = !0);
        });
        var dragSkip = !skipDragCheck && !Global_1.Konva.hitOnDragEnabled && layerUnderDrag;
        return this.isListening() && this.isVisible() && !dragSkip;
      }
      show() {
        return this.visible(!0), this;
      }
      hide() {
        return this.visible(!1), this;
      }
      getZIndex() {
        return this.index || 0;
      }
      getAbsoluteZIndex() {
        var depth = this.getDepth(), that = this, index = 0, nodes, len, n, child;
        function addChildren(children) {
          for (nodes = [], len = children.length, n = 0; n < len; n++)
            child = children[n], index++, child.nodeType !== SHAPE2 && (nodes = nodes.concat(child.getChildren().slice())), child._id === that._id && (n = len);
          nodes.length > 0 && nodes[0].getDepth() <= depth && addChildren(nodes);
        }
        return that.nodeType !== UPPER_STAGE2 && addChildren(that.getStage().getChildren()), index;
      }
      getDepth() {
        for (var depth = 0, parent = this.parent; parent; )
          depth++, parent = parent.parent;
        return depth;
      }
      _batchTransformChanges(func) {
        this._batchingTransformChange = !0, func(), this._batchingTransformChange = !1, this._needClearTransformCache && (this._clearCache(TRANSFORM2), this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM2)), this._needClearTransformCache = !1;
      }
      setPosition(pos) {
        return this._batchTransformChanges(() => {
          this.x(pos.x), this.y(pos.y);
        }), this;
      }
      getPosition() {
        return {
          x: this.x(),
          y: this.y()
        };
      }
      getRelativePointerPosition() {
        if (!this.getStage())
          return null;
        var pos = this.getStage().getPointerPosition();
        if (!pos)
          return null;
        var transform = this.getAbsoluteTransform().copy();
        return transform.invert(), transform.point(pos);
      }
      getAbsolutePosition(top) {
        let haveCachedParent = !1, parent = this.parent;
        for (; parent; ) {
          if (parent.isCached()) {
            haveCachedParent = !0;
            break;
          }
          parent = parent.parent;
        }
        haveCachedParent && !top && (top = !0);
        var absoluteMatrix = this.getAbsoluteTransform(top).getMatrix(), absoluteTransform = new Util_1.Transform(), offset = this.offset();
        return absoluteTransform.m = absoluteMatrix.slice(), absoluteTransform.translate(offset.x, offset.y), absoluteTransform.getTranslation();
      }
      setAbsolutePosition(pos) {
        var origTrans = this._clearTransform();
        this.attrs.x = origTrans.x, this.attrs.y = origTrans.y, delete origTrans.x, delete origTrans.y, this._clearCache(TRANSFORM2);
        var it = this._getAbsoluteTransform().copy();
        return it.invert(), it.translate(pos.x, pos.y), pos = {
          x: this.attrs.x + it.getTranslation().x,
          y: this.attrs.y + it.getTranslation().y
        }, this._setTransform(origTrans), this.setPosition({ x: pos.x, y: pos.y }), this._clearCache(TRANSFORM2), this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM2), this;
      }
      _setTransform(trans) {
        var key;
        for (key in trans)
          this.attrs[key] = trans[key];
      }
      _clearTransform() {
        var trans = {
          x: this.x(),
          y: this.y(),
          rotation: this.rotation(),
          scaleX: this.scaleX(),
          scaleY: this.scaleY(),
          offsetX: this.offsetX(),
          offsetY: this.offsetY(),
          skewX: this.skewX(),
          skewY: this.skewY()
        };
        return this.attrs.x = 0, this.attrs.y = 0, this.attrs.rotation = 0, this.attrs.scaleX = 1, this.attrs.scaleY = 1, this.attrs.offsetX = 0, this.attrs.offsetY = 0, this.attrs.skewX = 0, this.attrs.skewY = 0, trans;
      }
      move(change) {
        var changeX = change.x, changeY = change.y, x = this.x(), y = this.y();
        return changeX !== void 0 && (x += changeX), changeY !== void 0 && (y += changeY), this.setPosition({ x, y }), this;
      }
      _eachAncestorReverse(func, top) {
        var family = [], parent = this.getParent(), len, n;
        if (!(top && top._id === this._id)) {
          for (family.unshift(this); parent && (!top || parent._id !== top._id); )
            family.unshift(parent), parent = parent.parent;
          for (len = family.length, n = 0; n < len; n++)
            func(family[n]);
        }
      }
      rotate(theta) {
        return this.rotation(this.rotation() + theta), this;
      }
      moveToTop() {
        if (!this.parent)
          return Util_1.Util.warn("Node has no parent. moveToTop function is ignored."), !1;
        var index = this.index, len = this.parent.getChildren().length;
        return index < len - 1 ? (this.parent.children.splice(index, 1), this.parent.children.push(this), this.parent._setChildrenIndices(), !0) : !1;
      }
      moveUp() {
        if (!this.parent)
          return Util_1.Util.warn("Node has no parent. moveUp function is ignored."), !1;
        var index = this.index, len = this.parent.getChildren().length;
        return index < len - 1 ? (this.parent.children.splice(index, 1), this.parent.children.splice(index + 1, 0, this), this.parent._setChildrenIndices(), !0) : !1;
      }
      moveDown() {
        if (!this.parent)
          return Util_1.Util.warn("Node has no parent. moveDown function is ignored."), !1;
        var index = this.index;
        return index > 0 ? (this.parent.children.splice(index, 1), this.parent.children.splice(index - 1, 0, this), this.parent._setChildrenIndices(), !0) : !1;
      }
      moveToBottom() {
        if (!this.parent)
          return Util_1.Util.warn("Node has no parent. moveToBottom function is ignored."), !1;
        var index = this.index;
        return index > 0 ? (this.parent.children.splice(index, 1), this.parent.children.unshift(this), this.parent._setChildrenIndices(), !0) : !1;
      }
      setZIndex(zIndex) {
        if (!this.parent)
          return Util_1.Util.warn("Node has no parent. zIndex parameter is ignored."), this;
        (zIndex < 0 || zIndex >= this.parent.children.length) && Util_1.Util.warn("Unexpected value " + zIndex + " for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to " + (this.parent.children.length - 1) + ".");
        var index = this.index;
        return this.parent.children.splice(index, 1), this.parent.children.splice(zIndex, 0, this), this.parent._setChildrenIndices(), this;
      }
      getAbsoluteOpacity() {
        return this._getCache(ABSOLUTE_OPACITY2, this._getAbsoluteOpacity);
      }
      _getAbsoluteOpacity() {
        var absOpacity = this.opacity(), parent = this.getParent();
        return parent && !parent._isUnderCache && (absOpacity *= parent.getAbsoluteOpacity()), absOpacity;
      }
      moveTo(newContainer) {
        return this.getParent() !== newContainer && (this._remove(), newContainer.add(this)), this;
      }
      toObject() {
        var obj = {}, attrs = this.getAttrs(), key, val, getter, defaultValue, nonPlainObject;
        obj.attrs = {};
        for (key in attrs)
          val = attrs[key], nonPlainObject = Util_1.Util.isObject(val) && !Util_1.Util._isPlainObject(val) && !Util_1.Util._isArray(val), !nonPlainObject && (getter = typeof this[key] == "function" && this[key], delete attrs[key], defaultValue = getter ? getter.call(this) : null, attrs[key] = val, defaultValue !== val && (obj.attrs[key] = val));
        return obj.className = this.getClassName(), Util_1.Util._prepareToStringify(obj);
      }
      toJSON() {
        return JSON.stringify(this.toObject());
      }
      getParent() {
        return this.parent;
      }
      findAncestors(selector, includeSelf, stopNode) {
        var res = [];
        includeSelf && this._isMatch(selector) && res.push(this);
        for (var ancestor = this.parent; ancestor; ) {
          if (ancestor === stopNode)
            return res;
          ancestor._isMatch(selector) && res.push(ancestor), ancestor = ancestor.parent;
        }
        return res;
      }
      isAncestorOf(node) {
        return !1;
      }
      findAncestor(selector, includeSelf, stopNode) {
        return this.findAncestors(selector, includeSelf, stopNode)[0];
      }
      _isMatch(selector) {
        if (!selector)
          return !1;
        if (typeof selector == "function")
          return selector(this);
        var selectorArr = selector.replace(/ /g, "").split(","), len = selectorArr.length, n, sel;
        for (n = 0; n < len; n++)
          if (sel = selectorArr[n], Util_1.Util.isValidSelector(sel) || (Util_1.Util.warn('Selector "' + sel + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".'), Util_1.Util.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".'), Util_1.Util.warn("Konva is awesome, right?")), sel.charAt(0) === "#") {
            if (this.id() === sel.slice(1))
              return !0;
          } else if (sel.charAt(0) === ".") {
            if (this.hasName(sel.slice(1)))
              return !0;
          } else if (this.className === sel || this.nodeType === sel)
            return !0;
        return !1;
      }
      getLayer() {
        var parent = this.getParent();
        return parent ? parent.getLayer() : null;
      }
      getStage() {
        return this._getCache(STAGE3, this._getStage);
      }
      _getStage() {
        var parent = this.getParent();
        if (parent)
          return parent.getStage();
      }
      fire(eventType, evt = {}, bubble) {
        return evt.target = evt.target || this, bubble ? this._fireAndBubble(eventType, evt) : this._fire(eventType, evt), this;
      }
      getAbsoluteTransform(top) {
        return top ? this._getAbsoluteTransform(top) : this._getCache(ABSOLUTE_TRANSFORM2, this._getAbsoluteTransform);
      }
      _getAbsoluteTransform(top) {
        var at;
        if (top)
          return at = new Util_1.Transform(), this._eachAncestorReverse(function(node) {
            var transformsEnabled2 = node.transformsEnabled();
            transformsEnabled2 === "all" ? at.multiply(node.getTransform()) : transformsEnabled2 === "position" && at.translate(node.x() - node.offsetX(), node.y() - node.offsetY());
          }, top), at;
        at = this._cache.get(ABSOLUTE_TRANSFORM2) || new Util_1.Transform(), this.parent ? this.parent.getAbsoluteTransform().copyInto(at) : at.reset();
        var transformsEnabled = this.transformsEnabled();
        if (transformsEnabled === "all")
          at.multiply(this.getTransform());
        else if (transformsEnabled === "position") {
          let x = this.attrs.x || 0, y = this.attrs.y || 0, offsetX = this.attrs.offsetX || 0, offsetY = this.attrs.offsetY || 0;
          at.translate(x - offsetX, y - offsetY);
        }
        return at.dirty = !1, at;
      }
      getAbsoluteScale(top) {
        for (var parent = this; parent; )
          parent._isUnderCache && (top = parent), parent = parent.getParent();
        let attrs = this.getAbsoluteTransform(top).decompose();
        return {
          x: attrs.scaleX,
          y: attrs.scaleY
        };
      }
      getAbsoluteRotation() {
        return this.getAbsoluteTransform().decompose().rotation;
      }
      getTransform() {
        return this._getCache(TRANSFORM2, this._getTransform);
      }
      _getTransform() {
        var _a, _b, m = this._cache.get(TRANSFORM2) || new Util_1.Transform();
        m.reset();
        var x = this.x(), y = this.y(), rotation = Global_1.Konva.getAngle(this.rotation()), scaleX = (_a = this.attrs.scaleX) !== null && _a !== void 0 ? _a : 1, scaleY = (_b = this.attrs.scaleY) !== null && _b !== void 0 ? _b : 1, skewX = this.attrs.skewX || 0, skewY = this.attrs.skewY || 0, offsetX = this.attrs.offsetX || 0, offsetY = this.attrs.offsetY || 0;
        return (x !== 0 || y !== 0) && m.translate(x, y), rotation !== 0 && m.rotate(rotation), (skewX !== 0 || skewY !== 0) && m.skew(skewX, skewY), (scaleX !== 1 || scaleY !== 1) && m.scale(scaleX, scaleY), (offsetX !== 0 || offsetY !== 0) && m.translate(-1 * offsetX, -1 * offsetY), m.dirty = !1, m;
      }
      clone(obj) {
        var attrs = Util_1.Util.cloneObject(this.attrs), key, allListeners, len, n, listener;
        for (key in obj)
          attrs[key] = obj[key];
        var node = new this.constructor(attrs);
        for (key in this.eventListeners)
          for (allListeners = this.eventListeners[key], len = allListeners.length, n = 0; n < len; n++)
            listener = allListeners[n], listener.name.indexOf(KONVA2) < 0 && (node.eventListeners[key] || (node.eventListeners[key] = []), node.eventListeners[key].push(listener));
        return node;
      }
      _toKonvaCanvas(config) {
        config = config || {};
        var box = this.getClientRect(), stage = this.getStage(), x = config.x !== void 0 ? config.x : Math.floor(box.x), y = config.y !== void 0 ? config.y : Math.floor(box.y), pixelRatio = config.pixelRatio || 1, canvas = new Canvas_1.SceneCanvas({
          width: config.width || Math.ceil(box.width) || (stage ? stage.width() : 0),
          height: config.height || Math.ceil(box.height) || (stage ? stage.height() : 0),
          pixelRatio
        }), context = canvas.getContext();
        return config.imageSmoothingEnabled === !1 && (context._context.imageSmoothingEnabled = !1), context.save(), (x || y) && context.translate(-1 * x, -1 * y), this.drawScene(canvas), context.restore(), canvas;
      }
      toCanvas(config) {
        return this._toKonvaCanvas(config)._canvas;
      }
      toDataURL(config) {
        config = config || {};
        var mimeType = config.mimeType || null, quality = config.quality || null, url = this._toKonvaCanvas(config).toDataURL(mimeType, quality);
        return config.callback && config.callback(url), url;
      }
      toImage(config) {
        return new Promise((resolve, reject) => {
          try {
            let callback = config == null ? void 0 : config.callback;
            callback && delete config.callback, Util_1.Util._urlToImage(this.toDataURL(config), function(img) {
              resolve(img), callback == null || callback(img);
            });
          } catch (err) {
            reject(err);
          }
        });
      }
      toBlob(config) {
        return new Promise((resolve, reject) => {
          try {
            let callback = config == null ? void 0 : config.callback;
            callback && delete config.callback, this.toCanvas(config).toBlob((blob) => {
              resolve(blob), callback == null || callback(blob);
            });
          } catch (err) {
            reject(err);
          }
        });
      }
      setSize(size) {
        return this.width(size.width), this.height(size.height), this;
      }
      getSize() {
        return {
          width: this.width(),
          height: this.height()
        };
      }
      getClassName() {
        return this.className || this.nodeType;
      }
      getType() {
        return this.nodeType;
      }
      getDragDistance() {
        return this.attrs.dragDistance !== void 0 ? this.attrs.dragDistance : this.parent ? this.parent.getDragDistance() : Global_1.Konva.dragDistance;
      }
      _off(type, name, callback) {
        var evtListeners = this.eventListeners[type], i, evtName, handler;
        for (i = 0; i < evtListeners.length; i++)
          if (evtName = evtListeners[i].name, handler = evtListeners[i].handler, (evtName !== "konva" || name === "konva") && (!name || evtName === name) && (!callback || callback === handler)) {
            if (evtListeners.splice(i, 1), evtListeners.length === 0) {
              delete this.eventListeners[type];
              break;
            }
            i--;
          }
      }
      _fireChangeEvent(attr, oldVal, newVal) {
        this._fire(attr + CHANGE2, {
          oldVal,
          newVal
        });
      }
      addName(name) {
        if (!this.hasName(name)) {
          var oldName = this.name(), newName = oldName ? oldName + " " + name : name;
          this.name(newName);
        }
        return this;
      }
      hasName(name) {
        if (!name)
          return !1;
        let fullName = this.name();
        if (!fullName)
          return !1;
        var names = (fullName || "").split(/\s/g);
        return names.indexOf(name) !== -1;
      }
      removeName(name) {
        var names = (this.name() || "").split(/\s/g), index = names.indexOf(name);
        return index !== -1 && (names.splice(index, 1), this.name(names.join(" "))), this;
      }
      setAttr(attr, val) {
        var func = this[SET3 + Util_1.Util._capitalize(attr)];
        return Util_1.Util._isFunction(func) ? func.call(this, val) : this._setAttr(attr, val), this;
      }
      _requestDraw() {
        if (Global_1.Konva.autoDrawEnabled) {
          let drawNode = this.getLayer() || this.getStage();
          drawNode == null || drawNode.batchDraw();
        }
      }
      _setAttr(key, val) {
        var oldVal = this.attrs[key];
        oldVal === val && !Util_1.Util.isObject(val) || (val == null ? delete this.attrs[key] : this.attrs[key] = val, this._shouldFireChangeEvents && this._fireChangeEvent(key, oldVal, val), this._requestDraw());
      }
      _setComponentAttr(key, component, val) {
        var oldVal;
        val !== void 0 && (oldVal = this.attrs[key], oldVal || (this.attrs[key] = this.getAttr(key)), this.attrs[key][component] = val, this._fireChangeEvent(key, oldVal, val));
      }
      _fireAndBubble(eventType, evt, compareShape) {
        evt && this.nodeType === SHAPE2 && (evt.target = this);
        var shouldStop = (eventType === MOUSEENTER3 || eventType === MOUSELEAVE3) && (compareShape && (this === compareShape || this.isAncestorOf && this.isAncestorOf(compareShape)) || this.nodeType === "Stage" && !compareShape);
        if (!shouldStop) {
          this._fire(eventType, evt);
          var stopBubble = (eventType === MOUSEENTER3 || eventType === MOUSELEAVE3) && compareShape && compareShape.isAncestorOf && compareShape.isAncestorOf(this) && !compareShape.isAncestorOf(this.parent);
          (evt && !evt.cancelBubble || !evt) && this.parent && this.parent.isListening() && !stopBubble && (compareShape && compareShape.parent ? this._fireAndBubble.call(this.parent, eventType, evt, compareShape) : this._fireAndBubble.call(this.parent, eventType, evt));
        }
      }
      _getProtoListeners(eventType) {
        let listeners = this._cache.get(ALL_LISTENERS2);
        if (!listeners) {
          listeners = {};
          let obj = Object.getPrototypeOf(this);
          for (; obj; ) {
            if (!obj.eventListeners) {
              obj = Object.getPrototypeOf(obj);
              continue;
            }
            for (var event in obj.eventListeners) {
              let newEvents = obj.eventListeners[event], oldEvents = listeners[event] || [];
              listeners[event] = newEvents.concat(oldEvents);
            }
            obj = Object.getPrototypeOf(obj);
          }
          this._cache.set(ALL_LISTENERS2, listeners);
        }
        return listeners[eventType];
      }
      _fire(eventType, evt) {
        evt = evt || {}, evt.currentTarget = this, evt.type = eventType;
        let topListeners = this._getProtoListeners(eventType);
        if (topListeners)
          for (var i = 0; i < topListeners.length; i++)
            topListeners[i].handler.call(this, evt);
        let selfListeners = this.eventListeners[eventType];
        if (selfListeners)
          for (var i = 0; i < selfListeners.length; i++)
            selfListeners[i].handler.call(this, evt);
      }
      draw() {
        return this.drawScene(), this.drawHit(), this;
      }
      _createDragElement(evt) {
        var pointerId = evt ? evt.pointerId : void 0, stage = this.getStage(), ap = this.getAbsolutePosition(), pos = stage._getPointerById(pointerId) || stage._changedPointerPositions[0] || ap;
        DragAndDrop_1.DD._dragElements.set(this._id, {
          node: this,
          startPointerPos: pos,
          offset: {
            x: pos.x - ap.x,
            y: pos.y - ap.y
          },
          dragStatus: "ready",
          pointerId
        });
      }
      startDrag(evt, bubbleEvent = !0) {
        DragAndDrop_1.DD._dragElements.has(this._id) || this._createDragElement(evt);
        let elem = DragAndDrop_1.DD._dragElements.get(this._id);
        elem.dragStatus = "dragging", this.fire("dragstart", {
          type: "dragstart",
          target: this,
          evt: evt && evt.evt
        }, bubbleEvent);
      }
      _setDragPosition(evt, elem) {
        let pos = this.getStage()._getPointerById(elem.pointerId);
        if (!!pos) {
          var newNodePos = {
            x: pos.x - elem.offset.x,
            y: pos.y - elem.offset.y
          }, dbf = this.dragBoundFunc();
          if (dbf !== void 0) {
            let bounded = dbf.call(this, newNodePos, evt);
            bounded ? newNodePos = bounded : Util_1.Util.warn("dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.");
          }
          (!this._lastPos || this._lastPos.x !== newNodePos.x || this._lastPos.y !== newNodePos.y) && (this.setAbsolutePosition(newNodePos), this._requestDraw()), this._lastPos = newNodePos;
        }
      }
      stopDrag(evt) {
        let elem = DragAndDrop_1.DD._dragElements.get(this._id);
        elem && (elem.dragStatus = "stopped"), DragAndDrop_1.DD._endDragBefore(evt), DragAndDrop_1.DD._endDragAfter(evt);
      }
      setDraggable(draggable) {
        this._setAttr("draggable", draggable), this._dragChange();
      }
      isDragging() {
        let elem = DragAndDrop_1.DD._dragElements.get(this._id);
        return elem ? elem.dragStatus === "dragging" : !1;
      }
      _listenDrag() {
        this._dragCleanup(), this.on("mousedown.konva touchstart.konva", function(evt) {
          var shouldCheckButton = evt.evt.button !== void 0, canDrag = !shouldCheckButton || Global_1.Konva.dragButtons.indexOf(evt.evt.button) >= 0;
          if (!!canDrag && !this.isDragging()) {
            var hasDraggingChild = !1;
            DragAndDrop_1.DD._dragElements.forEach((elem) => {
              this.isAncestorOf(elem.node) && (hasDraggingChild = !0);
            }), hasDraggingChild || this._createDragElement(evt);
          }
        });
      }
      _dragChange() {
        if (this.attrs.draggable)
          this._listenDrag();
        else {
          this._dragCleanup();
          var stage = this.getStage();
          if (!stage)
            return;
          let dragElement = DragAndDrop_1.DD._dragElements.get(this._id), isDragging = dragElement && dragElement.dragStatus === "dragging", isReady = dragElement && dragElement.dragStatus === "ready";
          isDragging ? this.stopDrag() : isReady && DragAndDrop_1.DD._dragElements.delete(this._id);
        }
      }
      _dragCleanup() {
        this.off("mousedown.konva"), this.off("touchstart.konva");
      }
      isClientRectOnScreen(margin = { x: 0, y: 0 }) {
        let stage = this.getStage();
        if (!stage)
          return !1;
        let screenRect = {
          x: -margin.x,
          y: -margin.y,
          width: stage.width() + 2 * margin.x,
          height: stage.height() + 2 * margin.y
        };
        return Util_1.Util.haveIntersection(screenRect, this.getClientRect());
      }
      static create(data, container) {
        return Util_1.Util._isString(data) && (data = JSON.parse(data)), this._createNode(data, container);
      }
      static _createNode(obj, container) {
        var className = Node2.prototype.getClassName.call(obj), children = obj.children, no, len, n;
        container && (obj.attrs.container = container), Global_1.Konva[className] || (Util_1.Util.warn('Can not find a node with class name "' + className + '". Fallback to "Shape".'), className = "Shape");
        let Class = Global_1.Konva[className];
        if (no = new Class(obj.attrs), children)
          for (len = children.length, n = 0; n < len; n++)
            no.add(Node2._createNode(children[n]));
        return no;
      }
    };
    exports.Node = Node2;
    Node2.prototype.nodeType = "Node";
    Node2.prototype._attrsAffectingSize = [];
    Node2.prototype.eventListeners = {};
    Node2.prototype.on.call(Node2.prototype, TRANSFORM_CHANGE_STR2, function() {
      if (this._batchingTransformChange) {
        this._needClearTransformCache = !0;
        return;
      }
      this._clearCache(TRANSFORM2), this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM2);
    });
    Node2.prototype.on.call(Node2.prototype, "visibleChange.konva", function() {
      this._clearSelfAndDescendantCache(VISIBLE2);
    });
    Node2.prototype.on.call(Node2.prototype, "listeningChange.konva", function() {
      this._clearSelfAndDescendantCache(LISTENING2);
    });
    Node2.prototype.on.call(Node2.prototype, "opacityChange.konva", function() {
      this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY2);
    });
    var addGetterSetter2 = Factory_1.Factory.addGetterSetter;
    addGetterSetter2(Node2, "zIndex");
    addGetterSetter2(Node2, "absolutePosition");
    addGetterSetter2(Node2, "position");
    addGetterSetter2(Node2, "x", 0, (0, Validators_1.getNumberValidator)());
    addGetterSetter2(Node2, "y", 0, (0, Validators_1.getNumberValidator)());
    addGetterSetter2(Node2, "globalCompositeOperation", "source-over", (0, Validators_1.getStringValidator)());
    addGetterSetter2(Node2, "opacity", 1, (0, Validators_1.getNumberValidator)());
    addGetterSetter2(Node2, "name", "", (0, Validators_1.getStringValidator)());
    addGetterSetter2(Node2, "id", "", (0, Validators_1.getStringValidator)());
    addGetterSetter2(Node2, "rotation", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addComponentsGetterSetter(Node2, "scale", ["x", "y"]);
    addGetterSetter2(Node2, "scaleX", 1, (0, Validators_1.getNumberValidator)());
    addGetterSetter2(Node2, "scaleY", 1, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addComponentsGetterSetter(Node2, "skew", ["x", "y"]);
    addGetterSetter2(Node2, "skewX", 0, (0, Validators_1.getNumberValidator)());
    addGetterSetter2(Node2, "skewY", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addComponentsGetterSetter(Node2, "offset", ["x", "y"]);
    addGetterSetter2(Node2, "offsetX", 0, (0, Validators_1.getNumberValidator)());
    addGetterSetter2(Node2, "offsetY", 0, (0, Validators_1.getNumberValidator)());
    addGetterSetter2(Node2, "dragDistance", null, (0, Validators_1.getNumberValidator)());
    addGetterSetter2(Node2, "width", 0, (0, Validators_1.getNumberValidator)());
    addGetterSetter2(Node2, "height", 0, (0, Validators_1.getNumberValidator)());
    addGetterSetter2(Node2, "listening", !0, (0, Validators_1.getBooleanValidator)());
    addGetterSetter2(Node2, "preventDefault", !0, (0, Validators_1.getBooleanValidator)());
    addGetterSetter2(Node2, "filters", null, function(val) {
      return this._filterUpToDate = !1, val;
    });
    addGetterSetter2(Node2, "visible", !0, (0, Validators_1.getBooleanValidator)());
    addGetterSetter2(Node2, "transformsEnabled", "all", (0, Validators_1.getStringValidator)());
    addGetterSetter2(Node2, "size");
    addGetterSetter2(Node2, "dragBoundFunc");
    addGetterSetter2(Node2, "draggable", !1, (0, Validators_1.getBooleanValidator)());
    Factory_1.Factory.backCompat(Node2, {
      rotateDeg: "rotate",
      setRotationDeg: "setRotation",
      getRotationDeg: "getRotation"
    });
  }
});

// node_modules/konva/cmj/Container.js
var require_Container = __commonJS({
  "node_modules/konva/cmj/Container.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Container = void 0;
    var Factory_1 = require_Factory(), Node_1 = require_Node(), Validators_1 = require_Validators(), Container2 = class extends Node_1.Node {
      constructor() {
        super(...arguments), this.children = [];
      }
      getChildren(filterFunc) {
        if (!filterFunc)
          return this.children || [];
        let children = this.children || [];
        var results = [];
        return children.forEach(function(child) {
          filterFunc(child) && results.push(child);
        }), results;
      }
      hasChildren() {
        return this.getChildren().length > 0;
      }
      removeChildren() {
        return this.getChildren().forEach((child) => {
          child.parent = null, child.index = 0, child.remove();
        }), this.children = [], this._requestDraw(), this;
      }
      destroyChildren() {
        return this.getChildren().forEach((child) => {
          child.parent = null, child.index = 0, child.destroy();
        }), this.children = [], this._requestDraw(), this;
      }
      add(...children) {
        if (arguments.length > 1) {
          for (var i = 0; i < arguments.length; i++)
            this.add(arguments[i]);
          return this;
        }
        var child = children[0];
        return child.getParent() ? (child.moveTo(this), this) : (this._validateAdd(child), child.index = this.getChildren().length, child.parent = this, child._clearCaches(), this.getChildren().push(child), this._fire("add", {
          child
        }), this._requestDraw(), this);
      }
      destroy() {
        return this.hasChildren() && this.destroyChildren(), super.destroy(), this;
      }
      find(selector) {
        return this._generalFind(selector, !1);
      }
      findOne(selector) {
        var result = this._generalFind(selector, !0);
        return result.length > 0 ? result[0] : void 0;
      }
      _generalFind(selector, findOne) {
        var retArr = [];
        return this._descendants((node) => {
          let valid = node._isMatch(selector);
          return valid && retArr.push(node), !!(valid && findOne);
        }), retArr;
      }
      _descendants(fn) {
        let shouldStop = !1, children = this.getChildren();
        for (let child of children) {
          if (shouldStop = fn(child), shouldStop)
            return !0;
          if (!!child.hasChildren() && (shouldStop = child._descendants(fn), shouldStop))
            return !0;
        }
        return !1;
      }
      toObject() {
        var obj = Node_1.Node.prototype.toObject.call(this);
        return obj.children = [], this.getChildren().forEach((child) => {
          obj.children.push(child.toObject());
        }), obj;
      }
      isAncestorOf(node) {
        for (var parent = node.getParent(); parent; ) {
          if (parent._id === this._id)
            return !0;
          parent = parent.getParent();
        }
        return !1;
      }
      clone(obj) {
        var node = Node_1.Node.prototype.clone.call(this, obj);
        return this.getChildren().forEach(function(no) {
          node.add(no.clone());
        }), node;
      }
      getAllIntersections(pos) {
        var arr = [];
        return this.find("Shape").forEach(function(shape) {
          shape.isVisible() && shape.intersects(pos) && arr.push(shape);
        }), arr;
      }
      _clearSelfAndDescendantCache(attr) {
        var _a;
        super._clearSelfAndDescendantCache(attr), !this.isCached() && ((_a = this.children) === null || _a === void 0 || _a.forEach(function(node) {
          node._clearSelfAndDescendantCache(attr);
        }));
      }
      _setChildrenIndices() {
        var _a;
        (_a = this.children) === null || _a === void 0 || _a.forEach(function(child, n) {
          child.index = n;
        }), this._requestDraw();
      }
      drawScene(can, top) {
        var layer = this.getLayer(), canvas = can || layer && layer.getCanvas(), context = canvas && canvas.getContext(), cachedCanvas = this._getCanvasCache(), cachedSceneCanvas = cachedCanvas && cachedCanvas.scene, caching = canvas && canvas.isCache;
        if (!this.isVisible() && !caching)
          return this;
        if (cachedSceneCanvas) {
          context.save();
          var m = this.getAbsoluteTransform(top).getMatrix();
          context.transform(m[0], m[1], m[2], m[3], m[4], m[5]), this._drawCachedSceneCanvas(context), context.restore();
        } else
          this._drawChildren("drawScene", canvas, top);
        return this;
      }
      drawHit(can, top) {
        if (!this.shouldDrawHit(top))
          return this;
        var layer = this.getLayer(), canvas = can || layer && layer.hitCanvas, context = canvas && canvas.getContext(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;
        if (cachedHitCanvas) {
          context.save();
          var m = this.getAbsoluteTransform(top).getMatrix();
          context.transform(m[0], m[1], m[2], m[3], m[4], m[5]), this._drawCachedHitCanvas(context), context.restore();
        } else
          this._drawChildren("drawHit", canvas, top);
        return this;
      }
      _drawChildren(drawMethod, canvas, top) {
        var _a, context = canvas && canvas.getContext(), clipWidth = this.clipWidth(), clipHeight = this.clipHeight(), clipFunc = this.clipFunc(), hasClip = clipWidth && clipHeight || clipFunc;
        let selfCache = top === this;
        if (hasClip) {
          context.save();
          var transform = this.getAbsoluteTransform(top), m = transform.getMatrix();
          if (context.transform(m[0], m[1], m[2], m[3], m[4], m[5]), context.beginPath(), clipFunc)
            clipFunc.call(this, context, this);
          else {
            var clipX = this.clipX(), clipY = this.clipY();
            context.rect(clipX, clipY, clipWidth, clipHeight);
          }
          context.clip(), m = transform.copy().invert().getMatrix(), context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
        }
        var hasComposition = !selfCache && this.globalCompositeOperation() !== "source-over" && drawMethod === "drawScene";
        hasComposition && (context.save(), context._applyGlobalCompositeOperation(this)), (_a = this.children) === null || _a === void 0 || _a.forEach(function(child) {
          child[drawMethod](canvas, top);
        }), hasComposition && context.restore(), hasClip && context.restore();
      }
      getClientRect(config) {
        var _a;
        config = config || {};
        var skipTransform = config.skipTransform, relativeTo = config.relativeTo, minX, minY, maxX, maxY, selfRect = {
          x: 1 / 0,
          y: 1 / 0,
          width: 0,
          height: 0
        }, that = this;
        (_a = this.children) === null || _a === void 0 || _a.forEach(function(child) {
          if (!!child.visible()) {
            var rect = child.getClientRect({
              relativeTo: that,
              skipShadow: config.skipShadow,
              skipStroke: config.skipStroke
            });
            rect.width === 0 && rect.height === 0 || (minX === void 0 ? (minX = rect.x, minY = rect.y, maxX = rect.x + rect.width, maxY = rect.y + rect.height) : (minX = Math.min(minX, rect.x), minY = Math.min(minY, rect.y), maxX = Math.max(maxX, rect.x + rect.width), maxY = Math.max(maxY, rect.y + rect.height)));
          }
        });
        for (var shapes2 = this.find("Shape"), hasVisible = !1, i = 0; i < shapes2.length; i++) {
          var shape = shapes2[i];
          if (shape._isVisible(this)) {
            hasVisible = !0;
            break;
          }
        }
        return hasVisible && minX !== void 0 ? selfRect = {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        } : selfRect = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        }, skipTransform ? selfRect : this._transformedRect(selfRect, relativeTo);
      }
    };
    exports.Container = Container2;
    Factory_1.Factory.addComponentsGetterSetter(Container2, "clip", [
      "x",
      "y",
      "width",
      "height"
    ]);
    Factory_1.Factory.addGetterSetter(Container2, "clipX", void 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Container2, "clipY", void 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Container2, "clipWidth", void 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Container2, "clipHeight", void 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Container2, "clipFunc");
  }
});

// node_modules/konva/cmj/PointerEvents.js
var require_PointerEvents = __commonJS({
  "node_modules/konva/cmj/PointerEvents.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.releaseCapture = exports.setPointerCapture = exports.hasPointerCapture = exports.createEvent = exports.getCapturedShape = void 0;
    var Global_1 = require_Global2(), Captures2 = /* @__PURE__ */ new Map(), SUPPORT_POINTER_EVENTS2 = Global_1.Konva._global.PointerEvent !== void 0;
    function getCapturedShape2(pointerId) {
      return Captures2.get(pointerId);
    }
    exports.getCapturedShape = getCapturedShape2;
    function createEvent2(evt) {
      return {
        evt,
        pointerId: evt.pointerId
      };
    }
    exports.createEvent = createEvent2;
    function hasPointerCapture2(pointerId, shape) {
      return Captures2.get(pointerId) === shape;
    }
    exports.hasPointerCapture = hasPointerCapture2;
    function setPointerCapture2(pointerId, shape) {
      releaseCapture2(pointerId), shape.getStage() && (Captures2.set(pointerId, shape), SUPPORT_POINTER_EVENTS2 && shape._fire("gotpointercapture", createEvent2(new PointerEvent("gotpointercapture"))));
    }
    exports.setPointerCapture = setPointerCapture2;
    function releaseCapture2(pointerId, target) {
      let shape = Captures2.get(pointerId);
      if (!shape)
        return;
      let stage = shape.getStage();
      stage && stage.content, Captures2.delete(pointerId), SUPPORT_POINTER_EVENTS2 && shape._fire("lostpointercapture", createEvent2(new PointerEvent("lostpointercapture")));
    }
    exports.releaseCapture = releaseCapture2;
  }
});

// node_modules/konva/cmj/Stage.js
var require_Stage = __commonJS({
  "node_modules/konva/cmj/Stage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Stage = exports.stages = void 0;
    var Util_1 = require_Util(), Factory_1 = require_Factory(), Container_1 = require_Container(), Global_1 = require_Global2(), Canvas_1 = require_Canvas(), DragAndDrop_1 = require_DragAndDrop(), Global_2 = require_Global2(), PointerEvents = require_PointerEvents(), STAGE3 = "Stage", STRING2 = "string", PX2 = "px", MOUSEOUT2 = "mouseout", MOUSELEAVE3 = "mouseleave", MOUSEOVER2 = "mouseover", MOUSEENTER3 = "mouseenter", MOUSEMOVE2 = "mousemove", MOUSEDOWN2 = "mousedown", MOUSEUP2 = "mouseup", POINTERMOVE2 = "pointermove", POINTERDOWN2 = "pointerdown", POINTERUP2 = "pointerup", POINTERCANCEL2 = "pointercancel", LOSTPOINTERCAPTURE2 = "lostpointercapture", POINTEROUT2 = "pointerout", POINTERLEAVE2 = "pointerleave", POINTEROVER2 = "pointerover", POINTERENTER2 = "pointerenter", CONTEXTMENU2 = "contextmenu", TOUCHSTART2 = "touchstart", TOUCHEND2 = "touchend", TOUCHMOVE2 = "touchmove", TOUCHCANCEL2 = "touchcancel", WHEEL2 = "wheel", MAX_LAYERS_NUMBER2 = 5, EVENTS2 = [
      [MOUSEENTER3, "_pointerenter"],
      [MOUSEDOWN2, "_pointerdown"],
      [MOUSEMOVE2, "_pointermove"],
      [MOUSEUP2, "_pointerup"],
      [MOUSELEAVE3, "_pointerleave"],
      [TOUCHSTART2, "_pointerdown"],
      [TOUCHMOVE2, "_pointermove"],
      [TOUCHEND2, "_pointerup"],
      [TOUCHCANCEL2, "_pointercancel"],
      [MOUSEOVER2, "_pointerover"],
      [WHEEL2, "_wheel"],
      [CONTEXTMENU2, "_contextmenu"],
      [POINTERDOWN2, "_pointerdown"],
      [POINTERMOVE2, "_pointermove"],
      [POINTERUP2, "_pointerup"],
      [POINTERCANCEL2, "_pointercancel"],
      [LOSTPOINTERCAPTURE2, "_lostpointercapture"]
    ], EVENTS_MAP2 = {
      mouse: {
        [POINTEROUT2]: MOUSEOUT2,
        [POINTERLEAVE2]: MOUSELEAVE3,
        [POINTEROVER2]: MOUSEOVER2,
        [POINTERENTER2]: MOUSEENTER3,
        [POINTERMOVE2]: MOUSEMOVE2,
        [POINTERDOWN2]: MOUSEDOWN2,
        [POINTERUP2]: MOUSEUP2,
        [POINTERCANCEL2]: "mousecancel",
        pointerclick: "click",
        pointerdblclick: "dblclick"
      },
      touch: {
        [POINTEROUT2]: "touchout",
        [POINTERLEAVE2]: "touchleave",
        [POINTEROVER2]: "touchover",
        [POINTERENTER2]: "touchenter",
        [POINTERMOVE2]: TOUCHMOVE2,
        [POINTERDOWN2]: TOUCHSTART2,
        [POINTERUP2]: TOUCHEND2,
        [POINTERCANCEL2]: TOUCHCANCEL2,
        pointerclick: "tap",
        pointerdblclick: "dbltap"
      },
      pointer: {
        [POINTEROUT2]: POINTEROUT2,
        [POINTERLEAVE2]: POINTERLEAVE2,
        [POINTEROVER2]: POINTEROVER2,
        [POINTERENTER2]: POINTERENTER2,
        [POINTERMOVE2]: POINTERMOVE2,
        [POINTERDOWN2]: POINTERDOWN2,
        [POINTERUP2]: POINTERUP2,
        [POINTERCANCEL2]: POINTERCANCEL2,
        pointerclick: "pointerclick",
        pointerdblclick: "pointerdblclick"
      }
    }, getEventType2 = (type) => type.indexOf("pointer") >= 0 ? "pointer" : type.indexOf("touch") >= 0 ? "touch" : "mouse", getEventsMap2 = (eventType) => {
      let type = getEventType2(eventType);
      if (type === "pointer")
        return Global_1.Konva.pointerEventsEnabled && EVENTS_MAP2.pointer;
      if (type === "touch")
        return EVENTS_MAP2.touch;
      if (type === "mouse")
        return EVENTS_MAP2.mouse;
    };
    function checkNoClip2(attrs = {}) {
      return (attrs.clipFunc || attrs.clipWidth || attrs.clipHeight) && Util_1.Util.warn("Stage does not support clipping. Please use clip for Layers or Groups."), attrs;
    }
    var NO_POINTERS_MESSAGE2 = "Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);";
    exports.stages = [];
    var Stage4 = class extends Container_1.Container {
      constructor(config) {
        super(checkNoClip2(config)), this._pointerPositions = [], this._changedPointerPositions = [], this._buildDOM(), this._bindContentEvents(), exports.stages.push(this), this.on("widthChange.konva heightChange.konva", this._resizeDOM), this.on("visibleChange.konva", this._checkVisibility), this.on("clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva", () => {
          checkNoClip2(this.attrs);
        }), this._checkVisibility();
      }
      _validateAdd(child) {
        let isLayer = child.getType() === "Layer", isFastLayer = child.getType() === "FastLayer";
        isLayer || isFastLayer || Util_1.Util.throw("You may only add layers to the stage.");
      }
      _checkVisibility() {
        if (!this.content)
          return;
        let style = this.visible() ? "" : "none";
        this.content.style.display = style;
      }
      setContainer(container) {
        if (typeof container === STRING2) {
          if (container.charAt(0) === ".") {
            var className = container.slice(1);
            container = document.getElementsByClassName(className)[0];
          } else {
            var id;
            container.charAt(0) !== "#" ? id = container : id = container.slice(1), container = document.getElementById(id);
          }
          if (!container)
            throw "Can not find container in document with id " + id;
        }
        return this._setAttr("container", container), this.content && (this.content.parentElement && this.content.parentElement.removeChild(this.content), container.appendChild(this.content)), this;
      }
      shouldDrawHit() {
        return !0;
      }
      clear() {
        var layers = this.children, len = layers.length, n;
        for (n = 0; n < len; n++)
          layers[n].clear();
        return this;
      }
      clone(obj) {
        return obj || (obj = {}), obj.container = typeof document < "u" && document.createElement("div"), Container_1.Container.prototype.clone.call(this, obj);
      }
      destroy() {
        super.destroy();
        var content = this.content;
        content && Util_1.Util._isInDocument(content) && this.container().removeChild(content);
        var index = exports.stages.indexOf(this);
        return index > -1 && exports.stages.splice(index, 1), Util_1.Util.releaseCanvas(this.bufferCanvas._canvas, this.bufferHitCanvas._canvas), this;
      }
      getPointerPosition() {
        let pos = this._pointerPositions[0] || this._changedPointerPositions[0];
        return pos ? {
          x: pos.x,
          y: pos.y
        } : (Util_1.Util.warn(NO_POINTERS_MESSAGE2), null);
      }
      _getPointerById(id) {
        return this._pointerPositions.find((p) => p.id === id);
      }
      getPointersPositions() {
        return this._pointerPositions;
      }
      getStage() {
        return this;
      }
      getContent() {
        return this.content;
      }
      _toKonvaCanvas(config) {
        config = config || {}, config.x = config.x || 0, config.y = config.y || 0, config.width = config.width || this.width(), config.height = config.height || this.height();
        var canvas = new Canvas_1.SceneCanvas({
          width: config.width,
          height: config.height,
          pixelRatio: config.pixelRatio || 1
        }), _context = canvas.getContext()._context, layers = this.children;
        return (config.x || config.y) && _context.translate(-1 * config.x, -1 * config.y), layers.forEach(function(layer) {
          if (!!layer.isVisible()) {
            var layerCanvas = layer._toKonvaCanvas(config);
            _context.drawImage(layerCanvas._canvas, config.x, config.y, layerCanvas.getWidth() / layerCanvas.getPixelRatio(), layerCanvas.getHeight() / layerCanvas.getPixelRatio());
          }
        }), canvas;
      }
      getIntersection(pos) {
        if (!pos)
          return null;
        var layers = this.children, len = layers.length, end = len - 1, n;
        for (n = end; n >= 0; n--) {
          let shape = layers[n].getIntersection(pos);
          if (shape)
            return shape;
        }
        return null;
      }
      _resizeDOM() {
        var width = this.width(), height = this.height();
        this.content && (this.content.style.width = width + PX2, this.content.style.height = height + PX2), this.bufferCanvas.setSize(width, height), this.bufferHitCanvas.setSize(width, height), this.children.forEach((layer) => {
          layer.setSize({ width, height }), layer.draw();
        });
      }
      add(layer, ...rest) {
        if (arguments.length > 1) {
          for (var i = 0; i < arguments.length; i++)
            this.add(arguments[i]);
          return this;
        }
        super.add(layer);
        var length = this.children.length;
        return length > MAX_LAYERS_NUMBER2 && Util_1.Util.warn("The stage has " + length + " layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group."), layer.setSize({ width: this.width(), height: this.height() }), layer.draw(), Global_1.Konva.isBrowser && this.content.appendChild(layer.canvas._canvas), this;
      }
      getParent() {
        return null;
      }
      getLayer() {
        return null;
      }
      hasPointerCapture(pointerId) {
        return PointerEvents.hasPointerCapture(pointerId, this);
      }
      setPointerCapture(pointerId) {
        PointerEvents.setPointerCapture(pointerId, this);
      }
      releaseCapture(pointerId) {
        PointerEvents.releaseCapture(pointerId, this);
      }
      getLayers() {
        return this.children;
      }
      _bindContentEvents() {
        !Global_1.Konva.isBrowser || EVENTS2.forEach(([event, methodName]) => {
          this.content.addEventListener(event, (evt) => {
            this[methodName](evt);
          }, { passive: !1 });
        });
      }
      _pointerenter(evt) {
        this.setPointersPositions(evt);
        let events = getEventsMap2(evt.type);
        this._fire(events.pointerenter, {
          evt,
          target: this,
          currentTarget: this
        });
      }
      _pointerover(evt) {
        this.setPointersPositions(evt);
        let events = getEventsMap2(evt.type);
        this._fire(events.pointerover, {
          evt,
          target: this,
          currentTarget: this
        });
      }
      _getTargetShape(evenType) {
        let shape = this[evenType + "targetShape"];
        return shape && !shape.getStage() && (shape = null), shape;
      }
      _pointerleave(evt) {
        let events = getEventsMap2(evt.type), eventType = getEventType2(evt.type);
        if (!!events) {
          this.setPointersPositions(evt);
          var targetShape = this._getTargetShape(eventType), eventsEnabled = !DragAndDrop_1.DD.isDragging || Global_1.Konva.hitOnDragEnabled;
          targetShape && eventsEnabled ? (targetShape._fireAndBubble(events.pointerout, { evt }), targetShape._fireAndBubble(events.pointerleave, { evt }), this._fire(events.pointerleave, {
            evt,
            target: this,
            currentTarget: this
          }), this[eventType + "targetShape"] = null) : eventsEnabled && (this._fire(events.pointerleave, {
            evt,
            target: this,
            currentTarget: this
          }), this._fire(events.pointerout, {
            evt,
            target: this,
            currentTarget: this
          })), this.pointerPos = void 0, this._pointerPositions = [];
        }
      }
      _pointerdown(evt) {
        let events = getEventsMap2(evt.type), eventType = getEventType2(evt.type);
        if (!!events) {
          this.setPointersPositions(evt);
          var triggeredOnShape = !1;
          this._changedPointerPositions.forEach((pos) => {
            var shape = this.getIntersection(pos);
            if (DragAndDrop_1.DD.justDragged = !1, Global_1.Konva["_" + eventType + "ListenClick"] = !0, !(shape && shape.isListening()))
              return;
            Global_1.Konva.capturePointerEventsEnabled && shape.setPointerCapture(pos.id), this[eventType + "ClickStartShape"] = shape, shape._fireAndBubble(events.pointerdown, {
              evt,
              pointerId: pos.id
            }), triggeredOnShape = !0;
            let isTouch = evt.type.indexOf("touch") >= 0;
            shape.preventDefault() && evt.cancelable && isTouch && evt.preventDefault();
          }), triggeredOnShape || this._fire(events.pointerdown, {
            evt,
            target: this,
            currentTarget: this,
            pointerId: this._pointerPositions[0].id
          });
        }
      }
      _pointermove(evt) {
        let events = getEventsMap2(evt.type), eventType = getEventType2(evt.type);
        if (!events)
          return;
        DragAndDrop_1.DD.isDragging && DragAndDrop_1.DD.node.preventDefault() && evt.cancelable && evt.preventDefault(), this.setPointersPositions(evt);
        var eventsEnabled = !DragAndDrop_1.DD.isDragging || Global_1.Konva.hitOnDragEnabled;
        if (!eventsEnabled)
          return;
        var processedShapesIds = {};
        let triggeredOnShape = !1;
        var targetShape = this._getTargetShape(eventType);
        this._changedPointerPositions.forEach((pos) => {
          let shape = PointerEvents.getCapturedShape(pos.id) || this.getIntersection(pos), pointerId = pos.id, event = { evt, pointerId };
          var differentTarget = targetShape !== shape;
          if (differentTarget && targetShape && (targetShape._fireAndBubble(events.pointerout, Object.assign({}, event), shape), targetShape._fireAndBubble(events.pointerleave, Object.assign({}, event), shape)), shape) {
            if (processedShapesIds[shape._id])
              return;
            processedShapesIds[shape._id] = !0;
          }
          shape && shape.isListening() ? (triggeredOnShape = !0, differentTarget && (shape._fireAndBubble(events.pointerover, Object.assign({}, event), targetShape), shape._fireAndBubble(events.pointerenter, Object.assign({}, event), targetShape), this[eventType + "targetShape"] = shape), shape._fireAndBubble(events.pointermove, Object.assign({}, event))) : targetShape && (this._fire(events.pointerover, {
            evt,
            target: this,
            currentTarget: this,
            pointerId
          }), this[eventType + "targetShape"] = null);
        }), triggeredOnShape || this._fire(events.pointermove, {
          evt,
          target: this,
          currentTarget: this,
          pointerId: this._changedPointerPositions[0].id
        });
      }
      _pointerup(evt) {
        let events = getEventsMap2(evt.type), eventType = getEventType2(evt.type);
        if (!events)
          return;
        this.setPointersPositions(evt);
        let clickStartShape = this[eventType + "ClickStartShape"], clickEndShape = this[eventType + "ClickEndShape"];
        var processedShapesIds = {};
        let triggeredOnShape = !1;
        this._changedPointerPositions.forEach((pos) => {
          let shape = PointerEvents.getCapturedShape(pos.id) || this.getIntersection(pos);
          if (shape) {
            if (shape.releaseCapture(pos.id), processedShapesIds[shape._id])
              return;
            processedShapesIds[shape._id] = !0;
          }
          let pointerId = pos.id, event = { evt, pointerId }, fireDblClick = !1;
          Global_1.Konva["_" + eventType + "InDblClickWindow"] ? (fireDblClick = !0, clearTimeout(this[eventType + "DblTimeout"])) : DragAndDrop_1.DD.justDragged || (Global_1.Konva["_" + eventType + "InDblClickWindow"] = !0, clearTimeout(this[eventType + "DblTimeout"])), this[eventType + "DblTimeout"] = setTimeout(function() {
            Global_1.Konva["_" + eventType + "InDblClickWindow"] = !1;
          }, Global_1.Konva.dblClickWindow), shape && shape.isListening() ? (triggeredOnShape = !0, this[eventType + "ClickEndShape"] = shape, shape._fireAndBubble(events.pointerup, Object.assign({}, event)), Global_1.Konva["_" + eventType + "ListenClick"] && clickStartShape && clickStartShape === shape && (shape._fireAndBubble(events.pointerclick, Object.assign({}, event)), fireDblClick && clickEndShape && clickEndShape === shape && shape._fireAndBubble(events.pointerdblclick, Object.assign({}, event)))) : (this[eventType + "ClickEndShape"] = null, Global_1.Konva["_" + eventType + "ListenClick"] && this._fire(events.pointerclick, {
            evt,
            target: this,
            currentTarget: this,
            pointerId
          }), fireDblClick && this._fire(events.pointerdblclick, {
            evt,
            target: this,
            currentTarget: this,
            pointerId
          }));
        }), triggeredOnShape || this._fire(events.pointerup, {
          evt,
          target: this,
          currentTarget: this,
          pointerId: this._changedPointerPositions[0].id
        }), Global_1.Konva["_" + eventType + "ListenClick"] = !1, evt.cancelable && eventType !== "touch" && evt.preventDefault();
      }
      _contextmenu(evt) {
        this.setPointersPositions(evt);
        var shape = this.getIntersection(this.getPointerPosition());
        shape && shape.isListening() ? shape._fireAndBubble(CONTEXTMENU2, { evt }) : this._fire(CONTEXTMENU2, {
          evt,
          target: this,
          currentTarget: this
        });
      }
      _wheel(evt) {
        this.setPointersPositions(evt);
        var shape = this.getIntersection(this.getPointerPosition());
        shape && shape.isListening() ? shape._fireAndBubble(WHEEL2, { evt }) : this._fire(WHEEL2, {
          evt,
          target: this,
          currentTarget: this
        });
      }
      _pointercancel(evt) {
        this.setPointersPositions(evt);
        let shape = PointerEvents.getCapturedShape(evt.pointerId) || this.getIntersection(this.getPointerPosition());
        shape && shape._fireAndBubble(POINTERUP2, PointerEvents.createEvent(evt)), PointerEvents.releaseCapture(evt.pointerId);
      }
      _lostpointercapture(evt) {
        PointerEvents.releaseCapture(evt.pointerId);
      }
      setPointersPositions(evt) {
        var contentPosition = this._getContentPosition(), x = null, y = null;
        evt = evt || window.event, evt.touches !== void 0 ? (this._pointerPositions = [], this._changedPointerPositions = [], Array.prototype.forEach.call(evt.touches, (touch) => {
          this._pointerPositions.push({
            id: touch.identifier,
            x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,
            y: (touch.clientY - contentPosition.top) / contentPosition.scaleY
          });
        }), Array.prototype.forEach.call(evt.changedTouches || evt.touches, (touch) => {
          this._changedPointerPositions.push({
            id: touch.identifier,
            x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,
            y: (touch.clientY - contentPosition.top) / contentPosition.scaleY
          });
        })) : (x = (evt.clientX - contentPosition.left) / contentPosition.scaleX, y = (evt.clientY - contentPosition.top) / contentPosition.scaleY, this.pointerPos = {
          x,
          y
        }, this._pointerPositions = [{ x, y, id: Util_1.Util._getFirstPointerId(evt) }], this._changedPointerPositions = [
          { x, y, id: Util_1.Util._getFirstPointerId(evt) }
        ]);
      }
      _setPointerPosition(evt) {
        Util_1.Util.warn('Method _setPointerPosition is deprecated. Use "stage.setPointersPositions(event)" instead.'), this.setPointersPositions(evt);
      }
      _getContentPosition() {
        if (!this.content || !this.content.getBoundingClientRect)
          return {
            top: 0,
            left: 0,
            scaleX: 1,
            scaleY: 1
          };
        var rect = this.content.getBoundingClientRect();
        return {
          top: rect.top,
          left: rect.left,
          scaleX: rect.width / this.content.clientWidth || 1,
          scaleY: rect.height / this.content.clientHeight || 1
        };
      }
      _buildDOM() {
        if (this.bufferCanvas = new Canvas_1.SceneCanvas({
          width: this.width(),
          height: this.height()
        }), this.bufferHitCanvas = new Canvas_1.HitCanvas({
          pixelRatio: 1,
          width: this.width(),
          height: this.height()
        }), !!Global_1.Konva.isBrowser) {
          var container = this.container();
          if (!container)
            throw "Stage has no container. A container is required.";
          container.innerHTML = "", this.content = document.createElement("div"), this.content.style.position = "relative", this.content.style.userSelect = "none", this.content.className = "konvajs-content", this.content.setAttribute("role", "presentation"), container.appendChild(this.content), this._resizeDOM();
        }
      }
      cache() {
        return Util_1.Util.warn("Cache function is not allowed for stage. You may use cache only for layers, groups and shapes."), this;
      }
      clearCache() {
        return this;
      }
      batchDraw() {
        return this.getChildren().forEach(function(layer) {
          layer.batchDraw();
        }), this;
      }
    };
    exports.Stage = Stage4;
    Stage4.prototype.nodeType = STAGE3;
    (0, Global_2._registerNode)(Stage4);
    Factory_1.Factory.addGetterSetter(Stage4, "container");
  }
});

// node_modules/konva/cmj/Shape.js
var require_Shape = __commonJS({
  "node_modules/konva/cmj/Shape.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Shape = exports.shapes = void 0;
    var Global_1 = require_Global2(), Util_1 = require_Util(), Factory_1 = require_Factory(), Node_1 = require_Node(), Validators_1 = require_Validators(), Global_2 = require_Global2(), PointerEvents = require_PointerEvents(), HAS_SHADOW2 = "hasShadow", SHADOW_RGBA2 = "shadowRGBA", patternImage2 = "patternImage", linearGradient2 = "linearGradient", radialGradient2 = "radialGradient", dummyContext2;
    function getDummyContext2() {
      return dummyContext2 || (dummyContext2 = Util_1.Util.createCanvasElement().getContext("2d"), dummyContext2);
    }
    exports.shapes = {};
    function _fillFunc2(context) {
      context.fill();
    }
    function _strokeFunc2(context) {
      context.stroke();
    }
    function _fillFuncHit2(context) {
      context.fill();
    }
    function _strokeFuncHit2(context) {
      context.stroke();
    }
    function _clearHasShadowCache2() {
      this._clearCache(HAS_SHADOW2);
    }
    function _clearGetShadowRGBACache2() {
      this._clearCache(SHADOW_RGBA2);
    }
    function _clearFillPatternCache2() {
      this._clearCache(patternImage2);
    }
    function _clearLinearGradientCache2() {
      this._clearCache(linearGradient2);
    }
    function _clearRadialGradientCache2() {
      this._clearCache(radialGradient2);
    }
    var Shape2 = class extends Node_1.Node {
      constructor(config) {
        super(config);
        let key;
        for (; key = Util_1.Util.getRandomColor(), !(key && !(key in exports.shapes)); )
          ;
        this.colorKey = key, exports.shapes[key] = this;
      }
      getContext() {
        return Util_1.Util.warn("shape.getContext() method is deprecated. Please do not use it."), this.getLayer().getContext();
      }
      getCanvas() {
        return Util_1.Util.warn("shape.getCanvas() method is deprecated. Please do not use it."), this.getLayer().getCanvas();
      }
      getSceneFunc() {
        return this.attrs.sceneFunc || this._sceneFunc;
      }
      getHitFunc() {
        return this.attrs.hitFunc || this._hitFunc;
      }
      hasShadow() {
        return this._getCache(HAS_SHADOW2, this._hasShadow);
      }
      _hasShadow() {
        return this.shadowEnabled() && this.shadowOpacity() !== 0 && !!(this.shadowColor() || this.shadowBlur() || this.shadowOffsetX() || this.shadowOffsetY());
      }
      _getFillPattern() {
        return this._getCache(patternImage2, this.__getFillPattern);
      }
      __getFillPattern() {
        if (this.fillPatternImage()) {
          var ctx = getDummyContext2();
          let pattern = ctx.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || "repeat");
          if (pattern && pattern.setTransform) {
            let tr = new Util_1.Transform();
            tr.translate(this.fillPatternX(), this.fillPatternY()), tr.rotate(Global_1.Konva.getAngle(this.fillPatternRotation())), tr.scale(this.fillPatternScaleX(), this.fillPatternScaleY()), tr.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());
            let m = tr.getMatrix(), matrix = typeof DOMMatrix > "u" ? {
              a: m[0],
              b: m[1],
              c: m[2],
              d: m[3],
              e: m[4],
              f: m[5]
            } : new DOMMatrix(m);
            pattern.setTransform(matrix);
          }
          return pattern;
        }
      }
      _getLinearGradient() {
        return this._getCache(linearGradient2, this.__getLinearGradient);
      }
      __getLinearGradient() {
        var colorStops = this.fillLinearGradientColorStops();
        if (colorStops) {
          for (var ctx = getDummyContext2(), start = this.fillLinearGradientStartPoint(), end = this.fillLinearGradientEndPoint(), grd = ctx.createLinearGradient(start.x, start.y, end.x, end.y), n = 0; n < colorStops.length; n += 2)
            grd.addColorStop(colorStops[n], colorStops[n + 1]);
          return grd;
        }
      }
      _getRadialGradient() {
        return this._getCache(radialGradient2, this.__getRadialGradient);
      }
      __getRadialGradient() {
        var colorStops = this.fillRadialGradientColorStops();
        if (colorStops) {
          for (var ctx = getDummyContext2(), start = this.fillRadialGradientStartPoint(), end = this.fillRadialGradientEndPoint(), grd = ctx.createRadialGradient(start.x, start.y, this.fillRadialGradientStartRadius(), end.x, end.y, this.fillRadialGradientEndRadius()), n = 0; n < colorStops.length; n += 2)
            grd.addColorStop(colorStops[n], colorStops[n + 1]);
          return grd;
        }
      }
      getShadowRGBA() {
        return this._getCache(SHADOW_RGBA2, this._getShadowRGBA);
      }
      _getShadowRGBA() {
        if (!!this.hasShadow()) {
          var rgba = Util_1.Util.colorToRGBA(this.shadowColor());
          if (rgba)
            return "rgba(" + rgba.r + "," + rgba.g + "," + rgba.b + "," + rgba.a * (this.shadowOpacity() || 1) + ")";
        }
      }
      hasFill() {
        return this._calculate("hasFill", [
          "fillEnabled",
          "fill",
          "fillPatternImage",
          "fillLinearGradientColorStops",
          "fillRadialGradientColorStops"
        ], () => this.fillEnabled() && !!(this.fill() || this.fillPatternImage() || this.fillLinearGradientColorStops() || this.fillRadialGradientColorStops()));
      }
      hasStroke() {
        return this._calculate("hasStroke", [
          "strokeEnabled",
          "strokeWidth",
          "stroke",
          "strokeLinearGradientColorStops"
        ], () => this.strokeEnabled() && this.strokeWidth() && !!(this.stroke() || this.strokeLinearGradientColorStops()));
      }
      hasHitStroke() {
        let width = this.hitStrokeWidth();
        return width === "auto" ? this.hasStroke() : this.strokeEnabled() && !!width;
      }
      intersects(point) {
        var stage = this.getStage(), bufferHitCanvas = stage.bufferHitCanvas, p;
        return bufferHitCanvas.getContext().clear(), this.drawHit(bufferHitCanvas, null, !0), p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data, p[3] > 0;
      }
      destroy() {
        return Node_1.Node.prototype.destroy.call(this), delete exports.shapes[this.colorKey], delete this.colorKey, this;
      }
      _useBufferCanvas(forceFill) {
        var _a;
        if (!this.getStage() || !((_a = this.attrs.perfectDrawEnabled) !== null && _a !== void 0 ? _a : !0))
          return !1;
        let hasFill = forceFill || this.hasFill(), hasStroke = this.hasStroke(), isTransparent = this.getAbsoluteOpacity() !== 1;
        if (hasFill && hasStroke && isTransparent)
          return !0;
        let hasShadow = this.hasShadow(), strokeForShadow = this.shadowForStrokeEnabled();
        return !!(hasFill && hasStroke && hasShadow && strokeForShadow);
      }
      setStrokeHitEnabled(val) {
        Util_1.Util.warn("strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead."), val ? this.hitStrokeWidth("auto") : this.hitStrokeWidth(0);
      }
      getStrokeHitEnabled() {
        return this.hitStrokeWidth() !== 0;
      }
      getSelfRect() {
        var size = this.size();
        return {
          x: this._centroid ? -size.width / 2 : 0,
          y: this._centroid ? -size.height / 2 : 0,
          width: size.width,
          height: size.height
        };
      }
      getClientRect(config = {}) {
        let skipTransform = config.skipTransform, relativeTo = config.relativeTo, fillRect = this.getSelfRect(), strokeWidth = !config.skipStroke && this.hasStroke() && this.strokeWidth() || 0, fillAndStrokeWidth = fillRect.width + strokeWidth, fillAndStrokeHeight = fillRect.height + strokeWidth, applyShadow = !config.skipShadow && this.hasShadow(), shadowOffsetX = applyShadow ? this.shadowOffsetX() : 0, shadowOffsetY = applyShadow ? this.shadowOffsetY() : 0, preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX), preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY), blurRadius = applyShadow && this.shadowBlur() || 0, width = preWidth + blurRadius * 2, height = preHeight + blurRadius * 2, rect = {
          width,
          height,
          x: -(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetX, 0) + fillRect.x,
          y: -(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetY, 0) + fillRect.y
        };
        return skipTransform ? rect : this._transformedRect(rect, relativeTo);
      }
      drawScene(can, top) {
        var layer = this.getLayer(), canvas = can || layer.getCanvas(), context = canvas.getContext(), cachedCanvas = this._getCanvasCache(), drawFunc = this.getSceneFunc(), hasShadow = this.hasShadow(), stage, bufferCanvas, bufferContext, skipBuffer = canvas.isCache, cachingSelf = top === this;
        if (!this.isVisible() && !cachingSelf)
          return this;
        if (cachedCanvas) {
          context.save();
          var m = this.getAbsoluteTransform(top).getMatrix();
          return context.transform(m[0], m[1], m[2], m[3], m[4], m[5]), this._drawCachedSceneCanvas(context), context.restore(), this;
        }
        if (!drawFunc)
          return this;
        if (context.save(), this._useBufferCanvas() && !skipBuffer) {
          stage = this.getStage(), bufferCanvas = stage.bufferCanvas, bufferContext = bufferCanvas.getContext(), bufferContext.clear(), bufferContext.save(), bufferContext._applyLineJoin(this);
          var o = this.getAbsoluteTransform(top).getMatrix();
          bufferContext.transform(o[0], o[1], o[2], o[3], o[4], o[5]), drawFunc.call(this, bufferContext, this), bufferContext.restore();
          var ratio = bufferCanvas.pixelRatio;
          hasShadow && context._applyShadow(this), context._applyOpacity(this), context._applyGlobalCompositeOperation(this), context.drawImage(bufferCanvas._canvas, 0, 0, bufferCanvas.width / ratio, bufferCanvas.height / ratio);
        } else {
          if (context._applyLineJoin(this), !cachingSelf) {
            var o = this.getAbsoluteTransform(top).getMatrix();
            context.transform(o[0], o[1], o[2], o[3], o[4], o[5]), context._applyOpacity(this), context._applyGlobalCompositeOperation(this);
          }
          hasShadow && context._applyShadow(this), drawFunc.call(this, context, this);
        }
        return context.restore(), this;
      }
      drawHit(can, top, skipDragCheck = !1) {
        if (!this.shouldDrawHit(top, skipDragCheck))
          return this;
        var layer = this.getLayer(), canvas = can || layer.hitCanvas, context = canvas && canvas.getContext(), drawFunc = this.hitFunc() || this.sceneFunc(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;
        if (this.colorKey || Util_1.Util.warn("Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()"), cachedHitCanvas) {
          context.save();
          var m = this.getAbsoluteTransform(top).getMatrix();
          return context.transform(m[0], m[1], m[2], m[3], m[4], m[5]), this._drawCachedHitCanvas(context), context.restore(), this;
        }
        if (!drawFunc)
          return this;
        if (context.save(), context._applyLineJoin(this), !(this === top)) {
          var o = this.getAbsoluteTransform(top).getMatrix();
          context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
        }
        return drawFunc.call(this, context, this), context.restore(), this;
      }
      drawHitFromCache(alphaThreshold = 0) {
        var cachedCanvas = this._getCanvasCache(), sceneCanvas = this._getCachedSceneCanvas(), hitCanvas = cachedCanvas.hit, hitContext = hitCanvas.getContext(), hitWidth = hitCanvas.getWidth(), hitHeight = hitCanvas.getHeight(), hitImageData, hitData, len, rgbColorKey, i, alpha;
        hitContext.clear(), hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);
        try {
          for (hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight), hitData = hitImageData.data, len = hitData.length, rgbColorKey = Util_1.Util._hexToRgb(this.colorKey), i = 0; i < len; i += 4)
            alpha = hitData[i + 3], alpha > alphaThreshold ? (hitData[i] = rgbColorKey.r, hitData[i + 1] = rgbColorKey.g, hitData[i + 2] = rgbColorKey.b, hitData[i + 3] = 255) : hitData[i + 3] = 0;
          hitContext.putImageData(hitImageData, 0, 0);
        } catch (e) {
          Util_1.Util.error("Unable to draw hit graph from cached scene canvas. " + e.message);
        }
        return this;
      }
      hasPointerCapture(pointerId) {
        return PointerEvents.hasPointerCapture(pointerId, this);
      }
      setPointerCapture(pointerId) {
        PointerEvents.setPointerCapture(pointerId, this);
      }
      releaseCapture(pointerId) {
        PointerEvents.releaseCapture(pointerId, this);
      }
    };
    exports.Shape = Shape2;
    Shape2.prototype._fillFunc = _fillFunc2;
    Shape2.prototype._strokeFunc = _strokeFunc2;
    Shape2.prototype._fillFuncHit = _fillFuncHit2;
    Shape2.prototype._strokeFuncHit = _strokeFuncHit2;
    Shape2.prototype._centroid = !1;
    Shape2.prototype.nodeType = "Shape";
    (0, Global_2._registerNode)(Shape2);
    Shape2.prototype.eventListeners = {};
    Shape2.prototype.on.call(Shape2.prototype, "shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", _clearHasShadowCache2);
    Shape2.prototype.on.call(Shape2.prototype, "shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", _clearGetShadowRGBACache2);
    Shape2.prototype.on.call(Shape2.prototype, "fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva", _clearFillPatternCache2);
    Shape2.prototype.on.call(Shape2.prototype, "fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva", _clearLinearGradientCache2);
    Shape2.prototype.on.call(Shape2.prototype, "fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva", _clearRadialGradientCache2);
    Factory_1.Factory.addGetterSetter(Shape2, "stroke", void 0, (0, Validators_1.getStringOrGradientValidator)());
    Factory_1.Factory.addGetterSetter(Shape2, "strokeWidth", 2, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Shape2, "fillAfterStrokeEnabled", !1);
    Factory_1.Factory.addGetterSetter(Shape2, "hitStrokeWidth", "auto", (0, Validators_1.getNumberOrAutoValidator)());
    Factory_1.Factory.addGetterSetter(Shape2, "strokeHitEnabled", !0, (0, Validators_1.getBooleanValidator)());
    Factory_1.Factory.addGetterSetter(Shape2, "perfectDrawEnabled", !0, (0, Validators_1.getBooleanValidator)());
    Factory_1.Factory.addGetterSetter(Shape2, "shadowForStrokeEnabled", !0, (0, Validators_1.getBooleanValidator)());
    Factory_1.Factory.addGetterSetter(Shape2, "lineJoin");
    Factory_1.Factory.addGetterSetter(Shape2, "lineCap");
    Factory_1.Factory.addGetterSetter(Shape2, "sceneFunc");
    Factory_1.Factory.addGetterSetter(Shape2, "hitFunc");
    Factory_1.Factory.addGetterSetter(Shape2, "dash");
    Factory_1.Factory.addGetterSetter(Shape2, "dashOffset", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Shape2, "shadowColor", void 0, (0, Validators_1.getStringValidator)());
    Factory_1.Factory.addGetterSetter(Shape2, "shadowBlur", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Shape2, "shadowOpacity", 1, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addComponentsGetterSetter(Shape2, "shadowOffset", ["x", "y"]);
    Factory_1.Factory.addGetterSetter(Shape2, "shadowOffsetX", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Shape2, "shadowOffsetY", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Shape2, "fillPatternImage");
    Factory_1.Factory.addGetterSetter(Shape2, "fill", void 0, (0, Validators_1.getStringOrGradientValidator)());
    Factory_1.Factory.addGetterSetter(Shape2, "fillPatternX", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Shape2, "fillPatternY", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Shape2, "fillLinearGradientColorStops");
    Factory_1.Factory.addGetterSetter(Shape2, "strokeLinearGradientColorStops");
    Factory_1.Factory.addGetterSetter(Shape2, "fillRadialGradientStartRadius", 0);
    Factory_1.Factory.addGetterSetter(Shape2, "fillRadialGradientEndRadius", 0);
    Factory_1.Factory.addGetterSetter(Shape2, "fillRadialGradientColorStops");
    Factory_1.Factory.addGetterSetter(Shape2, "fillPatternRepeat", "repeat");
    Factory_1.Factory.addGetterSetter(Shape2, "fillEnabled", !0);
    Factory_1.Factory.addGetterSetter(Shape2, "strokeEnabled", !0);
    Factory_1.Factory.addGetterSetter(Shape2, "shadowEnabled", !0);
    Factory_1.Factory.addGetterSetter(Shape2, "dashEnabled", !0);
    Factory_1.Factory.addGetterSetter(Shape2, "strokeScaleEnabled", !0);
    Factory_1.Factory.addGetterSetter(Shape2, "fillPriority", "color");
    Factory_1.Factory.addComponentsGetterSetter(Shape2, "fillPatternOffset", ["x", "y"]);
    Factory_1.Factory.addGetterSetter(Shape2, "fillPatternOffsetX", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Shape2, "fillPatternOffsetY", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addComponentsGetterSetter(Shape2, "fillPatternScale", ["x", "y"]);
    Factory_1.Factory.addGetterSetter(Shape2, "fillPatternScaleX", 1, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Shape2, "fillPatternScaleY", 1, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addComponentsGetterSetter(Shape2, "fillLinearGradientStartPoint", [
      "x",
      "y"
    ]);
    Factory_1.Factory.addComponentsGetterSetter(Shape2, "strokeLinearGradientStartPoint", [
      "x",
      "y"
    ]);
    Factory_1.Factory.addGetterSetter(Shape2, "fillLinearGradientStartPointX", 0);
    Factory_1.Factory.addGetterSetter(Shape2, "strokeLinearGradientStartPointX", 0);
    Factory_1.Factory.addGetterSetter(Shape2, "fillLinearGradientStartPointY", 0);
    Factory_1.Factory.addGetterSetter(Shape2, "strokeLinearGradientStartPointY", 0);
    Factory_1.Factory.addComponentsGetterSetter(Shape2, "fillLinearGradientEndPoint", [
      "x",
      "y"
    ]);
    Factory_1.Factory.addComponentsGetterSetter(Shape2, "strokeLinearGradientEndPoint", [
      "x",
      "y"
    ]);
    Factory_1.Factory.addGetterSetter(Shape2, "fillLinearGradientEndPointX", 0);
    Factory_1.Factory.addGetterSetter(Shape2, "strokeLinearGradientEndPointX", 0);
    Factory_1.Factory.addGetterSetter(Shape2, "fillLinearGradientEndPointY", 0);
    Factory_1.Factory.addGetterSetter(Shape2, "strokeLinearGradientEndPointY", 0);
    Factory_1.Factory.addComponentsGetterSetter(Shape2, "fillRadialGradientStartPoint", [
      "x",
      "y"
    ]);
    Factory_1.Factory.addGetterSetter(Shape2, "fillRadialGradientStartPointX", 0);
    Factory_1.Factory.addGetterSetter(Shape2, "fillRadialGradientStartPointY", 0);
    Factory_1.Factory.addComponentsGetterSetter(Shape2, "fillRadialGradientEndPoint", [
      "x",
      "y"
    ]);
    Factory_1.Factory.addGetterSetter(Shape2, "fillRadialGradientEndPointX", 0);
    Factory_1.Factory.addGetterSetter(Shape2, "fillRadialGradientEndPointY", 0);
    Factory_1.Factory.addGetterSetter(Shape2, "fillPatternRotation", 0);
    Factory_1.Factory.backCompat(Shape2, {
      dashArray: "dash",
      getDashArray: "getDash",
      setDashArray: "getDash",
      drawFunc: "sceneFunc",
      getDrawFunc: "getSceneFunc",
      setDrawFunc: "setSceneFunc",
      drawHitFunc: "hitFunc",
      getDrawHitFunc: "getHitFunc",
      setDrawHitFunc: "setHitFunc"
    });
  }
});

// node_modules/konva/cmj/Layer.js
var require_Layer2 = __commonJS({
  "node_modules/konva/cmj/Layer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Layer = void 0;
    var Util_1 = require_Util(), Container_1 = require_Container(), Node_1 = require_Node(), Factory_1 = require_Factory(), Canvas_1 = require_Canvas(), Validators_1 = require_Validators(), Shape_1 = require_Shape(), Global_1 = require_Global2(), HASH3 = "#", BEFORE_DRAW2 = "beforeDraw", DRAW2 = "draw", INTERSECTION_OFFSETS2 = [
      { x: 0, y: 0 },
      { x: -1, y: -1 },
      { x: 1, y: -1 },
      { x: 1, y: 1 },
      { x: -1, y: 1 }
    ], INTERSECTION_OFFSETS_LEN2 = INTERSECTION_OFFSETS2.length, Layer4 = class extends Container_1.Container {
      constructor(config) {
        super(config), this.canvas = new Canvas_1.SceneCanvas(), this.hitCanvas = new Canvas_1.HitCanvas({
          pixelRatio: 1
        }), this._waitingForDraw = !1, this.on("visibleChange.konva", this._checkVisibility), this._checkVisibility(), this.on("imageSmoothingEnabledChange.konva", this._setSmoothEnabled), this._setSmoothEnabled();
      }
      createPNGStream() {
        return this.canvas._canvas.createPNGStream();
      }
      getCanvas() {
        return this.canvas;
      }
      getNativeCanvasElement() {
        return this.canvas._canvas;
      }
      getHitCanvas() {
        return this.hitCanvas;
      }
      getContext() {
        return this.getCanvas().getContext();
      }
      clear(bounds) {
        return this.getContext().clear(bounds), this.getHitCanvas().getContext().clear(bounds), this;
      }
      setZIndex(index) {
        super.setZIndex(index);
        var stage = this.getStage();
        return stage && stage.content && (stage.content.removeChild(this.getNativeCanvasElement()), index < stage.children.length - 1 ? stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[index + 1].getCanvas()._canvas) : stage.content.appendChild(this.getNativeCanvasElement())), this;
      }
      moveToTop() {
        Node_1.Node.prototype.moveToTop.call(this);
        var stage = this.getStage();
        return stage && stage.content && (stage.content.removeChild(this.getNativeCanvasElement()), stage.content.appendChild(this.getNativeCanvasElement())), !0;
      }
      moveUp() {
        var moved = Node_1.Node.prototype.moveUp.call(this);
        if (!moved)
          return !1;
        var stage = this.getStage();
        return !stage || !stage.content ? !1 : (stage.content.removeChild(this.getNativeCanvasElement()), this.index < stage.children.length - 1 ? stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[this.index + 1].getCanvas()._canvas) : stage.content.appendChild(this.getNativeCanvasElement()), !0);
      }
      moveDown() {
        if (Node_1.Node.prototype.moveDown.call(this)) {
          var stage = this.getStage();
          if (stage) {
            var children = stage.children;
            stage.content && (stage.content.removeChild(this.getNativeCanvasElement()), stage.content.insertBefore(this.getNativeCanvasElement(), children[this.index + 1].getCanvas()._canvas));
          }
          return !0;
        }
        return !1;
      }
      moveToBottom() {
        if (Node_1.Node.prototype.moveToBottom.call(this)) {
          var stage = this.getStage();
          if (stage) {
            var children = stage.children;
            stage.content && (stage.content.removeChild(this.getNativeCanvasElement()), stage.content.insertBefore(this.getNativeCanvasElement(), children[1].getCanvas()._canvas));
          }
          return !0;
        }
        return !1;
      }
      getLayer() {
        return this;
      }
      remove() {
        var _canvas = this.getNativeCanvasElement();
        return Node_1.Node.prototype.remove.call(this), _canvas && _canvas.parentNode && Util_1.Util._isInDocument(_canvas) && _canvas.parentNode.removeChild(_canvas), this;
      }
      getStage() {
        return this.parent;
      }
      setSize({ width, height }) {
        return this.canvas.setSize(width, height), this.hitCanvas.setSize(width, height), this._setSmoothEnabled(), this;
      }
      _validateAdd(child) {
        var type = child.getType();
        type !== "Group" && type !== "Shape" && Util_1.Util.throw("You may only add groups and shapes to a layer.");
      }
      _toKonvaCanvas(config) {
        return config = config || {}, config.width = config.width || this.getWidth(), config.height = config.height || this.getHeight(), config.x = config.x !== void 0 ? config.x : this.x(), config.y = config.y !== void 0 ? config.y : this.y(), Node_1.Node.prototype._toKonvaCanvas.call(this, config);
      }
      _checkVisibility() {
        this.visible() ? this.canvas._canvas.style.display = "block" : this.canvas._canvas.style.display = "none";
      }
      _setSmoothEnabled() {
        this.getContext()._context.imageSmoothingEnabled = this.imageSmoothingEnabled();
      }
      getWidth() {
        if (this.parent)
          return this.parent.width();
      }
      setWidth() {
        Util_1.Util.warn('Can not change width of layer. Use "stage.width(value)" function instead.');
      }
      getHeight() {
        if (this.parent)
          return this.parent.height();
      }
      setHeight() {
        Util_1.Util.warn('Can not change height of layer. Use "stage.height(value)" function instead.');
      }
      batchDraw() {
        return this._waitingForDraw || (this._waitingForDraw = !0, Util_1.Util.requestAnimFrame(() => {
          this.draw(), this._waitingForDraw = !1;
        })), this;
      }
      getIntersection(pos) {
        if (!this.isListening() || !this.isVisible())
          return null;
        for (var spiralSearchDistance = 1, continueSearch = !1; ; ) {
          for (let i = 0; i < INTERSECTION_OFFSETS_LEN2; i++) {
            let intersectionOffset = INTERSECTION_OFFSETS2[i], obj = this._getIntersection({
              x: pos.x + intersectionOffset.x * spiralSearchDistance,
              y: pos.y + intersectionOffset.y * spiralSearchDistance
            }), shape = obj.shape;
            if (shape)
              return shape;
            if (continueSearch = !!obj.antialiased, !obj.antialiased)
              break;
          }
          if (continueSearch)
            spiralSearchDistance += 1;
          else
            return null;
        }
      }
      _getIntersection(pos) {
        let ratio = this.hitCanvas.pixelRatio, p = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio), Math.round(pos.y * ratio), 1, 1).data, p3 = p[3];
        if (p3 === 255) {
          let colorKey = Util_1.Util._rgbToHex(p[0], p[1], p[2]), shape = Shape_1.shapes[HASH3 + colorKey];
          return shape ? {
            shape
          } : {
            antialiased: !0
          };
        } else if (p3 > 0)
          return {
            antialiased: !0
          };
        return {};
      }
      drawScene(can, top) {
        var layer = this.getLayer(), canvas = can || layer && layer.getCanvas();
        return this._fire(BEFORE_DRAW2, {
          node: this
        }), this.clearBeforeDraw() && canvas.getContext().clear(), Container_1.Container.prototype.drawScene.call(this, canvas, top), this._fire(DRAW2, {
          node: this
        }), this;
      }
      drawHit(can, top) {
        var layer = this.getLayer(), canvas = can || layer && layer.hitCanvas;
        return layer && layer.clearBeforeDraw() && layer.getHitCanvas().getContext().clear(), Container_1.Container.prototype.drawHit.call(this, canvas, top), this;
      }
      enableHitGraph() {
        return this.hitGraphEnabled(!0), this;
      }
      disableHitGraph() {
        return this.hitGraphEnabled(!1), this;
      }
      setHitGraphEnabled(val) {
        Util_1.Util.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening(val);
      }
      getHitGraphEnabled(val) {
        return Util_1.Util.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening();
      }
      toggleHitCanvas() {
        if (!(!this.parent || !this.parent.content)) {
          var parent = this.parent, added = !!this.hitCanvas._canvas.parentNode;
          added ? parent.content.removeChild(this.hitCanvas._canvas) : parent.content.appendChild(this.hitCanvas._canvas);
        }
      }
      destroy() {
        return Util_1.Util.releaseCanvas(this.getNativeCanvasElement(), this.getHitCanvas()._canvas), super.destroy();
      }
    };
    exports.Layer = Layer4;
    Layer4.prototype.nodeType = "Layer";
    (0, Global_1._registerNode)(Layer4);
    Factory_1.Factory.addGetterSetter(Layer4, "imageSmoothingEnabled", !0);
    Factory_1.Factory.addGetterSetter(Layer4, "clearBeforeDraw", !0);
    Factory_1.Factory.addGetterSetter(Layer4, "hitGraphEnabled", !0, (0, Validators_1.getBooleanValidator)());
  }
});

// node_modules/konva/cmj/FastLayer.js
var require_FastLayer = __commonJS({
  "node_modules/konva/cmj/FastLayer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.FastLayer = void 0;
    var Util_1 = require_Util(), Layer_1 = require_Layer2(), Global_1 = require_Global2(), FastLayer2 = class extends Layer_1.Layer {
      constructor(attrs) {
        super(attrs), this.listening(!1), Util_1.Util.warn('Konva.Fast layer is deprecated. Please use "new Konva.Layer({ listening: false })" instead.');
      }
    };
    exports.FastLayer = FastLayer2;
    FastLayer2.prototype.nodeType = "FastLayer";
    (0, Global_1._registerNode)(FastLayer2);
  }
});

// node_modules/konva/cmj/Group.js
var require_Group = __commonJS({
  "node_modules/konva/cmj/Group.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Group = void 0;
    var Util_1 = require_Util(), Container_1 = require_Container(), Global_1 = require_Global2(), Group2 = class extends Container_1.Container {
      _validateAdd(child) {
        var type = child.getType();
        type !== "Group" && type !== "Shape" && Util_1.Util.throw("You may only add groups and shapes to groups.");
      }
    };
    exports.Group = Group2;
    Group2.prototype.nodeType = "Group";
    (0, Global_1._registerNode)(Group2);
  }
});

// node_modules/konva/cmj/Animation.js
var require_Animation = __commonJS({
  "node_modules/konva/cmj/Animation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Animation = void 0;
    var Global_1 = require_Global2(), Util_1 = require_Util(), now2 = function() {
      return Global_1.glob.performance && Global_1.glob.performance.now ? function() {
        return Global_1.glob.performance.now();
      } : function() {
        return new Date().getTime();
      };
    }(), Animation2 = class {
      constructor(func, layers) {
        this.id = Animation2.animIdCounter++, this.frame = {
          time: 0,
          timeDiff: 0,
          lastTime: now2(),
          frameRate: 0
        }, this.func = func, this.setLayers(layers);
      }
      setLayers(layers) {
        var lays = [];
        return layers ? layers.length > 0 ? lays = layers : lays = [layers] : lays = [], this.layers = lays, this;
      }
      getLayers() {
        return this.layers;
      }
      addLayer(layer) {
        var layers = this.layers, len = layers.length, n;
        for (n = 0; n < len; n++)
          if (layers[n]._id === layer._id)
            return !1;
        return this.layers.push(layer), !0;
      }
      isRunning() {
        var a = Animation2, animations = a.animations, len = animations.length, n;
        for (n = 0; n < len; n++)
          if (animations[n].id === this.id)
            return !0;
        return !1;
      }
      start() {
        return this.stop(), this.frame.timeDiff = 0, this.frame.lastTime = now2(), Animation2._addAnimation(this), this;
      }
      stop() {
        return Animation2._removeAnimation(this), this;
      }
      _updateFrameObject(time) {
        this.frame.timeDiff = time - this.frame.lastTime, this.frame.lastTime = time, this.frame.time += this.frame.timeDiff, this.frame.frameRate = 1e3 / this.frame.timeDiff;
      }
      static _addAnimation(anim) {
        this.animations.push(anim), this._handleAnimation();
      }
      static _removeAnimation(anim) {
        var id = anim.id, animations = this.animations, len = animations.length, n;
        for (n = 0; n < len; n++)
          if (animations[n].id === id) {
            this.animations.splice(n, 1);
            break;
          }
      }
      static _runFrames() {
        var layerHash = {}, animations = this.animations, anim, layers, func, n, i, layersLen, layer, key, needRedraw;
        for (n = 0; n < animations.length; n++)
          if (anim = animations[n], layers = anim.layers, func = anim.func, anim._updateFrameObject(now2()), layersLen = layers.length, func ? needRedraw = func.call(anim, anim.frame) !== !1 : needRedraw = !0, !!needRedraw)
            for (i = 0; i < layersLen; i++)
              layer = layers[i], layer._id !== void 0 && (layerHash[layer._id] = layer);
        for (key in layerHash)
          !layerHash.hasOwnProperty(key) || layerHash[key].batchDraw();
      }
      static _animationLoop() {
        var Anim = Animation2;
        Anim.animations.length ? (Anim._runFrames(), Util_1.Util.requestAnimFrame(Anim._animationLoop)) : Anim.animRunning = !1;
      }
      static _handleAnimation() {
        this.animRunning || (this.animRunning = !0, Util_1.Util.requestAnimFrame(this._animationLoop));
      }
    };
    exports.Animation = Animation2;
    Animation2.animations = [];
    Animation2.animIdCounter = 0;
    Animation2.animRunning = !1;
  }
});

// node_modules/konva/cmj/Tween.js
var require_Tween = __commonJS({
  "node_modules/konva/cmj/Tween.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Easings = exports.Tween = void 0;
    var Util_1 = require_Util(), Animation_1 = require_Animation(), Node_1 = require_Node(), Global_1 = require_Global2(), blacklist2 = {
      node: 1,
      duration: 1,
      easing: 1,
      onFinish: 1,
      yoyo: 1
    }, PAUSED2 = 1, PLAYING2 = 2, REVERSING2 = 3, idCounter3 = 0, colorAttrs2 = ["fill", "stroke", "shadowColor"], TweenEngine2 = class {
      constructor(prop, propFunc, func, begin, finish, duration, yoyo) {
        this.prop = prop, this.propFunc = propFunc, this.begin = begin, this._pos = begin, this.duration = duration, this._change = 0, this.prevPos = 0, this.yoyo = yoyo, this._time = 0, this._position = 0, this._startTime = 0, this._finish = 0, this.func = func, this._change = finish - this.begin, this.pause();
      }
      fire(str) {
        var handler = this[str];
        handler && handler();
      }
      setTime(t) {
        t > this.duration ? this.yoyo ? (this._time = this.duration, this.reverse()) : this.finish() : t < 0 ? this.yoyo ? (this._time = 0, this.play()) : this.reset() : (this._time = t, this.update());
      }
      getTime() {
        return this._time;
      }
      setPosition(p) {
        this.prevPos = this._pos, this.propFunc(p), this._pos = p;
      }
      getPosition(t) {
        return t === void 0 && (t = this._time), this.func(t, this.begin, this._change, this.duration);
      }
      play() {
        this.state = PLAYING2, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onPlay");
      }
      reverse() {
        this.state = REVERSING2, this._time = this.duration - this._time, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onReverse");
      }
      seek(t) {
        this.pause(), this._time = t, this.update(), this.fire("onSeek");
      }
      reset() {
        this.pause(), this._time = 0, this.update(), this.fire("onReset");
      }
      finish() {
        this.pause(), this._time = this.duration, this.update(), this.fire("onFinish");
      }
      update() {
        this.setPosition(this.getPosition(this._time)), this.fire("onUpdate");
      }
      onEnterFrame() {
        var t = this.getTimer() - this._startTime;
        this.state === PLAYING2 ? this.setTime(t) : this.state === REVERSING2 && this.setTime(this.duration - t);
      }
      pause() {
        this.state = PAUSED2, this.fire("onPause");
      }
      getTimer() {
        return new Date().getTime();
      }
    }, Tween2 = class {
      constructor(config) {
        var that = this, node = config.node, nodeId = node._id, duration, easing = config.easing || exports.Easings.Linear, yoyo = !!config.yoyo, key;
        typeof config.duration > "u" ? duration = 0.3 : config.duration === 0 ? duration = 1e-3 : duration = config.duration, this.node = node, this._id = idCounter3++;
        var layers = node.getLayer() || (node instanceof Global_1.Konva.Stage ? node.getLayers() : null);
        layers || Util_1.Util.error("Tween constructor have `node` that is not in a layer. Please add node into layer first."), this.anim = new Animation_1.Animation(function() {
          that.tween.onEnterFrame();
        }, layers), this.tween = new TweenEngine2(key, function(i) {
          that._tweenFunc(i);
        }, easing, 0, 1, duration * 1e3, yoyo), this._addListeners(), Tween2.attrs[nodeId] || (Tween2.attrs[nodeId] = {}), Tween2.attrs[nodeId][this._id] || (Tween2.attrs[nodeId][this._id] = {}), Tween2.tweens[nodeId] || (Tween2.tweens[nodeId] = {});
        for (key in config)
          blacklist2[key] === void 0 && this._addAttr(key, config[key]);
        this.reset(), this.onFinish = config.onFinish, this.onReset = config.onReset, this.onUpdate = config.onUpdate;
      }
      _addAttr(key, end) {
        var node = this.node, nodeId = node._id, start, diff, tweenId, n, len, trueEnd, trueStart, endRGBA;
        if (tweenId = Tween2.tweens[nodeId][key], tweenId && delete Tween2.attrs[nodeId][tweenId][key], start = node.getAttr(key), Util_1.Util._isArray(end))
          if (diff = [], len = Math.max(end.length, start.length), key === "points" && end.length !== start.length && (end.length > start.length ? (trueStart = start, start = Util_1.Util._prepareArrayForTween(start, end, node.closed())) : (trueEnd = end, end = Util_1.Util._prepareArrayForTween(end, start, node.closed()))), key.indexOf("fill") === 0)
            for (n = 0; n < len; n++)
              if (n % 2 === 0)
                diff.push(end[n] - start[n]);
              else {
                var startRGBA = Util_1.Util.colorToRGBA(start[n]);
                endRGBA = Util_1.Util.colorToRGBA(end[n]), start[n] = startRGBA, diff.push({
                  r: endRGBA.r - startRGBA.r,
                  g: endRGBA.g - startRGBA.g,
                  b: endRGBA.b - startRGBA.b,
                  a: endRGBA.a - startRGBA.a
                });
              }
          else
            for (n = 0; n < len; n++)
              diff.push(end[n] - start[n]);
        else
          colorAttrs2.indexOf(key) !== -1 ? (start = Util_1.Util.colorToRGBA(start), endRGBA = Util_1.Util.colorToRGBA(end), diff = {
            r: endRGBA.r - start.r,
            g: endRGBA.g - start.g,
            b: endRGBA.b - start.b,
            a: endRGBA.a - start.a
          }) : diff = end - start;
        Tween2.attrs[nodeId][this._id][key] = {
          start,
          diff,
          end,
          trueEnd,
          trueStart
        }, Tween2.tweens[nodeId][key] = this._id;
      }
      _tweenFunc(i) {
        var node = this.node, attrs = Tween2.attrs[node._id][this._id], key, attr, start, diff, newVal, n, len, end;
        for (key in attrs) {
          if (attr = attrs[key], start = attr.start, diff = attr.diff, end = attr.end, Util_1.Util._isArray(start))
            if (newVal = [], len = Math.max(start.length, end.length), key.indexOf("fill") === 0)
              for (n = 0; n < len; n++)
                n % 2 === 0 ? newVal.push((start[n] || 0) + diff[n] * i) : newVal.push("rgba(" + Math.round(start[n].r + diff[n].r * i) + "," + Math.round(start[n].g + diff[n].g * i) + "," + Math.round(start[n].b + diff[n].b * i) + "," + (start[n].a + diff[n].a * i) + ")");
            else
              for (n = 0; n < len; n++)
                newVal.push((start[n] || 0) + diff[n] * i);
          else
            colorAttrs2.indexOf(key) !== -1 ? newVal = "rgba(" + Math.round(start.r + diff.r * i) + "," + Math.round(start.g + diff.g * i) + "," + Math.round(start.b + diff.b * i) + "," + (start.a + diff.a * i) + ")" : newVal = start + diff * i;
          node.setAttr(key, newVal);
        }
      }
      _addListeners() {
        this.tween.onPlay = () => {
          this.anim.start();
        }, this.tween.onReverse = () => {
          this.anim.start();
        }, this.tween.onPause = () => {
          this.anim.stop();
        }, this.tween.onFinish = () => {
          var node = this.node, attrs = Tween2.attrs[node._id][this._id];
          attrs.points && attrs.points.trueEnd && node.setAttr("points", attrs.points.trueEnd), this.onFinish && this.onFinish.call(this);
        }, this.tween.onReset = () => {
          var node = this.node, attrs = Tween2.attrs[node._id][this._id];
          attrs.points && attrs.points.trueStart && node.points(attrs.points.trueStart), this.onReset && this.onReset();
        }, this.tween.onUpdate = () => {
          this.onUpdate && this.onUpdate.call(this);
        };
      }
      play() {
        return this.tween.play(), this;
      }
      reverse() {
        return this.tween.reverse(), this;
      }
      reset() {
        return this.tween.reset(), this;
      }
      seek(t) {
        return this.tween.seek(t * 1e3), this;
      }
      pause() {
        return this.tween.pause(), this;
      }
      finish() {
        return this.tween.finish(), this;
      }
      destroy() {
        var nodeId = this.node._id, thisId = this._id, attrs = Tween2.tweens[nodeId], key;
        this.pause();
        for (key in attrs)
          delete Tween2.tweens[nodeId][key];
        delete Tween2.attrs[nodeId][thisId];
      }
    };
    exports.Tween = Tween2;
    Tween2.attrs = {};
    Tween2.tweens = {};
    Node_1.Node.prototype.to = function(params) {
      var onFinish = params.onFinish;
      params.node = this, params.onFinish = function() {
        this.destroy(), onFinish && onFinish();
      };
      var tween = new Tween2(params);
      tween.play();
    };
    exports.Easings = {
      BackEaseIn(t, b, c, d) {
        var s = 1.70158;
        return c * (t /= d) * t * ((s + 1) * t - s) + b;
      },
      BackEaseOut(t, b, c, d) {
        var s = 1.70158;
        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
      },
      BackEaseInOut(t, b, c, d) {
        var s = 1.70158;
        return (t /= d / 2) < 1 ? c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b : c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
      },
      ElasticEaseIn(t, b, c, d, a, p) {
        var s = 0;
        return t === 0 ? b : (t /= d) === 1 ? b + c : (p || (p = d * 0.3), !a || a < Math.abs(c) ? (a = c, s = p / 4) : s = p / (2 * Math.PI) * Math.asin(c / a), -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b);
      },
      ElasticEaseOut(t, b, c, d, a, p) {
        var s = 0;
        return t === 0 ? b : (t /= d) === 1 ? b + c : (p || (p = d * 0.3), !a || a < Math.abs(c) ? (a = c, s = p / 4) : s = p / (2 * Math.PI) * Math.asin(c / a), a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b);
      },
      ElasticEaseInOut(t, b, c, d, a, p) {
        var s = 0;
        return t === 0 ? b : (t /= d / 2) === 2 ? b + c : (p || (p = d * (0.3 * 1.5)), !a || a < Math.abs(c) ? (a = c, s = p / 4) : s = p / (2 * Math.PI) * Math.asin(c / a), t < 1 ? -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b : a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b);
      },
      BounceEaseOut(t, b, c, d) {
        return (t /= d) < 1 / 2.75 ? c * (7.5625 * t * t) + b : t < 2 / 2.75 ? c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b : t < 2.5 / 2.75 ? c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b : c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
      },
      BounceEaseIn(t, b, c, d) {
        return c - exports.Easings.BounceEaseOut(d - t, 0, c, d) + b;
      },
      BounceEaseInOut(t, b, c, d) {
        return t < d / 2 ? exports.Easings.BounceEaseIn(t * 2, 0, c, d) * 0.5 + b : exports.Easings.BounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
      },
      EaseIn(t, b, c, d) {
        return c * (t /= d) * t + b;
      },
      EaseOut(t, b, c, d) {
        return -c * (t /= d) * (t - 2) + b;
      },
      EaseInOut(t, b, c, d) {
        return (t /= d / 2) < 1 ? c / 2 * t * t + b : -c / 2 * (--t * (t - 2) - 1) + b;
      },
      StrongEaseIn(t, b, c, d) {
        return c * (t /= d) * t * t * t * t + b;
      },
      StrongEaseOut(t, b, c, d) {
        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
      },
      StrongEaseInOut(t, b, c, d) {
        return (t /= d / 2) < 1 ? c / 2 * t * t * t * t * t + b : c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
      },
      Linear(t, b, c, d) {
        return c * t / d + b;
      }
    };
  }
});

// node_modules/konva/cmj/_CoreInternals.js
var require_CoreInternals = __commonJS({
  "node_modules/konva/cmj/_CoreInternals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Konva = void 0;
    var Global_1 = require_Global2(), Util_1 = require_Util(), Node_1 = require_Node(), Container_1 = require_Container(), Stage_1 = require_Stage(), Layer_1 = require_Layer2(), FastLayer_1 = require_FastLayer(), Group_1 = require_Group(), DragAndDrop_1 = require_DragAndDrop(), Shape_1 = require_Shape(), Animation_1 = require_Animation(), Tween_1 = require_Tween(), Context_1 = require_Context(), Canvas_1 = require_Canvas();
    exports.Konva = Util_1.Util._assign(Global_1.Konva, {
      Util: Util_1.Util,
      Transform: Util_1.Transform,
      Node: Node_1.Node,
      Container: Container_1.Container,
      Stage: Stage_1.Stage,
      stages: Stage_1.stages,
      Layer: Layer_1.Layer,
      FastLayer: FastLayer_1.FastLayer,
      Group: Group_1.Group,
      DD: DragAndDrop_1.DD,
      Shape: Shape_1.Shape,
      shapes: Shape_1.shapes,
      Animation: Animation_1.Animation,
      Tween: Tween_1.Tween,
      Easings: Tween_1.Easings,
      Context: Context_1.Context,
      Canvas: Canvas_1.Canvas
    });
    exports.default = exports.Konva;
  }
});

// node_modules/konva/cmj/shapes/Arc.js
var require_Arc = __commonJS({
  "node_modules/konva/cmj/shapes/Arc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Arc = void 0;
    var Factory_1 = require_Factory(), Shape_1 = require_Shape(), Global_1 = require_Global2(), Validators_1 = require_Validators(), Global_2 = require_Global2(), Arc = class extends Shape_1.Shape {
      _sceneFunc(context) {
        var angle = Global_1.Konva.getAngle(this.angle()), clockwise = this.clockwise();
        context.beginPath(), context.arc(0, 0, this.outerRadius(), 0, angle, clockwise), context.arc(0, 0, this.innerRadius(), angle, 0, !clockwise), context.closePath(), context.fillStrokeShape(this);
      }
      getWidth() {
        return this.outerRadius() * 2;
      }
      getHeight() {
        return this.outerRadius() * 2;
      }
      setWidth(width) {
        this.outerRadius(width / 2);
      }
      setHeight(height) {
        this.outerRadius(height / 2);
      }
      getSelfRect() {
        let innerRadius = this.innerRadius(), outerRadius = this.outerRadius(), clockwise = this.clockwise(), angle = Global_1.Konva.getAngle(clockwise ? 360 - this.angle() : this.angle()), boundLeftRatio = Math.cos(Math.min(angle, Math.PI)), boundRightRatio = 1, boundTopRatio = Math.sin(Math.min(Math.max(Math.PI, angle), 3 * Math.PI / 2)), boundBottomRatio = Math.sin(Math.min(angle, Math.PI / 2)), boundLeft = boundLeftRatio * (boundLeftRatio > 0 ? innerRadius : outerRadius), boundRight = boundRightRatio * (boundRightRatio > 0 ? outerRadius : innerRadius), boundTop = boundTopRatio * (boundTopRatio > 0 ? innerRadius : outerRadius), boundBottom = boundBottomRatio * (boundBottomRatio > 0 ? outerRadius : innerRadius);
        return {
          x: boundLeft,
          y: clockwise ? -1 * boundBottom : boundTop,
          width: boundRight - boundLeft,
          height: boundBottom - boundTop
        };
      }
    };
    exports.Arc = Arc;
    Arc.prototype._centroid = !0;
    Arc.prototype.className = "Arc";
    Arc.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
    (0, Global_2._registerNode)(Arc);
    Factory_1.Factory.addGetterSetter(Arc, "innerRadius", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Arc, "outerRadius", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Arc, "angle", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Arc, "clockwise", !1, (0, Validators_1.getBooleanValidator)());
  }
});

// node_modules/konva/cmj/shapes/Line.js
var require_Line2 = __commonJS({
  "node_modules/konva/cmj/shapes/Line.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Line = void 0;
    var Factory_1 = require_Factory(), Shape_1 = require_Shape(), Validators_1 = require_Validators(), Global_1 = require_Global2();
    function getControlPoints(x0, y0, x1, y1, x2, y2, t) {
      var d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)), d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)), fa = t * d01 / (d01 + d12), fb = t * d12 / (d01 + d12), p1x = x1 - fa * (x2 - x0), p1y = y1 - fa * (y2 - y0), p2x = x1 + fb * (x2 - x0), p2y = y1 + fb * (y2 - y0);
      return [p1x, p1y, p2x, p2y];
    }
    function expandPoints(p, tension) {
      var len = p.length, allPoints = [], n, cp;
      for (n = 2; n < len - 2; n += 2)
        cp = getControlPoints(p[n - 2], p[n - 1], p[n], p[n + 1], p[n + 2], p[n + 3], tension), !isNaN(cp[0]) && (allPoints.push(cp[0]), allPoints.push(cp[1]), allPoints.push(p[n]), allPoints.push(p[n + 1]), allPoints.push(cp[2]), allPoints.push(cp[3]));
      return allPoints;
    }
    var Line = class extends Shape_1.Shape {
      constructor(config) {
        super(config), this.on("pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva", function() {
          this._clearCache("tensionPoints");
        });
      }
      _sceneFunc(context) {
        var points = this.points(), length = points.length, tension = this.tension(), closed = this.closed(), bezier = this.bezier(), tp, len, n;
        if (!!length) {
          if (context.beginPath(), context.moveTo(points[0], points[1]), tension !== 0 && length > 4) {
            for (tp = this.getTensionPoints(), len = tp.length, n = closed ? 0 : 4, closed || context.quadraticCurveTo(tp[0], tp[1], tp[2], tp[3]); n < len - 2; )
              context.bezierCurveTo(tp[n++], tp[n++], tp[n++], tp[n++], tp[n++], tp[n++]);
            closed || context.quadraticCurveTo(tp[len - 2], tp[len - 1], points[length - 2], points[length - 1]);
          } else if (bezier)
            for (n = 2; n < length; )
              context.bezierCurveTo(points[n++], points[n++], points[n++], points[n++], points[n++], points[n++]);
          else
            for (n = 2; n < length; n += 2)
              context.lineTo(points[n], points[n + 1]);
          closed ? (context.closePath(), context.fillStrokeShape(this)) : context.strokeShape(this);
        }
      }
      getTensionPoints() {
        return this._getCache("tensionPoints", this._getTensionPoints);
      }
      _getTensionPoints() {
        return this.closed() ? this._getTensionPointsClosed() : expandPoints(this.points(), this.tension());
      }
      _getTensionPointsClosed() {
        var p = this.points(), len = p.length, tension = this.tension(), firstControlPoints = getControlPoints(p[len - 2], p[len - 1], p[0], p[1], p[2], p[3], tension), lastControlPoints = getControlPoints(p[len - 4], p[len - 3], p[len - 2], p[len - 1], p[0], p[1], tension), middle = expandPoints(p, tension), tp = [firstControlPoints[2], firstControlPoints[3]].concat(middle).concat([
          lastControlPoints[0],
          lastControlPoints[1],
          p[len - 2],
          p[len - 1],
          lastControlPoints[2],
          lastControlPoints[3],
          firstControlPoints[0],
          firstControlPoints[1],
          p[0],
          p[1]
        ]);
        return tp;
      }
      getWidth() {
        return this.getSelfRect().width;
      }
      getHeight() {
        return this.getSelfRect().height;
      }
      getSelfRect() {
        var points = this.points();
        if (points.length < 4)
          return {
            x: points[0] || 0,
            y: points[1] || 0,
            width: 0,
            height: 0
          };
        this.tension() !== 0 ? points = [
          points[0],
          points[1],
          ...this._getTensionPoints(),
          points[points.length - 2],
          points[points.length - 1]
        ] : points = this.points();
        for (var minX = points[0], maxX = points[0], minY = points[1], maxY = points[1], x, y, i = 0; i < points.length / 2; i++)
          x = points[i * 2], y = points[i * 2 + 1], minX = Math.min(minX, x), maxX = Math.max(maxX, x), minY = Math.min(minY, y), maxY = Math.max(maxY, y);
        return {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
      }
    };
    exports.Line = Line;
    Line.prototype.className = "Line";
    Line.prototype._attrsAffectingSize = ["points", "bezier", "tension"];
    (0, Global_1._registerNode)(Line);
    Factory_1.Factory.addGetterSetter(Line, "closed", !1);
    Factory_1.Factory.addGetterSetter(Line, "bezier", !1);
    Factory_1.Factory.addGetterSetter(Line, "tension", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Line, "points", [], (0, Validators_1.getNumberArrayValidator)());
  }
});

// node_modules/konva/cmj/shapes/Path.js
var require_Path = __commonJS({
  "node_modules/konva/cmj/shapes/Path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Path = void 0;
    var Factory_1 = require_Factory(), Shape_1 = require_Shape(), Global_1 = require_Global2(), Path = class extends Shape_1.Shape {
      constructor(config) {
        super(config), this.dataArray = [], this.pathLength = 0, this.dataArray = Path.parsePathData(this.data()), this.pathLength = 0;
        for (var i = 0; i < this.dataArray.length; ++i)
          this.pathLength += this.dataArray[i].pathLength;
        this.on("dataChange.konva", function() {
          this.dataArray = Path.parsePathData(this.data()), this.pathLength = 0;
          for (var i2 = 0; i2 < this.dataArray.length; ++i2)
            this.pathLength += this.dataArray[i2].pathLength;
        });
      }
      _sceneFunc(context) {
        var ca = this.dataArray;
        context.beginPath();
        for (var isClosed = !1, n = 0; n < ca.length; n++) {
          var c = ca[n].command, p = ca[n].points;
          switch (c) {
            case "L":
              context.lineTo(p[0], p[1]);
              break;
            case "M":
              context.moveTo(p[0], p[1]);
              break;
            case "C":
              context.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
              break;
            case "Q":
              context.quadraticCurveTo(p[0], p[1], p[2], p[3]);
              break;
            case "A":
              var cx = p[0], cy = p[1], rx = p[2], ry = p[3], theta = p[4], dTheta = p[5], psi = p[6], fs = p[7], r = rx > ry ? rx : ry, scaleX = rx > ry ? 1 : rx / ry, scaleY = rx > ry ? ry / rx : 1;
              context.translate(cx, cy), context.rotate(psi), context.scale(scaleX, scaleY), context.arc(0, 0, r, theta, theta + dTheta, 1 - fs), context.scale(1 / scaleX, 1 / scaleY), context.rotate(-psi), context.translate(-cx, -cy);
              break;
            case "z":
              isClosed = !0, context.closePath();
              break;
          }
        }
        !isClosed && !this.hasFill() ? context.strokeShape(this) : context.fillStrokeShape(this);
      }
      getSelfRect() {
        var points = [];
        this.dataArray.forEach(function(data) {
          if (data.command === "A") {
            var start = data.points[4], dTheta = data.points[5], end = data.points[4] + dTheta, inc = Math.PI / 180;
            if (Math.abs(start - end) < inc && (inc = Math.abs(start - end)), dTheta < 0)
              for (let t = start - inc; t > end; t -= inc) {
                let point = Path.getPointOnEllipticalArc(data.points[0], data.points[1], data.points[2], data.points[3], t, 0);
                points.push(point.x, point.y);
              }
            else
              for (let t = start + inc; t < end; t += inc) {
                let point = Path.getPointOnEllipticalArc(data.points[0], data.points[1], data.points[2], data.points[3], t, 0);
                points.push(point.x, point.y);
              }
          } else if (data.command === "C")
            for (let t = 0; t <= 1; t += 0.01) {
              let point = Path.getPointOnCubicBezier(t, data.start.x, data.start.y, data.points[0], data.points[1], data.points[2], data.points[3], data.points[4], data.points[5]);
              points.push(point.x, point.y);
            }
          else
            points = points.concat(data.points);
        });
        for (var minX = points[0], maxX = points[0], minY = points[1], maxY = points[1], x, y, i = 0; i < points.length / 2; i++)
          x = points[i * 2], y = points[i * 2 + 1], isNaN(x) || (minX = Math.min(minX, x), maxX = Math.max(maxX, x)), isNaN(y) || (minY = Math.min(minY, y), maxY = Math.max(maxY, y));
        return {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
      }
      getLength() {
        return this.pathLength;
      }
      getPointAtLength(length) {
        var point, i = 0, ii = this.dataArray.length;
        if (!ii)
          return null;
        for (; i < ii && length > this.dataArray[i].pathLength; )
          length -= this.dataArray[i].pathLength, ++i;
        if (i === ii)
          return point = this.dataArray[i - 1].points.slice(-2), {
            x: point[0],
            y: point[1]
          };
        if (length < 0.01)
          return point = this.dataArray[i].points.slice(0, 2), {
            x: point[0],
            y: point[1]
          };
        var cp = this.dataArray[i], p = cp.points;
        switch (cp.command) {
          case "L":
            return Path.getPointOnLine(length, cp.start.x, cp.start.y, p[0], p[1]);
          case "C":
            return Path.getPointOnCubicBezier(length / cp.pathLength, cp.start.x, cp.start.y, p[0], p[1], p[2], p[3], p[4], p[5]);
          case "Q":
            return Path.getPointOnQuadraticBezier(length / cp.pathLength, cp.start.x, cp.start.y, p[0], p[1], p[2], p[3]);
          case "A":
            var cx = p[0], cy = p[1], rx = p[2], ry = p[3], theta = p[4], dTheta = p[5], psi = p[6];
            return theta += dTheta * length / cp.pathLength, Path.getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi);
        }
        return null;
      }
      static getLineLength(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      }
      static getPointOnLine(dist, P1x, P1y, P2x, P2y, fromX, fromY) {
        fromX === void 0 && (fromX = P1x), fromY === void 0 && (fromY = P1y);
        var m = (P2y - P1y) / (P2x - P1x + 1e-8), run = Math.sqrt(dist * dist / (1 + m * m));
        P2x < P1x && (run *= -1);
        var rise = m * run, pt;
        if (P2x === P1x)
          pt = {
            x: fromX,
            y: fromY + rise
          };
        else if ((fromY - P1y) / (fromX - P1x + 1e-8) === m)
          pt = {
            x: fromX + run,
            y: fromY + rise
          };
        else {
          var ix, iy, len = this.getLineLength(P1x, P1y, P2x, P2y), u = (fromX - P1x) * (P2x - P1x) + (fromY - P1y) * (P2y - P1y);
          u = u / (len * len), ix = P1x + u * (P2x - P1x), iy = P1y + u * (P2y - P1y);
          var pRise = this.getLineLength(fromX, fromY, ix, iy), pRun = Math.sqrt(dist * dist - pRise * pRise);
          run = Math.sqrt(pRun * pRun / (1 + m * m)), P2x < P1x && (run *= -1), rise = m * run, pt = {
            x: ix + run,
            y: iy + rise
          };
        }
        return pt;
      }
      static getPointOnCubicBezier(pct, P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y) {
        function CB1(t) {
          return t * t * t;
        }
        function CB2(t) {
          return 3 * t * t * (1 - t);
        }
        function CB3(t) {
          return 3 * t * (1 - t) * (1 - t);
        }
        function CB4(t) {
          return (1 - t) * (1 - t) * (1 - t);
        }
        var x = P4x * CB1(pct) + P3x * CB2(pct) + P2x * CB3(pct) + P1x * CB4(pct), y = P4y * CB1(pct) + P3y * CB2(pct) + P2y * CB3(pct) + P1y * CB4(pct);
        return {
          x,
          y
        };
      }
      static getPointOnQuadraticBezier(pct, P1x, P1y, P2x, P2y, P3x, P3y) {
        function QB1(t) {
          return t * t;
        }
        function QB2(t) {
          return 2 * t * (1 - t);
        }
        function QB3(t) {
          return (1 - t) * (1 - t);
        }
        var x = P3x * QB1(pct) + P2x * QB2(pct) + P1x * QB3(pct), y = P3y * QB1(pct) + P2y * QB2(pct) + P1y * QB3(pct);
        return {
          x,
          y
        };
      }
      static getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {
        var cosPsi = Math.cos(psi), sinPsi = Math.sin(psi), pt = {
          x: rx * Math.cos(theta),
          y: ry * Math.sin(theta)
        };
        return {
          x: cx + (pt.x * cosPsi - pt.y * sinPsi),
          y: cy + (pt.x * sinPsi + pt.y * cosPsi)
        };
      }
      static parsePathData(data) {
        if (!data)
          return [];
        var cs = data, cc = [
          "m",
          "M",
          "l",
          "L",
          "v",
          "V",
          "h",
          "H",
          "z",
          "Z",
          "c",
          "C",
          "q",
          "Q",
          "t",
          "T",
          "s",
          "S",
          "a",
          "A"
        ];
        cs = cs.replace(new RegExp(" ", "g"), ",");
        for (var n = 0; n < cc.length; n++)
          cs = cs.replace(new RegExp(cc[n], "g"), "|" + cc[n]);
        var arr = cs.split("|"), ca = [], coords = [], cpx = 0, cpy = 0, re = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi, match;
        for (n = 1; n < arr.length; n++) {
          var str = arr[n], c = str.charAt(0);
          for (str = str.slice(1), coords.length = 0; match = re.exec(str); )
            coords.push(match[0]);
          for (var p = [], j = 0, jlen = coords.length; j < jlen; j++) {
            if (coords[j] === "00") {
              p.push(0, 0);
              continue;
            }
            var parsed = parseFloat(coords[j]);
            isNaN(parsed) ? p.push(0) : p.push(parsed);
          }
          for (; p.length > 0 && !isNaN(p[0]); ) {
            var cmd = null, points = [], startX = cpx, startY = cpy, prevCmd, ctlPtx, ctlPty, rx, ry, psi, fa, fs, x1, y1;
            switch (c) {
              case "l":
                cpx += p.shift(), cpy += p.shift(), cmd = "L", points.push(cpx, cpy);
                break;
              case "L":
                cpx = p.shift(), cpy = p.shift(), points.push(cpx, cpy);
                break;
              case "m":
                var dx = p.shift(), dy = p.shift();
                if (cpx += dx, cpy += dy, cmd = "M", ca.length > 2 && ca[ca.length - 1].command === "z") {
                  for (var idx = ca.length - 2; idx >= 0; idx--)
                    if (ca[idx].command === "M") {
                      cpx = ca[idx].points[0] + dx, cpy = ca[idx].points[1] + dy;
                      break;
                    }
                }
                points.push(cpx, cpy), c = "l";
                break;
              case "M":
                cpx = p.shift(), cpy = p.shift(), cmd = "M", points.push(cpx, cpy), c = "L";
                break;
              case "h":
                cpx += p.shift(), cmd = "L", points.push(cpx, cpy);
                break;
              case "H":
                cpx = p.shift(), cmd = "L", points.push(cpx, cpy);
                break;
              case "v":
                cpy += p.shift(), cmd = "L", points.push(cpx, cpy);
                break;
              case "V":
                cpy = p.shift(), cmd = "L", points.push(cpx, cpy);
                break;
              case "C":
                points.push(p.shift(), p.shift(), p.shift(), p.shift()), cpx = p.shift(), cpy = p.shift(), points.push(cpx, cpy);
                break;
              case "c":
                points.push(cpx + p.shift(), cpy + p.shift(), cpx + p.shift(), cpy + p.shift()), cpx += p.shift(), cpy += p.shift(), cmd = "C", points.push(cpx, cpy);
                break;
              case "S":
                ctlPtx = cpx, ctlPty = cpy, prevCmd = ca[ca.length - 1], prevCmd.command === "C" && (ctlPtx = cpx + (cpx - prevCmd.points[2]), ctlPty = cpy + (cpy - prevCmd.points[3])), points.push(ctlPtx, ctlPty, p.shift(), p.shift()), cpx = p.shift(), cpy = p.shift(), cmd = "C", points.push(cpx, cpy);
                break;
              case "s":
                ctlPtx = cpx, ctlPty = cpy, prevCmd = ca[ca.length - 1], prevCmd.command === "C" && (ctlPtx = cpx + (cpx - prevCmd.points[2]), ctlPty = cpy + (cpy - prevCmd.points[3])), points.push(ctlPtx, ctlPty, cpx + p.shift(), cpy + p.shift()), cpx += p.shift(), cpy += p.shift(), cmd = "C", points.push(cpx, cpy);
                break;
              case "Q":
                points.push(p.shift(), p.shift()), cpx = p.shift(), cpy = p.shift(), points.push(cpx, cpy);
                break;
              case "q":
                points.push(cpx + p.shift(), cpy + p.shift()), cpx += p.shift(), cpy += p.shift(), cmd = "Q", points.push(cpx, cpy);
                break;
              case "T":
                ctlPtx = cpx, ctlPty = cpy, prevCmd = ca[ca.length - 1], prevCmd.command === "Q" && (ctlPtx = cpx + (cpx - prevCmd.points[0]), ctlPty = cpy + (cpy - prevCmd.points[1])), cpx = p.shift(), cpy = p.shift(), cmd = "Q", points.push(ctlPtx, ctlPty, cpx, cpy);
                break;
              case "t":
                ctlPtx = cpx, ctlPty = cpy, prevCmd = ca[ca.length - 1], prevCmd.command === "Q" && (ctlPtx = cpx + (cpx - prevCmd.points[0]), ctlPty = cpy + (cpy - prevCmd.points[1])), cpx += p.shift(), cpy += p.shift(), cmd = "Q", points.push(ctlPtx, ctlPty, cpx, cpy);
                break;
              case "A":
                rx = p.shift(), ry = p.shift(), psi = p.shift(), fa = p.shift(), fs = p.shift(), x1 = cpx, y1 = cpy, cpx = p.shift(), cpy = p.shift(), cmd = "A", points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
                break;
              case "a":
                rx = p.shift(), ry = p.shift(), psi = p.shift(), fa = p.shift(), fs = p.shift(), x1 = cpx, y1 = cpy, cpx += p.shift(), cpy += p.shift(), cmd = "A", points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
                break;
            }
            ca.push({
              command: cmd || c,
              points,
              start: {
                x: startX,
                y: startY
              },
              pathLength: this.calcLength(startX, startY, cmd || c, points)
            });
          }
          (c === "z" || c === "Z") && ca.push({
            command: "z",
            points: [],
            start: void 0,
            pathLength: 0
          });
        }
        return ca;
      }
      static calcLength(x, y, cmd, points) {
        var len, p1, p2, t, path = Path;
        switch (cmd) {
          case "L":
            return path.getLineLength(x, y, points[0], points[1]);
          case "C":
            for (len = 0, p1 = path.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]), t = 0.01; t <= 1; t += 0.01)
              p2 = path.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]), len += path.getLineLength(p1.x, p1.y, p2.x, p2.y), p1 = p2;
            return len;
          case "Q":
            for (len = 0, p1 = path.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]), t = 0.01; t <= 1; t += 0.01)
              p2 = path.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]), len += path.getLineLength(p1.x, p1.y, p2.x, p2.y), p1 = p2;
            return len;
          case "A":
            len = 0;
            var start = points[4], dTheta = points[5], end = points[4] + dTheta, inc = Math.PI / 180;
            if (Math.abs(start - end) < inc && (inc = Math.abs(start - end)), p1 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0), dTheta < 0)
              for (t = start - inc; t > end; t -= inc)
                p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0), len += path.getLineLength(p1.x, p1.y, p2.x, p2.y), p1 = p2;
            else
              for (t = start + inc; t < end; t += inc)
                p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0), len += path.getLineLength(p1.x, p1.y, p2.x, p2.y), p1 = p2;
            return p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0), len += path.getLineLength(p1.x, p1.y, p2.x, p2.y), len;
        }
        return 0;
      }
      static convertEndpointToCenterParameterization(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg) {
        var psi = psiDeg * (Math.PI / 180), xp = Math.cos(psi) * (x1 - x2) / 2 + Math.sin(psi) * (y1 - y2) / 2, yp = -1 * Math.sin(psi) * (x1 - x2) / 2 + Math.cos(psi) * (y1 - y2) / 2, lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
        lambda > 1 && (rx *= Math.sqrt(lambda), ry *= Math.sqrt(lambda));
        var f = Math.sqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp)));
        fa === fs && (f *= -1), isNaN(f) && (f = 0);
        var cxp = f * rx * yp / ry, cyp = f * -ry * xp / rx, cx = (x1 + x2) / 2 + Math.cos(psi) * cxp - Math.sin(psi) * cyp, cy = (y1 + y2) / 2 + Math.sin(psi) * cxp + Math.cos(psi) * cyp, vMag = function(v2) {
          return Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
        }, vRatio = function(u2, v2) {
          return (u2[0] * v2[0] + u2[1] * v2[1]) / (vMag(u2) * vMag(v2));
        }, vAngle = function(u2, v2) {
          return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vRatio(u2, v2));
        }, theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]), u = [(xp - cxp) / rx, (yp - cyp) / ry], v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry], dTheta = vAngle(u, v);
        return vRatio(u, v) <= -1 && (dTheta = Math.PI), vRatio(u, v) >= 1 && (dTheta = 0), fs === 0 && dTheta > 0 && (dTheta = dTheta - 2 * Math.PI), fs === 1 && dTheta < 0 && (dTheta = dTheta + 2 * Math.PI), [cx, cy, rx, ry, theta, dTheta, psi, fs];
      }
    };
    exports.Path = Path;
    Path.prototype.className = "Path";
    Path.prototype._attrsAffectingSize = ["data"];
    (0, Global_1._registerNode)(Path);
    Factory_1.Factory.addGetterSetter(Path, "data");
  }
});

// node_modules/konva/cmj/shapes/Arrow.js
var require_Arrow = __commonJS({
  "node_modules/konva/cmj/shapes/Arrow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Arrow = void 0;
    var Factory_1 = require_Factory(), Line_1 = require_Line2(), Validators_1 = require_Validators(), Global_1 = require_Global2(), Path_1 = require_Path(), Arrow = class extends Line_1.Line {
      _sceneFunc(ctx) {
        super._sceneFunc(ctx);
        var PI2 = Math.PI * 2, points = this.points(), tp = points, fromTension = this.tension() !== 0 && points.length > 4;
        fromTension && (tp = this.getTensionPoints());
        var length = this.pointerLength(), n = points.length, dx, dy;
        if (fromTension) {
          let lp = [
            tp[tp.length - 4],
            tp[tp.length - 3],
            tp[tp.length - 2],
            tp[tp.length - 1],
            points[n - 2],
            points[n - 1]
          ], lastLength = Path_1.Path.calcLength(tp[tp.length - 4], tp[tp.length - 3], "C", lp), previous = Path_1.Path.getPointOnQuadraticBezier(Math.min(1, 1 - length / lastLength), lp[0], lp[1], lp[2], lp[3], lp[4], lp[5]);
          dx = points[n - 2] - previous.x, dy = points[n - 1] - previous.y;
        } else
          dx = points[n - 2] - points[n - 4], dy = points[n - 1] - points[n - 3];
        var radians = (Math.atan2(dy, dx) + PI2) % PI2, width = this.pointerWidth();
        this.pointerAtEnding() && (ctx.save(), ctx.beginPath(), ctx.translate(points[n - 2], points[n - 1]), ctx.rotate(radians), ctx.moveTo(0, 0), ctx.lineTo(-length, width / 2), ctx.lineTo(-length, -width / 2), ctx.closePath(), ctx.restore(), this.__fillStroke(ctx)), this.pointerAtBeginning() && (ctx.save(), ctx.beginPath(), ctx.translate(points[0], points[1]), fromTension ? (dx = (tp[0] + tp[2]) / 2 - points[0], dy = (tp[1] + tp[3]) / 2 - points[1]) : (dx = points[2] - points[0], dy = points[3] - points[1]), ctx.rotate((Math.atan2(-dy, -dx) + PI2) % PI2), ctx.moveTo(0, 0), ctx.lineTo(-length, width / 2), ctx.lineTo(-length, -width / 2), ctx.closePath(), ctx.restore(), this.__fillStroke(ctx));
      }
      __fillStroke(ctx) {
        var isDashEnabled = this.dashEnabled();
        isDashEnabled && (this.attrs.dashEnabled = !1, ctx.setLineDash([])), ctx.fillStrokeShape(this), isDashEnabled && (this.attrs.dashEnabled = !0);
      }
      getSelfRect() {
        let lineRect = super.getSelfRect(), offset = this.pointerWidth() / 2;
        return {
          x: lineRect.x - offset,
          y: lineRect.y - offset,
          width: lineRect.width + offset * 2,
          height: lineRect.height + offset * 2
        };
      }
    };
    exports.Arrow = Arrow;
    Arrow.prototype.className = "Arrow";
    (0, Global_1._registerNode)(Arrow);
    Factory_1.Factory.addGetterSetter(Arrow, "pointerLength", 10, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Arrow, "pointerWidth", 10, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Arrow, "pointerAtBeginning", !1);
    Factory_1.Factory.addGetterSetter(Arrow, "pointerAtEnding", !0);
  }
});

// node_modules/konva/cmj/shapes/Circle.js
var require_Circle = __commonJS({
  "node_modules/konva/cmj/shapes/Circle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Circle = void 0;
    var Factory_1 = require_Factory(), Shape_1 = require_Shape(), Validators_1 = require_Validators(), Global_1 = require_Global2(), Circle = class extends Shape_1.Shape {
      _sceneFunc(context) {
        context.beginPath(), context.arc(0, 0, this.attrs.radius || 0, 0, Math.PI * 2, !1), context.closePath(), context.fillStrokeShape(this);
      }
      getWidth() {
        return this.radius() * 2;
      }
      getHeight() {
        return this.radius() * 2;
      }
      setWidth(width) {
        this.radius() !== width / 2 && this.radius(width / 2);
      }
      setHeight(height) {
        this.radius() !== height / 2 && this.radius(height / 2);
      }
    };
    exports.Circle = Circle;
    Circle.prototype._centroid = !0;
    Circle.prototype.className = "Circle";
    Circle.prototype._attrsAffectingSize = ["radius"];
    (0, Global_1._registerNode)(Circle);
    Factory_1.Factory.addGetterSetter(Circle, "radius", 0, (0, Validators_1.getNumberValidator)());
  }
});

// node_modules/konva/cmj/shapes/Ellipse.js
var require_Ellipse = __commonJS({
  "node_modules/konva/cmj/shapes/Ellipse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Ellipse = void 0;
    var Factory_1 = require_Factory(), Shape_1 = require_Shape(), Validators_1 = require_Validators(), Global_1 = require_Global2(), Ellipse = class extends Shape_1.Shape {
      _sceneFunc(context) {
        var rx = this.radiusX(), ry = this.radiusY();
        context.beginPath(), context.save(), rx !== ry && context.scale(1, ry / rx), context.arc(0, 0, rx, 0, Math.PI * 2, !1), context.restore(), context.closePath(), context.fillStrokeShape(this);
      }
      getWidth() {
        return this.radiusX() * 2;
      }
      getHeight() {
        return this.radiusY() * 2;
      }
      setWidth(width) {
        this.radiusX(width / 2);
      }
      setHeight(height) {
        this.radiusY(height / 2);
      }
    };
    exports.Ellipse = Ellipse;
    Ellipse.prototype.className = "Ellipse";
    Ellipse.prototype._centroid = !0;
    Ellipse.prototype._attrsAffectingSize = ["radiusX", "radiusY"];
    (0, Global_1._registerNode)(Ellipse);
    Factory_1.Factory.addComponentsGetterSetter(Ellipse, "radius", ["x", "y"]);
    Factory_1.Factory.addGetterSetter(Ellipse, "radiusX", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Ellipse, "radiusY", 0, (0, Validators_1.getNumberValidator)());
  }
});

// node_modules/konva/cmj/shapes/Image.js
var require_Image = __commonJS({
  "node_modules/konva/cmj/shapes/Image.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Image = void 0;
    var Util_1 = require_Util(), Factory_1 = require_Factory(), Shape_1 = require_Shape(), Validators_1 = require_Validators(), Global_1 = require_Global2(), Image3 = class extends Shape_1.Shape {
      constructor(attrs) {
        super(attrs), this.on("imageChange.konva", () => {
          this._setImageLoad();
        }), this._setImageLoad();
      }
      _setImageLoad() {
        let image = this.image();
        image && image.complete || image && image.readyState === 4 || image && image.addEventListener && image.addEventListener("load", () => {
          this._requestDraw();
        });
      }
      _useBufferCanvas() {
        return super._useBufferCanvas(!0);
      }
      _sceneFunc(context) {
        let width = this.getWidth(), height = this.getHeight(), image = this.attrs.image, params;
        if (image) {
          let cropWidth = this.attrs.cropWidth, cropHeight = this.attrs.cropHeight;
          cropWidth && cropHeight ? params = [
            image,
            this.cropX(),
            this.cropY(),
            cropWidth,
            cropHeight,
            0,
            0,
            width,
            height
          ] : params = [image, 0, 0, width, height];
        }
        (this.hasFill() || this.hasStroke()) && (context.beginPath(), context.rect(0, 0, width, height), context.closePath(), context.fillStrokeShape(this)), image && context.drawImage.apply(context, params);
      }
      _hitFunc(context) {
        var width = this.width(), height = this.height();
        context.beginPath(), context.rect(0, 0, width, height), context.closePath(), context.fillStrokeShape(this);
      }
      getWidth() {
        var _a, _b;
        return (_a = this.attrs.width) !== null && _a !== void 0 ? _a : (_b = this.image()) === null || _b === void 0 ? void 0 : _b.width;
      }
      getHeight() {
        var _a, _b;
        return (_a = this.attrs.height) !== null && _a !== void 0 ? _a : (_b = this.image()) === null || _b === void 0 ? void 0 : _b.height;
      }
      static fromURL(url, callback, onError = null) {
        var img = Util_1.Util.createImageElement();
        img.onload = function() {
          var image = new Image3({
            image: img
          });
          callback(image);
        }, img.onerror = onError, img.crossOrigin = "Anonymous", img.src = url;
      }
    };
    exports.Image = Image3;
    Image3.prototype.className = "Image";
    (0, Global_1._registerNode)(Image3);
    Factory_1.Factory.addGetterSetter(Image3, "image");
    Factory_1.Factory.addComponentsGetterSetter(Image3, "crop", ["x", "y", "width", "height"]);
    Factory_1.Factory.addGetterSetter(Image3, "cropX", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Image3, "cropY", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Image3, "cropWidth", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Image3, "cropHeight", 0, (0, Validators_1.getNumberValidator)());
  }
});

// node_modules/konva/cmj/shapes/Label.js
var require_Label2 = __commonJS({
  "node_modules/konva/cmj/shapes/Label.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Tag = exports.Label = void 0;
    var Factory_1 = require_Factory(), Shape_1 = require_Shape(), Group_1 = require_Group(), Validators_1 = require_Validators(), Global_1 = require_Global2(), ATTR_CHANGE_LIST = [
      "fontFamily",
      "fontSize",
      "fontStyle",
      "padding",
      "lineHeight",
      "text",
      "width",
      "height",
      "pointerDirection",
      "pointerWidth",
      "pointerHeight"
    ], CHANGE_KONVA = "Change.konva", NONE = "none", UP = "up", RIGHT = "right", DOWN = "down", LEFT = "left", attrChangeListLen = ATTR_CHANGE_LIST.length, Label2 = class extends Group_1.Group {
      constructor(config) {
        super(config), this.on("add.konva", function(evt) {
          this._addListeners(evt.child), this._sync();
        });
      }
      getText() {
        return this.find("Text")[0];
      }
      getTag() {
        return this.find("Tag")[0];
      }
      _addListeners(text) {
        var that = this, n, func = function() {
          that._sync();
        };
        for (n = 0; n < attrChangeListLen; n++)
          text.on(ATTR_CHANGE_LIST[n] + CHANGE_KONVA, func);
      }
      getWidth() {
        return this.getText().width();
      }
      getHeight() {
        return this.getText().height();
      }
      _sync() {
        var text = this.getText(), tag = this.getTag(), width, height, pointerDirection, pointerWidth, x, y, pointerHeight;
        if (text && tag) {
          switch (width = text.width(), height = text.height(), pointerDirection = tag.pointerDirection(), pointerWidth = tag.pointerWidth(), pointerHeight = tag.pointerHeight(), x = 0, y = 0, pointerDirection) {
            case UP:
              x = width / 2, y = -1 * pointerHeight;
              break;
            case RIGHT:
              x = width + pointerWidth, y = height / 2;
              break;
            case DOWN:
              x = width / 2, y = height + pointerHeight;
              break;
            case LEFT:
              x = -1 * pointerWidth, y = height / 2;
              break;
          }
          tag.setAttrs({
            x: -1 * x,
            y: -1 * y,
            width,
            height
          }), text.setAttrs({
            x: -1 * x,
            y: -1 * y
          });
        }
      }
    };
    exports.Label = Label2;
    Label2.prototype.className = "Label";
    (0, Global_1._registerNode)(Label2);
    var Tag2 = class extends Shape_1.Shape {
      _sceneFunc(context) {
        var width = this.width(), height = this.height(), pointerDirection = this.pointerDirection(), pointerWidth = this.pointerWidth(), pointerHeight = this.pointerHeight(), cornerRadius = this.cornerRadius();
        let topLeft = 0, topRight = 0, bottomLeft = 0, bottomRight = 0;
        typeof cornerRadius == "number" ? topLeft = topRight = bottomLeft = bottomRight = Math.min(cornerRadius, width / 2, height / 2) : (topLeft = Math.min(cornerRadius[0] || 0, width / 2, height / 2), topRight = Math.min(cornerRadius[1] || 0, width / 2, height / 2), bottomRight = Math.min(cornerRadius[2] || 0, width / 2, height / 2), bottomLeft = Math.min(cornerRadius[3] || 0, width / 2, height / 2)), context.beginPath(), context.moveTo(topLeft, 0), pointerDirection === UP && (context.lineTo((width - pointerWidth) / 2, 0), context.lineTo(width / 2, -1 * pointerHeight), context.lineTo((width + pointerWidth) / 2, 0)), context.lineTo(width - topRight, 0), context.arc(width - topRight, topRight, topRight, Math.PI * 3 / 2, 0, !1), pointerDirection === RIGHT && (context.lineTo(width, (height - pointerHeight) / 2), context.lineTo(width + pointerWidth, height / 2), context.lineTo(width, (height + pointerHeight) / 2)), context.lineTo(width, height - bottomRight), context.arc(width - bottomRight, height - bottomRight, bottomRight, 0, Math.PI / 2, !1), pointerDirection === DOWN && (context.lineTo((width + pointerWidth) / 2, height), context.lineTo(width / 2, height + pointerHeight), context.lineTo((width - pointerWidth) / 2, height)), context.lineTo(bottomLeft, height), context.arc(bottomLeft, height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, !1), pointerDirection === LEFT && (context.lineTo(0, (height + pointerHeight) / 2), context.lineTo(-1 * pointerWidth, height / 2), context.lineTo(0, (height - pointerHeight) / 2)), context.lineTo(0, topLeft), context.arc(topLeft, topLeft, topLeft, Math.PI, Math.PI * 3 / 2, !1), context.closePath(), context.fillStrokeShape(this);
      }
      getSelfRect() {
        var x = 0, y = 0, pointerWidth = this.pointerWidth(), pointerHeight = this.pointerHeight(), direction = this.pointerDirection(), width = this.width(), height = this.height();
        return direction === UP ? (y -= pointerHeight, height += pointerHeight) : direction === DOWN ? height += pointerHeight : direction === LEFT ? (x -= pointerWidth * 1.5, width += pointerWidth) : direction === RIGHT && (width += pointerWidth * 1.5), {
          x,
          y,
          width,
          height
        };
      }
    };
    exports.Tag = Tag2;
    Tag2.prototype.className = "Tag";
    (0, Global_1._registerNode)(Tag2);
    Factory_1.Factory.addGetterSetter(Tag2, "pointerDirection", NONE);
    Factory_1.Factory.addGetterSetter(Tag2, "pointerWidth", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Tag2, "pointerHeight", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Tag2, "cornerRadius", 0, (0, Validators_1.getNumberOrArrayOfNumbersValidator)(4));
  }
});

// node_modules/konva/cmj/shapes/Rect.js
var require_Rect = __commonJS({
  "node_modules/konva/cmj/shapes/Rect.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Rect = void 0;
    var Factory_1 = require_Factory(), Shape_1 = require_Shape(), Global_1 = require_Global2(), Validators_1 = require_Validators(), Rect2 = class extends Shape_1.Shape {
      _sceneFunc(context) {
        var cornerRadius = this.cornerRadius(), width = this.width(), height = this.height();
        if (context.beginPath(), !cornerRadius)
          context.rect(0, 0, width, height);
        else {
          let topLeft = 0, topRight = 0, bottomLeft = 0, bottomRight = 0;
          typeof cornerRadius == "number" ? topLeft = topRight = bottomLeft = bottomRight = Math.min(cornerRadius, width / 2, height / 2) : (topLeft = Math.min(cornerRadius[0] || 0, width / 2, height / 2), topRight = Math.min(cornerRadius[1] || 0, width / 2, height / 2), bottomRight = Math.min(cornerRadius[2] || 0, width / 2, height / 2), bottomLeft = Math.min(cornerRadius[3] || 0, width / 2, height / 2)), context.moveTo(topLeft, 0), context.lineTo(width - topRight, 0), context.arc(width - topRight, topRight, topRight, Math.PI * 3 / 2, 0, !1), context.lineTo(width, height - bottomRight), context.arc(width - bottomRight, height - bottomRight, bottomRight, 0, Math.PI / 2, !1), context.lineTo(bottomLeft, height), context.arc(bottomLeft, height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, !1), context.lineTo(0, topLeft), context.arc(topLeft, topLeft, topLeft, Math.PI, Math.PI * 3 / 2, !1);
        }
        context.closePath(), context.fillStrokeShape(this);
      }
    };
    exports.Rect = Rect2;
    Rect2.prototype.className = "Rect";
    (0, Global_1._registerNode)(Rect2);
    Factory_1.Factory.addGetterSetter(Rect2, "cornerRadius", 0, (0, Validators_1.getNumberOrArrayOfNumbersValidator)(4));
  }
});

// node_modules/konva/cmj/shapes/RegularPolygon.js
var require_RegularPolygon = __commonJS({
  "node_modules/konva/cmj/shapes/RegularPolygon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.RegularPolygon = void 0;
    var Factory_1 = require_Factory(), Shape_1 = require_Shape(), Validators_1 = require_Validators(), Global_1 = require_Global2(), RegularPolygon = class extends Shape_1.Shape {
      _sceneFunc(context) {
        let points = this._getPoints();
        context.beginPath(), context.moveTo(points[0].x, points[0].y);
        for (var n = 1; n < points.length; n++)
          context.lineTo(points[n].x, points[n].y);
        context.closePath(), context.fillStrokeShape(this);
      }
      _getPoints() {
        let sides = this.attrs.sides, radius = this.attrs.radius || 0, points = [];
        for (var n = 0; n < sides; n++)
          points.push({
            x: radius * Math.sin(n * 2 * Math.PI / sides),
            y: -1 * radius * Math.cos(n * 2 * Math.PI / sides)
          });
        return points;
      }
      getSelfRect() {
        let points = this._getPoints();
        var minX = points[0].x, maxX = points[0].y, minY = points[0].x, maxY = points[0].y;
        return points.forEach((point) => {
          minX = Math.min(minX, point.x), maxX = Math.max(maxX, point.x), minY = Math.min(minY, point.y), maxY = Math.max(maxY, point.y);
        }), {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
      }
      getWidth() {
        return this.radius() * 2;
      }
      getHeight() {
        return this.radius() * 2;
      }
      setWidth(width) {
        this.radius(width / 2);
      }
      setHeight(height) {
        this.radius(height / 2);
      }
    };
    exports.RegularPolygon = RegularPolygon;
    RegularPolygon.prototype.className = "RegularPolygon";
    RegularPolygon.prototype._centroid = !0;
    RegularPolygon.prototype._attrsAffectingSize = ["radius"];
    (0, Global_1._registerNode)(RegularPolygon);
    Factory_1.Factory.addGetterSetter(RegularPolygon, "radius", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(RegularPolygon, "sides", 0, (0, Validators_1.getNumberValidator)());
  }
});

// node_modules/konva/cmj/shapes/Ring.js
var require_Ring = __commonJS({
  "node_modules/konva/cmj/shapes/Ring.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Ring = void 0;
    var Factory_1 = require_Factory(), Shape_1 = require_Shape(), Validators_1 = require_Validators(), Global_1 = require_Global2(), PIx2 = Math.PI * 2, Ring = class extends Shape_1.Shape {
      _sceneFunc(context) {
        context.beginPath(), context.arc(0, 0, this.innerRadius(), 0, PIx2, !1), context.moveTo(this.outerRadius(), 0), context.arc(0, 0, this.outerRadius(), PIx2, 0, !0), context.closePath(), context.fillStrokeShape(this);
      }
      getWidth() {
        return this.outerRadius() * 2;
      }
      getHeight() {
        return this.outerRadius() * 2;
      }
      setWidth(width) {
        this.outerRadius(width / 2);
      }
      setHeight(height) {
        this.outerRadius(height / 2);
      }
    };
    exports.Ring = Ring;
    Ring.prototype.className = "Ring";
    Ring.prototype._centroid = !0;
    Ring.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
    (0, Global_1._registerNode)(Ring);
    Factory_1.Factory.addGetterSetter(Ring, "innerRadius", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Ring, "outerRadius", 0, (0, Validators_1.getNumberValidator)());
  }
});

// node_modules/konva/cmj/shapes/Sprite.js
var require_Sprite = __commonJS({
  "node_modules/konva/cmj/shapes/Sprite.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Sprite = void 0;
    var Factory_1 = require_Factory(), Shape_1 = require_Shape(), Animation_1 = require_Animation(), Validators_1 = require_Validators(), Global_1 = require_Global2(), Sprite = class extends Shape_1.Shape {
      constructor(config) {
        super(config), this._updated = !0, this.anim = new Animation_1.Animation(() => {
          var updated = this._updated;
          return this._updated = !1, updated;
        }), this.on("animationChange.konva", function() {
          this.frameIndex(0);
        }), this.on("frameIndexChange.konva", function() {
          this._updated = !0;
        }), this.on("frameRateChange.konva", function() {
          !this.anim.isRunning() || (clearInterval(this.interval), this._setInterval());
        });
      }
      _sceneFunc(context) {
        var anim = this.animation(), index = this.frameIndex(), ix4 = index * 4, set = this.animations()[anim], offsets = this.frameOffsets(), x = set[ix4 + 0], y = set[ix4 + 1], width = set[ix4 + 2], height = set[ix4 + 3], image = this.image();
        if ((this.hasFill() || this.hasStroke()) && (context.beginPath(), context.rect(0, 0, width, height), context.closePath(), context.fillStrokeShape(this)), image)
          if (offsets) {
            var offset = offsets[anim], ix2 = index * 2;
            context.drawImage(image, x, y, width, height, offset[ix2 + 0], offset[ix2 + 1], width, height);
          } else
            context.drawImage(image, x, y, width, height, 0, 0, width, height);
      }
      _hitFunc(context) {
        var anim = this.animation(), index = this.frameIndex(), ix4 = index * 4, set = this.animations()[anim], offsets = this.frameOffsets(), width = set[ix4 + 2], height = set[ix4 + 3];
        if (context.beginPath(), offsets) {
          var offset = offsets[anim], ix2 = index * 2;
          context.rect(offset[ix2 + 0], offset[ix2 + 1], width, height);
        } else
          context.rect(0, 0, width, height);
        context.closePath(), context.fillShape(this);
      }
      _useBufferCanvas() {
        return super._useBufferCanvas(!0);
      }
      _setInterval() {
        var that = this;
        this.interval = setInterval(function() {
          that._updateIndex();
        }, 1e3 / this.frameRate());
      }
      start() {
        if (!this.isRunning()) {
          var layer = this.getLayer();
          this.anim.setLayers(layer), this._setInterval(), this.anim.start();
        }
      }
      stop() {
        this.anim.stop(), clearInterval(this.interval);
      }
      isRunning() {
        return this.anim.isRunning();
      }
      _updateIndex() {
        var index = this.frameIndex(), animation = this.animation(), animations = this.animations(), anim = animations[animation], len = anim.length / 4;
        index < len - 1 ? this.frameIndex(index + 1) : this.frameIndex(0);
      }
    };
    exports.Sprite = Sprite;
    Sprite.prototype.className = "Sprite";
    (0, Global_1._registerNode)(Sprite);
    Factory_1.Factory.addGetterSetter(Sprite, "animation");
    Factory_1.Factory.addGetterSetter(Sprite, "animations");
    Factory_1.Factory.addGetterSetter(Sprite, "frameOffsets");
    Factory_1.Factory.addGetterSetter(Sprite, "image");
    Factory_1.Factory.addGetterSetter(Sprite, "frameIndex", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Sprite, "frameRate", 17, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.backCompat(Sprite, {
      index: "frameIndex",
      getIndex: "getFrameIndex",
      setIndex: "setFrameIndex"
    });
  }
});

// node_modules/konva/cmj/shapes/Star.js
var require_Star = __commonJS({
  "node_modules/konva/cmj/shapes/Star.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Star = void 0;
    var Factory_1 = require_Factory(), Shape_1 = require_Shape(), Validators_1 = require_Validators(), Global_1 = require_Global2(), Star = class extends Shape_1.Shape {
      _sceneFunc(context) {
        var innerRadius = this.innerRadius(), outerRadius = this.outerRadius(), numPoints = this.numPoints();
        context.beginPath(), context.moveTo(0, 0 - outerRadius);
        for (var n = 1; n < numPoints * 2; n++) {
          var radius = n % 2 === 0 ? outerRadius : innerRadius, x = radius * Math.sin(n * Math.PI / numPoints), y = -1 * radius * Math.cos(n * Math.PI / numPoints);
          context.lineTo(x, y);
        }
        context.closePath(), context.fillStrokeShape(this);
      }
      getWidth() {
        return this.outerRadius() * 2;
      }
      getHeight() {
        return this.outerRadius() * 2;
      }
      setWidth(width) {
        this.outerRadius(width / 2);
      }
      setHeight(height) {
        this.outerRadius(height / 2);
      }
    };
    exports.Star = Star;
    Star.prototype.className = "Star";
    Star.prototype._centroid = !0;
    Star.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"];
    (0, Global_1._registerNode)(Star);
    Factory_1.Factory.addGetterSetter(Star, "numPoints", 5, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Star, "innerRadius", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Star, "outerRadius", 0, (0, Validators_1.getNumberValidator)());
  }
});

// node_modules/konva/cmj/shapes/Text.js
var require_Text2 = __commonJS({
  "node_modules/konva/cmj/shapes/Text.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Text = exports.stringToArray = void 0;
    var Util_1 = require_Util(), Factory_1 = require_Factory(), Shape_1 = require_Shape(), Validators_1 = require_Validators(), Global_1 = require_Global2();
    function stringToArray(string) {
      return Array.from(string);
    }
    exports.stringToArray = stringToArray;
    var AUTO = "auto", CENTER = "center", JUSTIFY = "justify", CHANGE_KONVA = "Change.konva", CONTEXT_2D = "2d", DASH = "-", LEFT = "left", TEXT = "text", TEXT_UPPER = "Text", TOP = "top", BOTTOM = "bottom", MIDDLE = "middle", NORMAL = "normal", PX_SPACE = "px ", SPACE2 = " ", RIGHT = "right", WORD = "word", CHAR = "char", NONE = "none", ELLIPSIS = "\u2026", ATTR_CHANGE_LIST = [
      "fontFamily",
      "fontSize",
      "fontStyle",
      "fontVariant",
      "padding",
      "align",
      "verticalAlign",
      "lineHeight",
      "text",
      "width",
      "height",
      "wrap",
      "ellipsis",
      "letterSpacing"
    ], attrChangeListLen = ATTR_CHANGE_LIST.length;
    function normalizeFontFamily(fontFamily) {
      return fontFamily.split(",").map((family) => {
        family = family.trim();
        let hasSpace = family.indexOf(" ") >= 0, hasQuotes = family.indexOf('"') >= 0 || family.indexOf("'") >= 0;
        return hasSpace && !hasQuotes && (family = `"${family}"`), family;
      }).join(", ");
    }
    var dummyContext2;
    function getDummyContext2() {
      return dummyContext2 || (dummyContext2 = Util_1.Util.createCanvasElement().getContext(CONTEXT_2D), dummyContext2);
    }
    function _fillFunc2(context) {
      context.fillText(this._partialText, this._partialTextX, this._partialTextY);
    }
    function _strokeFunc2(context) {
      context.strokeText(this._partialText, this._partialTextX, this._partialTextY);
    }
    function checkDefaultFill(config) {
      return config = config || {}, !config.fillLinearGradientColorStops && !config.fillRadialGradientColorStops && !config.fillPatternImage && (config.fill = config.fill || "black"), config;
    }
    var Text2 = class extends Shape_1.Shape {
      constructor(config) {
        super(checkDefaultFill(config)), this._partialTextX = 0, this._partialTextY = 0;
        for (var n = 0; n < attrChangeListLen; n++)
          this.on(ATTR_CHANGE_LIST[n] + CHANGE_KONVA, this._setTextData);
        this._setTextData();
      }
      _sceneFunc(context) {
        var textArr = this.textArr, textArrLen = textArr.length;
        if (!!this.text()) {
          var padding = this.padding(), fontSize = this.fontSize(), lineHeightPx = this.lineHeight() * fontSize, verticalAlign = this.verticalAlign(), alignY = 0, align = this.align(), totalWidth = this.getWidth(), letterSpacing = this.letterSpacing(), fill = this.fill(), textDecoration = this.textDecoration(), shouldUnderline = textDecoration.indexOf("underline") !== -1, shouldLineThrough = textDecoration.indexOf("line-through") !== -1, n, translateY = 0, translateY = lineHeightPx / 2, lineTranslateX = 0, lineTranslateY = 0;
          for (context.setAttr("font", this._getContextFont()), context.setAttr("textBaseline", MIDDLE), context.setAttr("textAlign", LEFT), verticalAlign === MIDDLE ? alignY = (this.getHeight() - textArrLen * lineHeightPx - padding * 2) / 2 : verticalAlign === BOTTOM && (alignY = this.getHeight() - textArrLen * lineHeightPx - padding * 2), context.translate(padding, alignY + padding), n = 0; n < textArrLen; n++) {
            var lineTranslateX = 0, lineTranslateY = 0, obj = textArr[n], text = obj.text, width = obj.width, lastLine = obj.lastInParagraph, spacesNumber, oneWord, lineWidth;
            if (context.save(), align === RIGHT ? lineTranslateX += totalWidth - width - padding * 2 : align === CENTER && (lineTranslateX += (totalWidth - width - padding * 2) / 2), shouldUnderline && (context.save(), context.beginPath(), context.moveTo(lineTranslateX, translateY + lineTranslateY + Math.round(fontSize / 2)), spacesNumber = text.split(" ").length - 1, oneWord = spacesNumber === 0, lineWidth = align === JUSTIFY && lastLine && !oneWord ? totalWidth - padding * 2 : width, context.lineTo(lineTranslateX + Math.round(lineWidth), translateY + lineTranslateY + Math.round(fontSize / 2)), context.lineWidth = fontSize / 15, context.strokeStyle = fill, context.stroke(), context.restore()), shouldLineThrough && (context.save(), context.beginPath(), context.moveTo(lineTranslateX, translateY + lineTranslateY), spacesNumber = text.split(" ").length - 1, oneWord = spacesNumber === 0, lineWidth = align === JUSTIFY && lastLine && !oneWord ? totalWidth - padding * 2 : width, context.lineTo(lineTranslateX + Math.round(lineWidth), translateY + lineTranslateY), context.lineWidth = fontSize / 15, context.strokeStyle = fill, context.stroke(), context.restore()), letterSpacing !== 0 || align === JUSTIFY) {
              spacesNumber = text.split(" ").length - 1;
              for (var array = stringToArray(text), li = 0; li < array.length; li++) {
                var letter = array[li];
                letter === " " && !lastLine && align === JUSTIFY && (lineTranslateX += (totalWidth - padding * 2 - width) / spacesNumber), this._partialTextX = lineTranslateX, this._partialTextY = translateY + lineTranslateY, this._partialText = letter, context.fillStrokeShape(this), lineTranslateX += this.measureSize(letter).width + letterSpacing;
              }
            } else
              this._partialTextX = lineTranslateX, this._partialTextY = translateY + lineTranslateY, this._partialText = text, context.fillStrokeShape(this);
            context.restore(), textArrLen > 1 && (translateY += lineHeightPx);
          }
        }
      }
      _hitFunc(context) {
        var width = this.getWidth(), height = this.getHeight();
        context.beginPath(), context.rect(0, 0, width, height), context.closePath(), context.fillStrokeShape(this);
      }
      setText(text) {
        var str = Util_1.Util._isString(text) ? text : text == null ? "" : text + "";
        return this._setAttr(TEXT, str), this;
      }
      getWidth() {
        var isAuto = this.attrs.width === AUTO || this.attrs.width === void 0;
        return isAuto ? this.getTextWidth() + this.padding() * 2 : this.attrs.width;
      }
      getHeight() {
        var isAuto = this.attrs.height === AUTO || this.attrs.height === void 0;
        return isAuto ? this.fontSize() * this.textArr.length * this.lineHeight() + this.padding() * 2 : this.attrs.height;
      }
      getTextWidth() {
        return this.textWidth;
      }
      getTextHeight() {
        return Util_1.Util.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."), this.textHeight;
      }
      measureSize(text) {
        var _context = getDummyContext2(), fontSize = this.fontSize(), metrics;
        return _context.save(), _context.font = this._getContextFont(), metrics = _context.measureText(text), _context.restore(), {
          width: metrics.width,
          height: fontSize
        };
      }
      _getContextFont() {
        return this.fontStyle() + SPACE2 + this.fontVariant() + SPACE2 + (this.fontSize() + PX_SPACE) + normalizeFontFamily(this.fontFamily());
      }
      _addTextLine(line) {
        this.align() === JUSTIFY && (line = line.trim());
        var width = this._getTextWidth(line);
        return this.textArr.push({
          text: line,
          width,
          lastInParagraph: !1
        });
      }
      _getTextWidth(text) {
        var letterSpacing = this.letterSpacing(), length = text.length;
        return getDummyContext2().measureText(text).width + (length ? letterSpacing * (length - 1) : 0);
      }
      _setTextData() {
        var lines = this.text().split(`
`), fontSize = +this.fontSize(), textWidth = 0, lineHeightPx = this.lineHeight() * fontSize, width = this.attrs.width, height = this.attrs.height, fixedWidth = width !== AUTO && width !== void 0, fixedHeight = height !== AUTO && height !== void 0, padding = this.padding(), maxWidth = width - padding * 2, maxHeightPx = height - padding * 2, currentHeightPx = 0, wrap = this.wrap(), shouldWrap = wrap !== NONE, wrapAtWord = wrap !== CHAR && shouldWrap, shouldAddEllipsis = this.ellipsis();
        this.textArr = [], getDummyContext2().font = this._getContextFont();
        for (var additionalWidth = shouldAddEllipsis ? this._getTextWidth(ELLIPSIS) : 0, i = 0, max = lines.length; i < max; ++i) {
          var line = lines[i], lineWidth = this._getTextWidth(line);
          if (fixedWidth && lineWidth > maxWidth)
            for (; line.length > 0; ) {
              for (var low = 0, high = line.length, match = "", matchWidth = 0; low < high; ) {
                var mid = low + high >>> 1, substr = line.slice(0, mid + 1), substrWidth = this._getTextWidth(substr) + additionalWidth;
                substrWidth <= maxWidth ? (low = mid + 1, match = substr, matchWidth = substrWidth) : high = mid;
              }
              if (match) {
                if (wrapAtWord) {
                  var wrapIndex, nextChar = line[match.length], nextIsSpaceOrDash = nextChar === SPACE2 || nextChar === DASH;
                  nextIsSpaceOrDash && matchWidth <= maxWidth ? wrapIndex = match.length : wrapIndex = Math.max(match.lastIndexOf(SPACE2), match.lastIndexOf(DASH)) + 1, wrapIndex > 0 && (low = wrapIndex, match = match.slice(0, low), matchWidth = this._getTextWidth(match));
                }
                match = match.trimRight(), this._addTextLine(match), textWidth = Math.max(textWidth, matchWidth), currentHeightPx += lineHeightPx;
                var shouldHandleEllipsis = this._shouldHandleEllipsis(currentHeightPx);
                if (shouldHandleEllipsis) {
                  this._tryToAddEllipsisToLastLine();
                  break;
                }
                if (line = line.slice(low), line = line.trimLeft(), line.length > 0 && (lineWidth = this._getTextWidth(line), lineWidth <= maxWidth)) {
                  this._addTextLine(line), currentHeightPx += lineHeightPx, textWidth = Math.max(textWidth, lineWidth);
                  break;
                }
              } else
                break;
            }
          else
            this._addTextLine(line), currentHeightPx += lineHeightPx, textWidth = Math.max(textWidth, lineWidth), this._shouldHandleEllipsis(currentHeightPx) && i < max - 1 && this._tryToAddEllipsisToLastLine();
          if (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx)
            break;
          this.textArr[this.textArr.length - 1] && (this.textArr[this.textArr.length - 1].lastInParagraph = !0);
        }
        this.textHeight = fontSize, this.textWidth = textWidth;
      }
      _shouldHandleEllipsis(currentHeightPx) {
        var fontSize = +this.fontSize(), lineHeightPx = this.lineHeight() * fontSize, height = this.attrs.height, fixedHeight = height !== AUTO && height !== void 0, padding = this.padding(), maxHeightPx = height - padding * 2, wrap = this.wrap(), shouldWrap = wrap !== NONE;
        return !shouldWrap || fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx;
      }
      _tryToAddEllipsisToLastLine() {
        var width = this.attrs.width, fixedWidth = width !== AUTO && width !== void 0, padding = this.padding(), maxWidth = width - padding * 2, shouldAddEllipsis = this.ellipsis(), lastLine = this.textArr[this.textArr.length - 1];
        if (!(!lastLine || !shouldAddEllipsis)) {
          if (fixedWidth) {
            var haveSpace = this._getTextWidth(lastLine.text + ELLIPSIS) < maxWidth;
            haveSpace || (lastLine.text = lastLine.text.slice(0, lastLine.text.length - 3));
          }
          this.textArr.splice(this.textArr.length - 1, 1), this._addTextLine(lastLine.text + ELLIPSIS);
        }
      }
      getStrokeScaleEnabled() {
        return !0;
      }
    };
    exports.Text = Text2;
    Text2.prototype._fillFunc = _fillFunc2;
    Text2.prototype._strokeFunc = _strokeFunc2;
    Text2.prototype.className = TEXT_UPPER;
    Text2.prototype._attrsAffectingSize = [
      "text",
      "fontSize",
      "padding",
      "wrap",
      "lineHeight",
      "letterSpacing"
    ];
    (0, Global_1._registerNode)(Text2);
    Factory_1.Factory.overWriteSetter(Text2, "width", (0, Validators_1.getNumberOrAutoValidator)());
    Factory_1.Factory.overWriteSetter(Text2, "height", (0, Validators_1.getNumberOrAutoValidator)());
    Factory_1.Factory.addGetterSetter(Text2, "fontFamily", "Arial");
    Factory_1.Factory.addGetterSetter(Text2, "fontSize", 12, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Text2, "fontStyle", NORMAL);
    Factory_1.Factory.addGetterSetter(Text2, "fontVariant", NORMAL);
    Factory_1.Factory.addGetterSetter(Text2, "padding", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Text2, "align", LEFT);
    Factory_1.Factory.addGetterSetter(Text2, "verticalAlign", TOP);
    Factory_1.Factory.addGetterSetter(Text2, "lineHeight", 1, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Text2, "wrap", WORD);
    Factory_1.Factory.addGetterSetter(Text2, "ellipsis", !1, (0, Validators_1.getBooleanValidator)());
    Factory_1.Factory.addGetterSetter(Text2, "letterSpacing", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Text2, "text", "", (0, Validators_1.getStringValidator)());
    Factory_1.Factory.addGetterSetter(Text2, "textDecoration", "");
  }
});

// node_modules/konva/cmj/shapes/TextPath.js
var require_TextPath = __commonJS({
  "node_modules/konva/cmj/shapes/TextPath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.TextPath = void 0;
    var Util_1 = require_Util(), Factory_1 = require_Factory(), Shape_1 = require_Shape(), Path_1 = require_Path(), Text_1 = require_Text2(), Validators_1 = require_Validators(), Global_1 = require_Global2(), EMPTY_STRING2 = "", NORMAL = "normal";
    function _fillFunc2(context) {
      context.fillText(this.partialText, 0, 0);
    }
    function _strokeFunc2(context) {
      context.strokeText(this.partialText, 0, 0);
    }
    var TextPath = class extends Shape_1.Shape {
      constructor(config) {
        super(config), this.dummyCanvas = Util_1.Util.createCanvasElement(), this.dataArray = [], this.dataArray = Path_1.Path.parsePathData(this.attrs.data), this.on("dataChange.konva", function() {
          this.dataArray = Path_1.Path.parsePathData(this.attrs.data), this._setTextData();
        }), this.on("textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva", this._setTextData), this._setTextData();
      }
      _sceneFunc(context) {
        context.setAttr("font", this._getContextFont()), context.setAttr("textBaseline", this.textBaseline()), context.setAttr("textAlign", "left"), context.save();
        var textDecoration = this.textDecoration(), fill = this.fill(), fontSize = this.fontSize(), glyphInfo = this.glyphInfo;
        textDecoration === "underline" && context.beginPath();
        for (var i = 0; i < glyphInfo.length; i++) {
          context.save();
          var p0 = glyphInfo[i].p0;
          context.translate(p0.x, p0.y), context.rotate(glyphInfo[i].rotation), this.partialText = glyphInfo[i].text, context.fillStrokeShape(this), textDecoration === "underline" && (i === 0 && context.moveTo(0, fontSize / 2 + 1), context.lineTo(fontSize, fontSize / 2 + 1)), context.restore();
        }
        textDecoration === "underline" && (context.strokeStyle = fill, context.lineWidth = fontSize / 20, context.stroke()), context.restore();
      }
      _hitFunc(context) {
        context.beginPath();
        var glyphInfo = this.glyphInfo;
        if (glyphInfo.length >= 1) {
          var p0 = glyphInfo[0].p0;
          context.moveTo(p0.x, p0.y);
        }
        for (var i = 0; i < glyphInfo.length; i++) {
          var p1 = glyphInfo[i].p1;
          context.lineTo(p1.x, p1.y);
        }
        context.setAttr("lineWidth", this.fontSize()), context.setAttr("strokeStyle", this.colorKey), context.stroke();
      }
      getTextWidth() {
        return this.textWidth;
      }
      getTextHeight() {
        return Util_1.Util.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."), this.textHeight;
      }
      setText(text) {
        return Text_1.Text.prototype.setText.call(this, text);
      }
      _getContextFont() {
        return Text_1.Text.prototype._getContextFont.call(this);
      }
      _getTextSize(text) {
        var dummyCanvas = this.dummyCanvas, _context = dummyCanvas.getContext("2d");
        _context.save(), _context.font = this._getContextFont();
        var metrics = _context.measureText(text);
        return _context.restore(), {
          width: metrics.width,
          height: parseInt(this.attrs.fontSize, 10)
        };
      }
      _setTextData() {
        var that = this, size = this._getTextSize(this.attrs.text), letterSpacing = this.letterSpacing(), align = this.align(), kerningFunc = this.kerningFunc();
        this.textWidth = size.width, this.textHeight = size.height;
        var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || "").length - 1) * letterSpacing, 0);
        this.glyphInfo = [];
        for (var fullPathWidth = 0, l = 0; l < that.dataArray.length; l++)
          that.dataArray[l].pathLength > 0 && (fullPathWidth += that.dataArray[l].pathLength);
        var offset = 0;
        align === "center" && (offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2)), align === "right" && (offset = Math.max(0, fullPathWidth - textFullWidth));
        for (var charArr = (0, Text_1.stringToArray)(this.text()), spacesNumber = this.text().split(" ").length - 1, p0, p1, pathCmd, pIndex = -1, currentT = 0, getNextPathSegment = function() {
          currentT = 0;
          for (var pathData = that.dataArray, j = pIndex + 1; j < pathData.length; j++) {
            if (pathData[j].pathLength > 0)
              return pIndex = j, pathData[j];
            pathData[j].command === "M" && (p0 = {
              x: pathData[j].points[0],
              y: pathData[j].points[1]
            });
          }
          return {};
        }, findSegmentToFitCharacter = function(c) {
          var glyphWidth2 = that._getTextSize(c).width + letterSpacing;
          c === " " && align === "justify" && (glyphWidth2 += (fullPathWidth - textFullWidth) / spacesNumber);
          var currLen = 0, attempts = 0;
          for (p1 = void 0; Math.abs(glyphWidth2 - currLen) / glyphWidth2 > 0.01 && attempts < 20; ) {
            attempts++;
            for (var cumulativePathLength = currLen; pathCmd === void 0; )
              pathCmd = getNextPathSegment(), pathCmd && cumulativePathLength + pathCmd.pathLength < glyphWidth2 && (cumulativePathLength += pathCmd.pathLength, pathCmd = void 0);
            if (Object.keys(pathCmd).length === 0 || p0 === void 0)
              return;
            var needNewSegment = !1;
            switch (pathCmd.command) {
              case "L":
                Path_1.Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth2 ? p1 = Path_1.Path.getPointOnLine(glyphWidth2, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y) : pathCmd = void 0;
                break;
              case "A":
                var start = pathCmd.points[4], dTheta = pathCmd.points[5], end = pathCmd.points[4] + dTheta;
                currentT === 0 ? currentT = start + 1e-8 : glyphWidth2 > currLen ? currentT += Math.PI / 180 * dTheta / Math.abs(dTheta) : currentT -= Math.PI / 360 * dTheta / Math.abs(dTheta), (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) && (currentT = end, needNewSegment = !0), p1 = Path_1.Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);
                break;
              case "C":
                currentT === 0 ? glyphWidth2 > pathCmd.pathLength ? currentT = 1e-8 : currentT = glyphWidth2 / pathCmd.pathLength : glyphWidth2 > currLen ? currentT += (glyphWidth2 - currLen) / pathCmd.pathLength / 2 : currentT = Math.max(currentT - (currLen - glyphWidth2) / pathCmd.pathLength / 2, 0), currentT > 1 && (currentT = 1, needNewSegment = !0), p1 = Path_1.Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);
                break;
              case "Q":
                currentT === 0 ? currentT = glyphWidth2 / pathCmd.pathLength : glyphWidth2 > currLen ? currentT += (glyphWidth2 - currLen) / pathCmd.pathLength : currentT -= (currLen - glyphWidth2) / pathCmd.pathLength, currentT > 1 && (currentT = 1, needNewSegment = !0), p1 = Path_1.Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);
                break;
            }
            p1 !== void 0 && (currLen = Path_1.Path.getLineLength(p0.x, p0.y, p1.x, p1.y)), needNewSegment && (needNewSegment = !1, pathCmd = void 0);
          }
        }, testChar = "C", glyphWidth = that._getTextSize(testChar).width + letterSpacing, lettersInOffset = offset / glyphWidth - 1, k = 0; k < lettersInOffset && (findSegmentToFitCharacter(testChar), !(p0 === void 0 || p1 === void 0)); k++)
          p0 = p1;
        for (var i = 0; i < charArr.length && (findSegmentToFitCharacter(charArr[i]), !(p0 === void 0 || p1 === void 0)); i++) {
          var width = Path_1.Path.getLineLength(p0.x, p0.y, p1.x, p1.y), kern = 0;
          if (kerningFunc)
            try {
              kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();
            } catch {
              kern = 0;
            }
          p0.x += kern, p1.x += kern, this.textWidth += kern;
          var midpoint = Path_1.Path.getPointOnLine(kern + width / 2, p0.x, p0.y, p1.x, p1.y), rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);
          this.glyphInfo.push({
            transposeX: midpoint.x,
            transposeY: midpoint.y,
            text: charArr[i],
            rotation,
            p0,
            p1
          }), p0 = p1;
        }
      }
      getSelfRect() {
        if (!this.glyphInfo.length)
          return {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        var points = [];
        this.glyphInfo.forEach(function(info) {
          points.push(info.p0.x), points.push(info.p0.y), points.push(info.p1.x), points.push(info.p1.y);
        });
        for (var minX = points[0] || 0, maxX = points[0] || 0, minY = points[1] || 0, maxY = points[1] || 0, x, y, i = 0; i < points.length / 2; i++)
          x = points[i * 2], y = points[i * 2 + 1], minX = Math.min(minX, x), maxX = Math.max(maxX, x), minY = Math.min(minY, y), maxY = Math.max(maxY, y);
        var fontSize = this.fontSize();
        return {
          x: minX - fontSize / 2,
          y: minY - fontSize / 2,
          width: maxX - minX + fontSize,
          height: maxY - minY + fontSize
        };
      }
      destroy() {
        return Util_1.Util.releaseCanvas(this.dummyCanvas), super.destroy();
      }
    };
    exports.TextPath = TextPath;
    TextPath.prototype._fillFunc = _fillFunc2;
    TextPath.prototype._strokeFunc = _strokeFunc2;
    TextPath.prototype._fillFuncHit = _fillFunc2;
    TextPath.prototype._strokeFuncHit = _strokeFunc2;
    TextPath.prototype.className = "TextPath";
    TextPath.prototype._attrsAffectingSize = ["text", "fontSize", "data"];
    (0, Global_1._registerNode)(TextPath);
    Factory_1.Factory.addGetterSetter(TextPath, "data");
    Factory_1.Factory.addGetterSetter(TextPath, "fontFamily", "Arial");
    Factory_1.Factory.addGetterSetter(TextPath, "fontSize", 12, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(TextPath, "fontStyle", NORMAL);
    Factory_1.Factory.addGetterSetter(TextPath, "align", "left");
    Factory_1.Factory.addGetterSetter(TextPath, "letterSpacing", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(TextPath, "textBaseline", "middle");
    Factory_1.Factory.addGetterSetter(TextPath, "fontVariant", NORMAL);
    Factory_1.Factory.addGetterSetter(TextPath, "text", EMPTY_STRING2);
    Factory_1.Factory.addGetterSetter(TextPath, "textDecoration", null);
    Factory_1.Factory.addGetterSetter(TextPath, "kerningFunc", null);
  }
});

// node_modules/konva/cmj/shapes/Transformer.js
var require_Transformer = __commonJS({
  "node_modules/konva/cmj/shapes/Transformer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Transformer = void 0;
    var Util_1 = require_Util(), Factory_1 = require_Factory(), Node_1 = require_Node(), Shape_1 = require_Shape(), Rect_1 = require_Rect(), Group_1 = require_Group(), Global_1 = require_Global2(), Validators_1 = require_Validators(), Global_2 = require_Global2(), EVENTS_NAME = "tr-konva", ATTR_CHANGE_LIST = [
      "resizeEnabledChange",
      "rotateAnchorOffsetChange",
      "rotateEnabledChange",
      "enabledAnchorsChange",
      "anchorSizeChange",
      "borderEnabledChange",
      "borderStrokeChange",
      "borderStrokeWidthChange",
      "borderDashChange",
      "anchorStrokeChange",
      "anchorStrokeWidthChange",
      "anchorFillChange",
      "anchorCornerRadiusChange",
      "ignoreStrokeChange"
    ].map((e) => e + `.${EVENTS_NAME}`).join(" "), NODES_RECT = "nodesRect", TRANSFORM_CHANGE_STR2 = [
      "widthChange",
      "heightChange",
      "scaleXChange",
      "scaleYChange",
      "skewXChange",
      "skewYChange",
      "rotationChange",
      "offsetXChange",
      "offsetYChange",
      "transformsEnabledChange",
      "strokeWidthChange"
    ], ANGLES = {
      "top-left": -45,
      "top-center": 0,
      "top-right": 45,
      "middle-right": -90,
      "middle-left": 90,
      "bottom-left": -135,
      "bottom-center": 180,
      "bottom-right": 135
    }, TOUCH_DEVICE = "ontouchstart" in Global_1.Konva._global;
    function getCursor(anchorName, rad) {
      if (anchorName === "rotater")
        return "crosshair";
      rad += Util_1.Util.degToRad(ANGLES[anchorName] || 0);
      var angle = (Util_1.Util.radToDeg(rad) % 360 + 360) % 360;
      return Util_1.Util._inRange(angle, 315 + 22.5, 360) || Util_1.Util._inRange(angle, 0, 22.5) ? "ns-resize" : Util_1.Util._inRange(angle, 45 - 22.5, 45 + 22.5) ? "nesw-resize" : Util_1.Util._inRange(angle, 90 - 22.5, 90 + 22.5) ? "ew-resize" : Util_1.Util._inRange(angle, 135 - 22.5, 135 + 22.5) ? "nwse-resize" : Util_1.Util._inRange(angle, 180 - 22.5, 180 + 22.5) ? "ns-resize" : Util_1.Util._inRange(angle, 225 - 22.5, 225 + 22.5) ? "nesw-resize" : Util_1.Util._inRange(angle, 270 - 22.5, 270 + 22.5) ? "ew-resize" : Util_1.Util._inRange(angle, 315 - 22.5, 315 + 22.5) ? "nwse-resize" : (Util_1.Util.error("Transformer has unknown angle for cursor detection: " + angle), "pointer");
    }
    var ANCHORS_NAMES = [
      "top-left",
      "top-center",
      "top-right",
      "middle-right",
      "middle-left",
      "bottom-left",
      "bottom-center",
      "bottom-right"
    ], MAX_SAFE_INTEGER = 1e8;
    function getCenter(shape) {
      return {
        x: shape.x + shape.width / 2 * Math.cos(shape.rotation) + shape.height / 2 * Math.sin(-shape.rotation),
        y: shape.y + shape.height / 2 * Math.cos(shape.rotation) + shape.width / 2 * Math.sin(shape.rotation)
      };
    }
    function rotateAroundPoint(shape, angleRad, point) {
      let x = point.x + (shape.x - point.x) * Math.cos(angleRad) - (shape.y - point.y) * Math.sin(angleRad), y = point.y + (shape.x - point.x) * Math.sin(angleRad) + (shape.y - point.y) * Math.cos(angleRad);
      return Object.assign(Object.assign({}, shape), {
        rotation: shape.rotation + angleRad,
        x,
        y
      });
    }
    function rotateAroundCenter(shape, deltaRad) {
      let center = getCenter(shape);
      return rotateAroundPoint(shape, deltaRad, center);
    }
    function getSnap(snaps, newRotationRad, tol) {
      let snapped = newRotationRad;
      for (let i = 0; i < snaps.length; i++) {
        let angle = Global_1.Konva.getAngle(snaps[i]), absDiff = Math.abs(angle - newRotationRad) % (Math.PI * 2);
        Math.min(absDiff, Math.PI * 2 - absDiff) < tol && (snapped = angle);
      }
      return snapped;
    }
    var Transformer2 = class extends Group_1.Group {
      constructor(config) {
        super(config), this._transforming = !1, this._createElements(), this._handleMouseMove = this._handleMouseMove.bind(this), this._handleMouseUp = this._handleMouseUp.bind(this), this.update = this.update.bind(this), this.on(ATTR_CHANGE_LIST, this.update), this.getNode() && this.update();
      }
      attachTo(node) {
        return this.setNode(node), this;
      }
      setNode(node) {
        return Util_1.Util.warn("tr.setNode(shape), tr.node(shape) and tr.attachTo(shape) methods are deprecated. Please use tr.nodes(nodesArray) instead."), this.setNodes([node]);
      }
      getNode() {
        return this._nodes && this._nodes[0];
      }
      _getEventNamespace() {
        return EVENTS_NAME + this._id;
      }
      setNodes(nodes = []) {
        this._nodes && this._nodes.length && this.detach(), this._nodes = nodes, nodes.length === 1 && this.useSingleNodeRotation() ? this.rotation(nodes[0].getAbsoluteRotation()) : this.rotation(0), this._nodes.forEach((node) => {
          let onChange = () => {
            this.nodes().length === 1 && this.useSingleNodeRotation() && this.rotation(this.nodes()[0].getAbsoluteRotation()), this._resetTransformCache(), !this._transforming && !this.isDragging() && this.update();
          }, additionalEvents = node._attrsAffectingSize.map((prop) => prop + "Change." + this._getEventNamespace()).join(" ");
          node.on(additionalEvents, onChange), node.on(TRANSFORM_CHANGE_STR2.map((e) => e + `.${this._getEventNamespace()}`).join(" "), onChange), node.on(`absoluteTransformChange.${this._getEventNamespace()}`, onChange), this._proxyDrag(node);
        }), this._resetTransformCache();
        var elementsCreated = !!this.findOne(".top-left");
        return elementsCreated && this.update(), this;
      }
      _proxyDrag(node) {
        let lastPos;
        node.on(`dragstart.${this._getEventNamespace()}`, (e) => {
          lastPos = node.getAbsolutePosition(), !this.isDragging() && node !== this.findOne(".back") && this.startDrag(e, !1);
        }), node.on(`dragmove.${this._getEventNamespace()}`, (e) => {
          if (!lastPos)
            return;
          let abs = node.getAbsolutePosition(), dx = abs.x - lastPos.x, dy = abs.y - lastPos.y;
          this.nodes().forEach((otherNode) => {
            if (otherNode === node || otherNode.isDragging())
              return;
            let otherAbs = otherNode.getAbsolutePosition();
            otherNode.setAbsolutePosition({
              x: otherAbs.x + dx,
              y: otherAbs.y + dy
            }), otherNode.startDrag(e);
          }), lastPos = null;
        });
      }
      getNodes() {
        return this._nodes || [];
      }
      getActiveAnchor() {
        return this._movingAnchorName;
      }
      detach() {
        this._nodes && this._nodes.forEach((node) => {
          node.off("." + this._getEventNamespace());
        }), this._nodes = [], this._resetTransformCache();
      }
      _resetTransformCache() {
        this._clearCache(NODES_RECT), this._clearCache("transform"), this._clearSelfAndDescendantCache("absoluteTransform");
      }
      _getNodeRect() {
        return this._getCache(NODES_RECT, this.__getNodeRect);
      }
      __getNodeShape(node, rot = this.rotation(), relative) {
        var rect = node.getClientRect({
          skipTransform: !0,
          skipShadow: !0,
          skipStroke: this.ignoreStroke()
        }), absScale = node.getAbsoluteScale(relative), absPos = node.getAbsolutePosition(relative), dx = rect.x * absScale.x - node.offsetX() * absScale.x, dy = rect.y * absScale.y - node.offsetY() * absScale.y;
        let rotation = (Global_1.Konva.getAngle(node.getAbsoluteRotation()) + Math.PI * 2) % (Math.PI * 2), box = {
          x: absPos.x + dx * Math.cos(rotation) + dy * Math.sin(-rotation),
          y: absPos.y + dy * Math.cos(rotation) + dx * Math.sin(rotation),
          width: rect.width * absScale.x,
          height: rect.height * absScale.y,
          rotation
        };
        return rotateAroundPoint(box, -Global_1.Konva.getAngle(rot), {
          x: 0,
          y: 0
        });
      }
      __getNodeRect() {
        var node = this.getNode();
        if (!node)
          return {
            x: -MAX_SAFE_INTEGER,
            y: -MAX_SAFE_INTEGER,
            width: 0,
            height: 0,
            rotation: 0
          };
        let totalPoints = [];
        this.nodes().map((node2) => {
          let box = node2.getClientRect({
            skipTransform: !0,
            skipShadow: !0,
            skipStroke: this.ignoreStroke()
          });
          var points = [
            { x: box.x, y: box.y },
            { x: box.x + box.width, y: box.y },
            { x: box.x + box.width, y: box.y + box.height },
            { x: box.x, y: box.y + box.height }
          ], trans = node2.getAbsoluteTransform();
          points.forEach(function(point) {
            var transformed = trans.point(point);
            totalPoints.push(transformed);
          });
        });
        let tr = new Util_1.Transform();
        tr.rotate(-Global_1.Konva.getAngle(this.rotation()));
        var minX, minY, maxX, maxY;
        totalPoints.forEach(function(point) {
          var transformed = tr.point(point);
          minX === void 0 && (minX = maxX = transformed.x, minY = maxY = transformed.y), minX = Math.min(minX, transformed.x), minY = Math.min(minY, transformed.y), maxX = Math.max(maxX, transformed.x), maxY = Math.max(maxY, transformed.y);
        }), tr.invert();
        let p = tr.point({ x: minX, y: minY });
        return {
          x: p.x,
          y: p.y,
          width: maxX - minX,
          height: maxY - minY,
          rotation: Global_1.Konva.getAngle(this.rotation())
        };
      }
      getX() {
        return this._getNodeRect().x;
      }
      getY() {
        return this._getNodeRect().y;
      }
      getWidth() {
        return this._getNodeRect().width;
      }
      getHeight() {
        return this._getNodeRect().height;
      }
      _createElements() {
        this._createBack(), ANCHORS_NAMES.forEach(function(name) {
          this._createAnchor(name);
        }.bind(this)), this._createAnchor("rotater");
      }
      _createAnchor(name) {
        var anchor = new Rect_1.Rect({
          stroke: "rgb(0, 161, 255)",
          fill: "white",
          strokeWidth: 1,
          name: name + " _anchor",
          dragDistance: 0,
          draggable: !0,
          hitStrokeWidth: TOUCH_DEVICE ? 10 : "auto"
        }), self2 = this;
        anchor.on("mousedown touchstart", function(e) {
          self2._handleMouseDown(e);
        }), anchor.on("dragstart", (e) => {
          anchor.stopDrag(), e.cancelBubble = !0;
        }), anchor.on("dragend", (e) => {
          e.cancelBubble = !0;
        }), anchor.on("mouseenter", () => {
          var rad = Global_1.Konva.getAngle(this.rotation()), cursor = getCursor(name, rad);
          anchor.getStage().content && (anchor.getStage().content.style.cursor = cursor), this._cursorChange = !0;
        }), anchor.on("mouseout", () => {
          anchor.getStage().content && (anchor.getStage().content.style.cursor = ""), this._cursorChange = !1;
        }), this.add(anchor);
      }
      _createBack() {
        var back = new Shape_1.Shape({
          name: "back",
          width: 0,
          height: 0,
          draggable: !0,
          sceneFunc(ctx) {
            var tr = this.getParent(), padding = tr.padding();
            ctx.beginPath(), ctx.rect(-padding, -padding, this.width() + padding * 2, this.height() + padding * 2), ctx.moveTo(this.width() / 2, -padding), tr.rotateEnabled() && ctx.lineTo(this.width() / 2, -tr.rotateAnchorOffset() * Util_1.Util._sign(this.height()) - padding), ctx.fillStrokeShape(this);
          },
          hitFunc: (ctx, shape) => {
            if (!!this.shouldOverdrawWholeArea()) {
              var padding = this.padding();
              ctx.beginPath(), ctx.rect(-padding, -padding, shape.width() + padding * 2, shape.height() + padding * 2), ctx.fillStrokeShape(shape);
            }
          }
        });
        this.add(back), this._proxyDrag(back), back.on("dragstart", (e) => {
          e.cancelBubble = !0;
        }), back.on("dragmove", (e) => {
          e.cancelBubble = !0;
        }), back.on("dragend", (e) => {
          e.cancelBubble = !0;
        }), this.on("dragmove", (e) => {
          this.update();
        });
      }
      _handleMouseDown(e) {
        this._movingAnchorName = e.target.name().split(" ")[0];
        var attrs = this._getNodeRect(), width = attrs.width, height = attrs.height, hypotenuse = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));
        this.sin = Math.abs(height / hypotenuse), this.cos = Math.abs(width / hypotenuse), typeof window < "u" && (window.addEventListener("mousemove", this._handleMouseMove), window.addEventListener("touchmove", this._handleMouseMove), window.addEventListener("mouseup", this._handleMouseUp, !0), window.addEventListener("touchend", this._handleMouseUp, !0)), this._transforming = !0;
        var ap = e.target.getAbsolutePosition(), pos = e.target.getStage().getPointerPosition();
        this._anchorDragOffset = {
          x: pos.x - ap.x,
          y: pos.y - ap.y
        }, this._fire("transformstart", { evt: e.evt, target: this.getNode() }), this._nodes.forEach((target) => {
          target._fire("transformstart", { evt: e.evt, target });
        });
      }
      _handleMouseMove(e) {
        var x, y, newHypotenuse, anchorNode = this.findOne("." + this._movingAnchorName), stage = anchorNode.getStage();
        stage.setPointersPositions(e);
        let pp = stage.getPointerPosition(), newNodePos = {
          x: pp.x - this._anchorDragOffset.x,
          y: pp.y - this._anchorDragOffset.y
        }, oldAbs = anchorNode.getAbsolutePosition();
        this.anchorDragBoundFunc() && (newNodePos = this.anchorDragBoundFunc()(oldAbs, newNodePos, e)), anchorNode.setAbsolutePosition(newNodePos);
        let newAbs = anchorNode.getAbsolutePosition();
        if (!(oldAbs.x === newAbs.x && oldAbs.y === newAbs.y)) {
          if (this._movingAnchorName === "rotater") {
            var attrs = this._getNodeRect();
            x = anchorNode.x() - attrs.width / 2, y = -anchorNode.y() + attrs.height / 2;
            let delta = Math.atan2(-y, x) + Math.PI / 2;
            attrs.height < 0 && (delta -= Math.PI);
            var oldRotation = Global_1.Konva.getAngle(this.rotation());
            let newRotation = oldRotation + delta, tol = Global_1.Konva.getAngle(this.rotationSnapTolerance()), diff = getSnap(this.rotationSnaps(), newRotation, tol) - attrs.rotation, shape = rotateAroundCenter(attrs, diff);
            this._fitNodesInto(shape, e);
            return;
          }
          var keepProportion = this.keepRatio() || e.shiftKey, centeredScaling = this.centeredScaling() || e.altKey;
          if (this._movingAnchorName === "top-left") {
            if (keepProportion) {
              var comparePoint = centeredScaling ? {
                x: this.width() / 2,
                y: this.height() / 2
              } : {
                x: this.findOne(".bottom-right").x(),
                y: this.findOne(".bottom-right").y()
              };
              newHypotenuse = Math.sqrt(Math.pow(comparePoint.x - anchorNode.x(), 2) + Math.pow(comparePoint.y - anchorNode.y(), 2));
              var reverseX = this.findOne(".top-left").x() > comparePoint.x ? -1 : 1, reverseY = this.findOne(".top-left").y() > comparePoint.y ? -1 : 1;
              x = newHypotenuse * this.cos * reverseX, y = newHypotenuse * this.sin * reverseY, this.findOne(".top-left").x(comparePoint.x - x), this.findOne(".top-left").y(comparePoint.y - y);
            }
          } else if (this._movingAnchorName === "top-center")
            this.findOne(".top-left").y(anchorNode.y());
          else if (this._movingAnchorName === "top-right") {
            if (keepProportion) {
              var comparePoint = centeredScaling ? {
                x: this.width() / 2,
                y: this.height() / 2
              } : {
                x: this.findOne(".bottom-left").x(),
                y: this.findOne(".bottom-left").y()
              };
              newHypotenuse = Math.sqrt(Math.pow(anchorNode.x() - comparePoint.x, 2) + Math.pow(comparePoint.y - anchorNode.y(), 2));
              var reverseX = this.findOne(".top-right").x() < comparePoint.x ? -1 : 1, reverseY = this.findOne(".top-right").y() > comparePoint.y ? -1 : 1;
              x = newHypotenuse * this.cos * reverseX, y = newHypotenuse * this.sin * reverseY, this.findOne(".top-right").x(comparePoint.x + x), this.findOne(".top-right").y(comparePoint.y - y);
            }
            var pos = anchorNode.position();
            this.findOne(".top-left").y(pos.y), this.findOne(".bottom-right").x(pos.x);
          } else if (this._movingAnchorName === "middle-left")
            this.findOne(".top-left").x(anchorNode.x());
          else if (this._movingAnchorName === "middle-right")
            this.findOne(".bottom-right").x(anchorNode.x());
          else if (this._movingAnchorName === "bottom-left") {
            if (keepProportion) {
              var comparePoint = centeredScaling ? {
                x: this.width() / 2,
                y: this.height() / 2
              } : {
                x: this.findOne(".top-right").x(),
                y: this.findOne(".top-right").y()
              };
              newHypotenuse = Math.sqrt(Math.pow(comparePoint.x - anchorNode.x(), 2) + Math.pow(anchorNode.y() - comparePoint.y, 2));
              var reverseX = comparePoint.x < anchorNode.x() ? -1 : 1, reverseY = anchorNode.y() < comparePoint.y ? -1 : 1;
              x = newHypotenuse * this.cos * reverseX, y = newHypotenuse * this.sin * reverseY, anchorNode.x(comparePoint.x - x), anchorNode.y(comparePoint.y + y);
            }
            pos = anchorNode.position(), this.findOne(".top-left").x(pos.x), this.findOne(".bottom-right").y(pos.y);
          } else if (this._movingAnchorName === "bottom-center")
            this.findOne(".bottom-right").y(anchorNode.y());
          else if (this._movingAnchorName === "bottom-right") {
            if (keepProportion) {
              var comparePoint = centeredScaling ? {
                x: this.width() / 2,
                y: this.height() / 2
              } : {
                x: this.findOne(".top-left").x(),
                y: this.findOne(".top-left").y()
              };
              newHypotenuse = Math.sqrt(Math.pow(anchorNode.x() - comparePoint.x, 2) + Math.pow(anchorNode.y() - comparePoint.y, 2));
              var reverseX = this.findOne(".bottom-right").x() < comparePoint.x ? -1 : 1, reverseY = this.findOne(".bottom-right").y() < comparePoint.y ? -1 : 1;
              x = newHypotenuse * this.cos * reverseX, y = newHypotenuse * this.sin * reverseY, this.findOne(".bottom-right").x(comparePoint.x + x), this.findOne(".bottom-right").y(comparePoint.y + y);
            }
          } else
            console.error(new Error("Wrong position argument of selection resizer: " + this._movingAnchorName));
          var centeredScaling = this.centeredScaling() || e.altKey;
          if (centeredScaling) {
            var topLeft = this.findOne(".top-left"), bottomRight = this.findOne(".bottom-right"), topOffsetX = topLeft.x(), topOffsetY = topLeft.y(), bottomOffsetX = this.getWidth() - bottomRight.x(), bottomOffsetY = this.getHeight() - bottomRight.y();
            bottomRight.move({
              x: -topOffsetX,
              y: -topOffsetY
            }), topLeft.move({
              x: bottomOffsetX,
              y: bottomOffsetY
            });
          }
          var absPos = this.findOne(".top-left").getAbsolutePosition();
          x = absPos.x, y = absPos.y;
          var width = this.findOne(".bottom-right").x() - this.findOne(".top-left").x(), height = this.findOne(".bottom-right").y() - this.findOne(".top-left").y();
          this._fitNodesInto({
            x,
            y,
            width,
            height,
            rotation: Global_1.Konva.getAngle(this.rotation())
          }, e);
        }
      }
      _handleMouseUp(e) {
        this._removeEvents(e);
      }
      getAbsoluteTransform() {
        return this.getTransform();
      }
      _removeEvents(e) {
        if (this._transforming) {
          this._transforming = !1, typeof window < "u" && (window.removeEventListener("mousemove", this._handleMouseMove), window.removeEventListener("touchmove", this._handleMouseMove), window.removeEventListener("mouseup", this._handleMouseUp, !0), window.removeEventListener("touchend", this._handleMouseUp, !0));
          var node = this.getNode();
          this._fire("transformend", { evt: e, target: node }), node && this._nodes.forEach((target) => {
            target._fire("transformend", { evt: e, target });
          }), this._movingAnchorName = null;
        }
      }
      _fitNodesInto(newAttrs, evt) {
        var oldAttrs = this._getNodeRect();
        let minSize = 1;
        if (Util_1.Util._inRange(newAttrs.width, -this.padding() * 2 - minSize, minSize)) {
          this.update();
          return;
        }
        if (Util_1.Util._inRange(newAttrs.height, -this.padding() * 2 - minSize, minSize)) {
          this.update();
          return;
        }
        let allowNegativeScale = this.flipEnabled();
        var t = new Util_1.Transform();
        if (t.rotate(Global_1.Konva.getAngle(this.rotation())), this._movingAnchorName && newAttrs.width < 0 && this._movingAnchorName.indexOf("left") >= 0) {
          let offset = t.point({
            x: -this.padding() * 2,
            y: 0
          });
          if (newAttrs.x += offset.x, newAttrs.y += offset.y, newAttrs.width += this.padding() * 2, this._movingAnchorName = this._movingAnchorName.replace("left", "right"), this._anchorDragOffset.x -= offset.x, this._anchorDragOffset.y -= offset.y, !allowNegativeScale) {
            this.update();
            return;
          }
        } else if (this._movingAnchorName && newAttrs.width < 0 && this._movingAnchorName.indexOf("right") >= 0) {
          let offset = t.point({
            x: this.padding() * 2,
            y: 0
          });
          if (this._movingAnchorName = this._movingAnchorName.replace("right", "left"), this._anchorDragOffset.x -= offset.x, this._anchorDragOffset.y -= offset.y, newAttrs.width += this.padding() * 2, !allowNegativeScale) {
            this.update();
            return;
          }
        }
        if (this._movingAnchorName && newAttrs.height < 0 && this._movingAnchorName.indexOf("top") >= 0) {
          let offset = t.point({
            x: 0,
            y: -this.padding() * 2
          });
          if (newAttrs.x += offset.x, newAttrs.y += offset.y, this._movingAnchorName = this._movingAnchorName.replace("top", "bottom"), this._anchorDragOffset.x -= offset.x, this._anchorDragOffset.y -= offset.y, newAttrs.height += this.padding() * 2, !allowNegativeScale) {
            this.update();
            return;
          }
        } else if (this._movingAnchorName && newAttrs.height < 0 && this._movingAnchorName.indexOf("bottom") >= 0) {
          let offset = t.point({
            x: 0,
            y: this.padding() * 2
          });
          if (this._movingAnchorName = this._movingAnchorName.replace("bottom", "top"), this._anchorDragOffset.x -= offset.x, this._anchorDragOffset.y -= offset.y, newAttrs.height += this.padding() * 2, !allowNegativeScale) {
            this.update();
            return;
          }
        }
        if (this.boundBoxFunc()) {
          let bounded = this.boundBoxFunc()(oldAttrs, newAttrs);
          bounded ? newAttrs = bounded : Util_1.Util.warn("boundBoxFunc returned falsy. You should return new bound rect from it!");
        }
        let baseSize = 1e7, oldTr = new Util_1.Transform();
        oldTr.translate(oldAttrs.x, oldAttrs.y), oldTr.rotate(oldAttrs.rotation), oldTr.scale(oldAttrs.width / baseSize, oldAttrs.height / baseSize);
        let newTr = new Util_1.Transform();
        newTr.translate(newAttrs.x, newAttrs.y), newTr.rotate(newAttrs.rotation), newTr.scale(newAttrs.width / baseSize, newAttrs.height / baseSize);
        let delta = newTr.multiply(oldTr.invert());
        this._nodes.forEach((node) => {
          var _a;
          let parentTransform = node.getParent().getAbsoluteTransform(), localTransform = node.getTransform().copy();
          localTransform.translate(node.offsetX(), node.offsetY());
          let newLocalTransform = new Util_1.Transform();
          newLocalTransform.multiply(parentTransform.copy().invert()).multiply(delta).multiply(parentTransform).multiply(localTransform);
          let attrs = newLocalTransform.decompose();
          node.setAttrs(attrs), this._fire("transform", { evt, target: node }), node._fire("transform", { evt, target: node }), (_a = node.getLayer()) === null || _a === void 0 || _a.batchDraw();
        }), this.rotation(Util_1.Util._getRotation(newAttrs.rotation)), this._resetTransformCache(), this.update(), this.getLayer().batchDraw();
      }
      forceUpdate() {
        this._resetTransformCache(), this.update();
      }
      _batchChangeChild(selector, attrs) {
        this.findOne(selector).setAttrs(attrs);
      }
      update() {
        var _a, attrs = this._getNodeRect();
        this.rotation(Util_1.Util._getRotation(attrs.rotation));
        var width = attrs.width, height = attrs.height, enabledAnchors = this.enabledAnchors(), resizeEnabled = this.resizeEnabled(), padding = this.padding(), anchorSize = this.anchorSize();
        this.find("._anchor").forEach((node) => {
          node.setAttrs({
            width: anchorSize,
            height: anchorSize,
            offsetX: anchorSize / 2,
            offsetY: anchorSize / 2,
            stroke: this.anchorStroke(),
            strokeWidth: this.anchorStrokeWidth(),
            fill: this.anchorFill(),
            cornerRadius: this.anchorCornerRadius()
          });
        }), this._batchChangeChild(".top-left", {
          x: 0,
          y: 0,
          offsetX: anchorSize / 2 + padding,
          offsetY: anchorSize / 2 + padding,
          visible: resizeEnabled && enabledAnchors.indexOf("top-left") >= 0
        }), this._batchChangeChild(".top-center", {
          x: width / 2,
          y: 0,
          offsetY: anchorSize / 2 + padding,
          visible: resizeEnabled && enabledAnchors.indexOf("top-center") >= 0
        }), this._batchChangeChild(".top-right", {
          x: width,
          y: 0,
          offsetX: anchorSize / 2 - padding,
          offsetY: anchorSize / 2 + padding,
          visible: resizeEnabled && enabledAnchors.indexOf("top-right") >= 0
        }), this._batchChangeChild(".middle-left", {
          x: 0,
          y: height / 2,
          offsetX: anchorSize / 2 + padding,
          visible: resizeEnabled && enabledAnchors.indexOf("middle-left") >= 0
        }), this._batchChangeChild(".middle-right", {
          x: width,
          y: height / 2,
          offsetX: anchorSize / 2 - padding,
          visible: resizeEnabled && enabledAnchors.indexOf("middle-right") >= 0
        }), this._batchChangeChild(".bottom-left", {
          x: 0,
          y: height,
          offsetX: anchorSize / 2 + padding,
          offsetY: anchorSize / 2 - padding,
          visible: resizeEnabled && enabledAnchors.indexOf("bottom-left") >= 0
        }), this._batchChangeChild(".bottom-center", {
          x: width / 2,
          y: height,
          offsetY: anchorSize / 2 - padding,
          visible: resizeEnabled && enabledAnchors.indexOf("bottom-center") >= 0
        }), this._batchChangeChild(".bottom-right", {
          x: width,
          y: height,
          offsetX: anchorSize / 2 - padding,
          offsetY: anchorSize / 2 - padding,
          visible: resizeEnabled && enabledAnchors.indexOf("bottom-right") >= 0
        }), this._batchChangeChild(".rotater", {
          x: width / 2,
          y: -this.rotateAnchorOffset() * Util_1.Util._sign(height) - padding,
          visible: this.rotateEnabled()
        }), this._batchChangeChild(".back", {
          width,
          height,
          visible: this.borderEnabled(),
          stroke: this.borderStroke(),
          strokeWidth: this.borderStrokeWidth(),
          dash: this.borderDash(),
          x: 0,
          y: 0
        }), (_a = this.getLayer()) === null || _a === void 0 || _a.batchDraw();
      }
      isTransforming() {
        return this._transforming;
      }
      stopTransform() {
        if (this._transforming) {
          this._removeEvents();
          var anchorNode = this.findOne("." + this._movingAnchorName);
          anchorNode && anchorNode.stopDrag();
        }
      }
      destroy() {
        return this.getStage() && this._cursorChange && this.getStage().content && (this.getStage().content.style.cursor = ""), Group_1.Group.prototype.destroy.call(this), this.detach(), this._removeEvents(), this;
      }
      toObject() {
        return Node_1.Node.prototype.toObject.call(this);
      }
      getClientRect() {
        return this.nodes().length > 0 ? super.getClientRect() : { x: 0, y: 0, width: 0, height: 0 };
      }
    };
    exports.Transformer = Transformer2;
    function validateAnchors(val) {
      return val instanceof Array || Util_1.Util.warn("enabledAnchors value should be an array"), val instanceof Array && val.forEach(function(name) {
        ANCHORS_NAMES.indexOf(name) === -1 && Util_1.Util.warn("Unknown anchor name: " + name + ". Available names are: " + ANCHORS_NAMES.join(", "));
      }), val || [];
    }
    Transformer2.prototype.className = "Transformer";
    (0, Global_2._registerNode)(Transformer2);
    Factory_1.Factory.addGetterSetter(Transformer2, "enabledAnchors", ANCHORS_NAMES, validateAnchors);
    Factory_1.Factory.addGetterSetter(Transformer2, "flipEnabled", !0, (0, Validators_1.getBooleanValidator)());
    Factory_1.Factory.addGetterSetter(Transformer2, "resizeEnabled", !0);
    Factory_1.Factory.addGetterSetter(Transformer2, "anchorSize", 10, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Transformer2, "rotateEnabled", !0);
    Factory_1.Factory.addGetterSetter(Transformer2, "rotationSnaps", []);
    Factory_1.Factory.addGetterSetter(Transformer2, "rotateAnchorOffset", 50, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Transformer2, "rotationSnapTolerance", 5, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Transformer2, "borderEnabled", !0);
    Factory_1.Factory.addGetterSetter(Transformer2, "anchorStroke", "rgb(0, 161, 255)");
    Factory_1.Factory.addGetterSetter(Transformer2, "anchorStrokeWidth", 1, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Transformer2, "anchorFill", "white");
    Factory_1.Factory.addGetterSetter(Transformer2, "anchorCornerRadius", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Transformer2, "borderStroke", "rgb(0, 161, 255)");
    Factory_1.Factory.addGetterSetter(Transformer2, "borderStrokeWidth", 1, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Transformer2, "borderDash");
    Factory_1.Factory.addGetterSetter(Transformer2, "keepRatio", !0);
    Factory_1.Factory.addGetterSetter(Transformer2, "centeredScaling", !1);
    Factory_1.Factory.addGetterSetter(Transformer2, "ignoreStroke", !1);
    Factory_1.Factory.addGetterSetter(Transformer2, "padding", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Transformer2, "node");
    Factory_1.Factory.addGetterSetter(Transformer2, "nodes");
    Factory_1.Factory.addGetterSetter(Transformer2, "boundBoxFunc");
    Factory_1.Factory.addGetterSetter(Transformer2, "anchorDragBoundFunc");
    Factory_1.Factory.addGetterSetter(Transformer2, "shouldOverdrawWholeArea", !1);
    Factory_1.Factory.addGetterSetter(Transformer2, "useSingleNodeRotation", !0);
    Factory_1.Factory.backCompat(Transformer2, {
      lineEnabled: "borderEnabled",
      rotateHandlerOffset: "rotateAnchorOffset",
      enabledHandlers: "enabledAnchors"
    });
  }
});

// node_modules/konva/cmj/shapes/Wedge.js
var require_Wedge = __commonJS({
  "node_modules/konva/cmj/shapes/Wedge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Wedge = void 0;
    var Factory_1 = require_Factory(), Shape_1 = require_Shape(), Global_1 = require_Global2(), Validators_1 = require_Validators(), Global_2 = require_Global2(), Wedge = class extends Shape_1.Shape {
      _sceneFunc(context) {
        context.beginPath(), context.arc(0, 0, this.radius(), 0, Global_1.Konva.getAngle(this.angle()), this.clockwise()), context.lineTo(0, 0), context.closePath(), context.fillStrokeShape(this);
      }
      getWidth() {
        return this.radius() * 2;
      }
      getHeight() {
        return this.radius() * 2;
      }
      setWidth(width) {
        this.radius(width / 2);
      }
      setHeight(height) {
        this.radius(height / 2);
      }
    };
    exports.Wedge = Wedge;
    Wedge.prototype.className = "Wedge";
    Wedge.prototype._centroid = !0;
    Wedge.prototype._attrsAffectingSize = ["radius"];
    (0, Global_2._registerNode)(Wedge);
    Factory_1.Factory.addGetterSetter(Wedge, "radius", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Wedge, "angle", 0, (0, Validators_1.getNumberValidator)());
    Factory_1.Factory.addGetterSetter(Wedge, "clockwise", !1);
    Factory_1.Factory.backCompat(Wedge, {
      angleDeg: "angle",
      getAngleDeg: "getAngle",
      setAngleDeg: "setAngle"
    });
  }
});

// node_modules/konva/cmj/filters/Blur.js
var require_Blur = __commonJS({
  "node_modules/konva/cmj/filters/Blur.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Blur = void 0;
    var Factory_1 = require_Factory(), Node_1 = require_Node(), Validators_1 = require_Validators();
    function BlurStack() {
      this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.next = null;
    }
    var mul_table = [
      512,
      512,
      456,
      512,
      328,
      456,
      335,
      512,
      405,
      328,
      271,
      456,
      388,
      335,
      292,
      512,
      454,
      405,
      364,
      328,
      298,
      271,
      496,
      456,
      420,
      388,
      360,
      335,
      312,
      292,
      273,
      512,
      482,
      454,
      428,
      405,
      383,
      364,
      345,
      328,
      312,
      298,
      284,
      271,
      259,
      496,
      475,
      456,
      437,
      420,
      404,
      388,
      374,
      360,
      347,
      335,
      323,
      312,
      302,
      292,
      282,
      273,
      265,
      512,
      497,
      482,
      468,
      454,
      441,
      428,
      417,
      405,
      394,
      383,
      373,
      364,
      354,
      345,
      337,
      328,
      320,
      312,
      305,
      298,
      291,
      284,
      278,
      271,
      265,
      259,
      507,
      496,
      485,
      475,
      465,
      456,
      446,
      437,
      428,
      420,
      412,
      404,
      396,
      388,
      381,
      374,
      367,
      360,
      354,
      347,
      341,
      335,
      329,
      323,
      318,
      312,
      307,
      302,
      297,
      292,
      287,
      282,
      278,
      273,
      269,
      265,
      261,
      512,
      505,
      497,
      489,
      482,
      475,
      468,
      461,
      454,
      447,
      441,
      435,
      428,
      422,
      417,
      411,
      405,
      399,
      394,
      389,
      383,
      378,
      373,
      368,
      364,
      359,
      354,
      350,
      345,
      341,
      337,
      332,
      328,
      324,
      320,
      316,
      312,
      309,
      305,
      301,
      298,
      294,
      291,
      287,
      284,
      281,
      278,
      274,
      271,
      268,
      265,
      262,
      259,
      257,
      507,
      501,
      496,
      491,
      485,
      480,
      475,
      470,
      465,
      460,
      456,
      451,
      446,
      442,
      437,
      433,
      428,
      424,
      420,
      416,
      412,
      408,
      404,
      400,
      396,
      392,
      388,
      385,
      381,
      377,
      374,
      370,
      367,
      363,
      360,
      357,
      354,
      350,
      347,
      344,
      341,
      338,
      335,
      332,
      329,
      326,
      323,
      320,
      318,
      315,
      312,
      310,
      307,
      304,
      302,
      299,
      297,
      294,
      292,
      289,
      287,
      285,
      282,
      280,
      278,
      275,
      273,
      271,
      269,
      267,
      265,
      263,
      261,
      259
    ], shg_table = [
      9,
      11,
      12,
      13,
      13,
      14,
      14,
      15,
      15,
      15,
      15,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24
    ];
    function filterGaussBlurRGBA(imageData, radius) {
      var pixels = imageData.data, width = imageData.width, height = imageData.height, x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, r_out_sum, g_out_sum, b_out_sum, a_out_sum, r_in_sum, g_in_sum, b_in_sum, a_in_sum, pr, pg, pb, pa, rbs, div = radius + radius + 1, widthMinus1 = width - 1, heightMinus1 = height - 1, radiusPlus1 = radius + 1, sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2, stackStart = new BlurStack(), stackEnd = null, stack = stackStart, stackIn = null, stackOut = null, mul_sum = mul_table[radius], shg_sum = shg_table[radius];
      for (i = 1; i < div; i++)
        stack = stack.next = new BlurStack(), i === radiusPlus1 && (stackEnd = stack);
      for (stack.next = stackStart, yw = yi = 0, y = 0; y < height; y++) {
        for (r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0, r_out_sum = radiusPlus1 * (pr = pixels[yi]), g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]), b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]), a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]), r_sum += sumFactor * pr, g_sum += sumFactor * pg, b_sum += sumFactor * pb, a_sum += sumFactor * pa, stack = stackStart, i = 0; i < radiusPlus1; i++)
          stack.r = pr, stack.g = pg, stack.b = pb, stack.a = pa, stack = stack.next;
        for (i = 1; i < radiusPlus1; i++)
          p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2), r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i), g_sum += (stack.g = pg = pixels[p + 1]) * rbs, b_sum += (stack.b = pb = pixels[p + 2]) * rbs, a_sum += (stack.a = pa = pixels[p + 3]) * rbs, r_in_sum += pr, g_in_sum += pg, b_in_sum += pb, a_in_sum += pa, stack = stack.next;
        for (stackIn = stackStart, stackOut = stackEnd, x = 0; x < width; x++)
          pixels[yi + 3] = pa = a_sum * mul_sum >> shg_sum, pa !== 0 ? (pa = 255 / pa, pixels[yi] = (r_sum * mul_sum >> shg_sum) * pa, pixels[yi + 1] = (g_sum * mul_sum >> shg_sum) * pa, pixels[yi + 2] = (b_sum * mul_sum >> shg_sum) * pa) : pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0, r_sum -= r_out_sum, g_sum -= g_out_sum, b_sum -= b_out_sum, a_sum -= a_out_sum, r_out_sum -= stackIn.r, g_out_sum -= stackIn.g, b_out_sum -= stackIn.b, a_out_sum -= stackIn.a, p = yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1) << 2, r_in_sum += stackIn.r = pixels[p], g_in_sum += stackIn.g = pixels[p + 1], b_in_sum += stackIn.b = pixels[p + 2], a_in_sum += stackIn.a = pixels[p + 3], r_sum += r_in_sum, g_sum += g_in_sum, b_sum += b_in_sum, a_sum += a_in_sum, stackIn = stackIn.next, r_out_sum += pr = stackOut.r, g_out_sum += pg = stackOut.g, b_out_sum += pb = stackOut.b, a_out_sum += pa = stackOut.a, r_in_sum -= pr, g_in_sum -= pg, b_in_sum -= pb, a_in_sum -= pa, stackOut = stackOut.next, yi += 4;
        yw += width;
      }
      for (x = 0; x < width; x++) {
        for (g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0, yi = x << 2, r_out_sum = radiusPlus1 * (pr = pixels[yi]), g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]), b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]), a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]), r_sum += sumFactor * pr, g_sum += sumFactor * pg, b_sum += sumFactor * pb, a_sum += sumFactor * pa, stack = stackStart, i = 0; i < radiusPlus1; i++)
          stack.r = pr, stack.g = pg, stack.b = pb, stack.a = pa, stack = stack.next;
        for (yp = width, i = 1; i <= radius; i++)
          yi = yp + x << 2, r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i), g_sum += (stack.g = pg = pixels[yi + 1]) * rbs, b_sum += (stack.b = pb = pixels[yi + 2]) * rbs, a_sum += (stack.a = pa = pixels[yi + 3]) * rbs, r_in_sum += pr, g_in_sum += pg, b_in_sum += pb, a_in_sum += pa, stack = stack.next, i < heightMinus1 && (yp += width);
        for (yi = x, stackIn = stackStart, stackOut = stackEnd, y = 0; y < height; y++)
          p = yi << 2, pixels[p + 3] = pa = a_sum * mul_sum >> shg_sum, pa > 0 ? (pa = 255 / pa, pixels[p] = (r_sum * mul_sum >> shg_sum) * pa, pixels[p + 1] = (g_sum * mul_sum >> shg_sum) * pa, pixels[p + 2] = (b_sum * mul_sum >> shg_sum) * pa) : pixels[p] = pixels[p + 1] = pixels[p + 2] = 0, r_sum -= r_out_sum, g_sum -= g_out_sum, b_sum -= b_out_sum, a_sum -= a_out_sum, r_out_sum -= stackIn.r, g_out_sum -= stackIn.g, b_out_sum -= stackIn.b, a_out_sum -= stackIn.a, p = x + ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width << 2, r_sum += r_in_sum += stackIn.r = pixels[p], g_sum += g_in_sum += stackIn.g = pixels[p + 1], b_sum += b_in_sum += stackIn.b = pixels[p + 2], a_sum += a_in_sum += stackIn.a = pixels[p + 3], stackIn = stackIn.next, r_out_sum += pr = stackOut.r, g_out_sum += pg = stackOut.g, b_out_sum += pb = stackOut.b, a_out_sum += pa = stackOut.a, r_in_sum -= pr, g_in_sum -= pg, b_in_sum -= pb, a_in_sum -= pa, stackOut = stackOut.next, yi += width;
      }
    }
    var Blur = function(imageData) {
      var radius = Math.round(this.blurRadius());
      radius > 0 && filterGaussBlurRGBA(imageData, radius);
    };
    exports.Blur = Blur;
    Factory_1.Factory.addGetterSetter(Node_1.Node, "blurRadius", 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
  }
});

// node_modules/konva/cmj/filters/Brighten.js
var require_Brighten = __commonJS({
  "node_modules/konva/cmj/filters/Brighten.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Brighten = void 0;
    var Factory_1 = require_Factory(), Node_1 = require_Node(), Validators_1 = require_Validators(), Brighten = function(imageData) {
      var brightness = this.brightness() * 255, data = imageData.data, len = data.length, i;
      for (i = 0; i < len; i += 4)
        data[i] += brightness, data[i + 1] += brightness, data[i + 2] += brightness;
    };
    exports.Brighten = Brighten;
    Factory_1.Factory.addGetterSetter(Node_1.Node, "brightness", 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
  }
});

// node_modules/konva/cmj/filters/Contrast.js
var require_Contrast = __commonJS({
  "node_modules/konva/cmj/filters/Contrast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Contrast = void 0;
    var Factory_1 = require_Factory(), Node_1 = require_Node(), Validators_1 = require_Validators(), Contrast = function(imageData) {
      var adjust = Math.pow((this.contrast() + 100) / 100, 2), data = imageData.data, nPixels = data.length, red = 150, green = 150, blue = 150, i;
      for (i = 0; i < nPixels; i += 4)
        red = data[i], green = data[i + 1], blue = data[i + 2], red /= 255, red -= 0.5, red *= adjust, red += 0.5, red *= 255, green /= 255, green -= 0.5, green *= adjust, green += 0.5, green *= 255, blue /= 255, blue -= 0.5, blue *= adjust, blue += 0.5, blue *= 255, red = red < 0 ? 0 : red > 255 ? 255 : red, green = green < 0 ? 0 : green > 255 ? 255 : green, blue = blue < 0 ? 0 : blue > 255 ? 255 : blue, data[i] = red, data[i + 1] = green, data[i + 2] = blue;
    };
    exports.Contrast = Contrast;
    Factory_1.Factory.addGetterSetter(Node_1.Node, "contrast", 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
  }
});

// node_modules/konva/cmj/filters/Emboss.js
var require_Emboss = __commonJS({
  "node_modules/konva/cmj/filters/Emboss.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Emboss = void 0;
    var Factory_1 = require_Factory(), Node_1 = require_Node(), Util_1 = require_Util(), Validators_1 = require_Validators(), Emboss = function(imageData) {
      var strength = this.embossStrength() * 10, greyLevel = this.embossWhiteLevel() * 255, direction = this.embossDirection(), blend = this.embossBlend(), dirY = 0, dirX = 0, data = imageData.data, w = imageData.width, h = imageData.height, w4 = w * 4, y = h;
      switch (direction) {
        case "top-left":
          dirY = -1, dirX = -1;
          break;
        case "top":
          dirY = -1, dirX = 0;
          break;
        case "top-right":
          dirY = -1, dirX = 1;
          break;
        case "right":
          dirY = 0, dirX = 1;
          break;
        case "bottom-right":
          dirY = 1, dirX = 1;
          break;
        case "bottom":
          dirY = 1, dirX = 0;
          break;
        case "bottom-left":
          dirY = 1, dirX = -1;
          break;
        case "left":
          dirY = 0, dirX = -1;
          break;
        default:
          Util_1.Util.error("Unknown emboss direction: " + direction);
      }
      do {
        var offsetY = (y - 1) * w4, otherY = dirY;
        y + otherY < 1 && (otherY = 0), y + otherY > h && (otherY = 0);
        var offsetYOther = (y - 1 + otherY) * w * 4, x = w;
        do {
          var offset = offsetY + (x - 1) * 4, otherX = dirX;
          x + otherX < 1 && (otherX = 0), x + otherX > w && (otherX = 0);
          var offsetOther = offsetYOther + (x - 1 + otherX) * 4, dR = data[offset] - data[offsetOther], dG = data[offset + 1] - data[offsetOther + 1], dB = data[offset + 2] - data[offsetOther + 2], dif = dR, absDif = dif > 0 ? dif : -dif, absG = dG > 0 ? dG : -dG, absB = dB > 0 ? dB : -dB;
          if (absG > absDif && (dif = dG), absB > absDif && (dif = dB), dif *= strength, blend) {
            var r = data[offset] + dif, g = data[offset + 1] + dif, b = data[offset + 2] + dif;
            data[offset] = r > 255 ? 255 : r < 0 ? 0 : r, data[offset + 1] = g > 255 ? 255 : g < 0 ? 0 : g, data[offset + 2] = b > 255 ? 255 : b < 0 ? 0 : b;
          } else {
            var grey = greyLevel - dif;
            grey < 0 ? grey = 0 : grey > 255 && (grey = 255), data[offset] = data[offset + 1] = data[offset + 2] = grey;
          }
        } while (--x);
      } while (--y);
    };
    exports.Emboss = Emboss;
    Factory_1.Factory.addGetterSetter(Node_1.Node, "embossStrength", 0.5, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
    Factory_1.Factory.addGetterSetter(Node_1.Node, "embossWhiteLevel", 0.5, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
    Factory_1.Factory.addGetterSetter(Node_1.Node, "embossDirection", "top-left", null, Factory_1.Factory.afterSetFilter);
    Factory_1.Factory.addGetterSetter(Node_1.Node, "embossBlend", !1, null, Factory_1.Factory.afterSetFilter);
  }
});

// node_modules/konva/cmj/filters/Enhance.js
var require_Enhance = __commonJS({
  "node_modules/konva/cmj/filters/Enhance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Enhance = void 0;
    var Factory_1 = require_Factory(), Node_1 = require_Node(), Validators_1 = require_Validators();
    function remap(fromValue, fromMin, fromMax, toMin, toMax) {
      var fromRange = fromMax - fromMin, toRange = toMax - toMin, toValue;
      return fromRange === 0 ? toMin + toRange / 2 : toRange === 0 ? toMin : (toValue = (fromValue - fromMin) / fromRange, toValue = toRange * toValue + toMin, toValue);
    }
    var Enhance = function(imageData) {
      var data = imageData.data, nSubPixels = data.length, rMin = data[0], rMax = rMin, r, gMin = data[1], gMax = gMin, g, bMin = data[2], bMax = bMin, b, i, enhanceAmount = this.enhance();
      if (enhanceAmount !== 0) {
        for (i = 0; i < nSubPixels; i += 4)
          r = data[i + 0], r < rMin ? rMin = r : r > rMax && (rMax = r), g = data[i + 1], g < gMin ? gMin = g : g > gMax && (gMax = g), b = data[i + 2], b < bMin ? bMin = b : b > bMax && (bMax = b);
        rMax === rMin && (rMax = 255, rMin = 0), gMax === gMin && (gMax = 255, gMin = 0), bMax === bMin && (bMax = 255, bMin = 0);
        var rMid, rGoalMax, rGoalMin, gMid, gGoalMax, gGoalMin, bMid, bGoalMax, bGoalMin;
        for (enhanceAmount > 0 ? (rGoalMax = rMax + enhanceAmount * (255 - rMax), rGoalMin = rMin - enhanceAmount * (rMin - 0), gGoalMax = gMax + enhanceAmount * (255 - gMax), gGoalMin = gMin - enhanceAmount * (gMin - 0), bGoalMax = bMax + enhanceAmount * (255 - bMax), bGoalMin = bMin - enhanceAmount * (bMin - 0)) : (rMid = (rMax + rMin) * 0.5, rGoalMax = rMax + enhanceAmount * (rMax - rMid), rGoalMin = rMin + enhanceAmount * (rMin - rMid), gMid = (gMax + gMin) * 0.5, gGoalMax = gMax + enhanceAmount * (gMax - gMid), gGoalMin = gMin + enhanceAmount * (gMin - gMid), bMid = (bMax + bMin) * 0.5, bGoalMax = bMax + enhanceAmount * (bMax - bMid), bGoalMin = bMin + enhanceAmount * (bMin - bMid)), i = 0; i < nSubPixels; i += 4)
          data[i + 0] = remap(data[i + 0], rMin, rMax, rGoalMin, rGoalMax), data[i + 1] = remap(data[i + 1], gMin, gMax, gGoalMin, gGoalMax), data[i + 2] = remap(data[i + 2], bMin, bMax, bGoalMin, bGoalMax);
      }
    };
    exports.Enhance = Enhance;
    Factory_1.Factory.addGetterSetter(Node_1.Node, "enhance", 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
  }
});

// node_modules/konva/cmj/filters/Grayscale.js
var require_Grayscale = __commonJS({
  "node_modules/konva/cmj/filters/Grayscale.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Grayscale = void 0;
    var Grayscale = function(imageData) {
      var data = imageData.data, len = data.length, i, brightness;
      for (i = 0; i < len; i += 4)
        brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2], data[i] = brightness, data[i + 1] = brightness, data[i + 2] = brightness;
    };
    exports.Grayscale = Grayscale;
  }
});

// node_modules/konva/cmj/filters/HSL.js
var require_HSL = __commonJS({
  "node_modules/konva/cmj/filters/HSL.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.HSL = void 0;
    var Factory_1 = require_Factory(), Node_1 = require_Node(), Validators_1 = require_Validators();
    Factory_1.Factory.addGetterSetter(Node_1.Node, "hue", 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
    Factory_1.Factory.addGetterSetter(Node_1.Node, "saturation", 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
    Factory_1.Factory.addGetterSetter(Node_1.Node, "luminance", 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
    var HSL = function(imageData) {
      var data = imageData.data, nPixels = data.length, v = 1, s = Math.pow(2, this.saturation()), h = Math.abs(this.hue() + 360) % 360, l = this.luminance() * 127, i, vsu = v * s * Math.cos(h * Math.PI / 180), vsw = v * s * Math.sin(h * Math.PI / 180), rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw, rg = 0.587 * v - 0.587 * vsu + 0.33 * vsw, rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw, gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw, gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw, gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw, br = 0.299 * v - 0.3 * vsu + 1.25 * vsw, bg = 0.587 * v - 0.586 * vsu - 1.05 * vsw, bb = 0.114 * v + 0.886 * vsu - 0.2 * vsw, r, g, b, a;
      for (i = 0; i < nPixels; i += 4)
        r = data[i + 0], g = data[i + 1], b = data[i + 2], a = data[i + 3], data[i + 0] = rr * r + rg * g + rb * b + l, data[i + 1] = gr * r + gg * g + gb * b + l, data[i + 2] = br * r + bg * g + bb * b + l, data[i + 3] = a;
    };
    exports.HSL = HSL;
  }
});

// node_modules/konva/cmj/filters/HSV.js
var require_HSV = __commonJS({
  "node_modules/konva/cmj/filters/HSV.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.HSV = void 0;
    var Factory_1 = require_Factory(), Node_1 = require_Node(), Validators_1 = require_Validators(), HSV = function(imageData) {
      var data = imageData.data, nPixels = data.length, v = Math.pow(2, this.value()), s = Math.pow(2, this.saturation()), h = Math.abs(this.hue() + 360) % 360, i, vsu = v * s * Math.cos(h * Math.PI / 180), vsw = v * s * Math.sin(h * Math.PI / 180), rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw, rg = 0.587 * v - 0.587 * vsu + 0.33 * vsw, rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw, gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw, gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw, gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw, br = 0.299 * v - 0.3 * vsu + 1.25 * vsw, bg = 0.587 * v - 0.586 * vsu - 1.05 * vsw, bb = 0.114 * v + 0.886 * vsu - 0.2 * vsw, r, g, b, a;
      for (i = 0; i < nPixels; i += 4)
        r = data[i + 0], g = data[i + 1], b = data[i + 2], a = data[i + 3], data[i + 0] = rr * r + rg * g + rb * b, data[i + 1] = gr * r + gg * g + gb * b, data[i + 2] = br * r + bg * g + bb * b, data[i + 3] = a;
    };
    exports.HSV = HSV;
    Factory_1.Factory.addGetterSetter(Node_1.Node, "hue", 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
    Factory_1.Factory.addGetterSetter(Node_1.Node, "saturation", 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
    Factory_1.Factory.addGetterSetter(Node_1.Node, "value", 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
  }
});

// node_modules/konva/cmj/filters/Invert.js
var require_Invert = __commonJS({
  "node_modules/konva/cmj/filters/Invert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Invert = void 0;
    var Invert = function(imageData) {
      var data = imageData.data, len = data.length, i;
      for (i = 0; i < len; i += 4)
        data[i] = 255 - data[i], data[i + 1] = 255 - data[i + 1], data[i + 2] = 255 - data[i + 2];
    };
    exports.Invert = Invert;
  }
});

// node_modules/konva/cmj/filters/Kaleidoscope.js
var require_Kaleidoscope = __commonJS({
  "node_modules/konva/cmj/filters/Kaleidoscope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Kaleidoscope = void 0;
    var Factory_1 = require_Factory(), Node_1 = require_Node(), Util_1 = require_Util(), Validators_1 = require_Validators(), ToPolar = function(src, dst, opt) {
      var srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2, i, x, y, r = 0, g = 0, b = 0, a = 0, rad, rMax = Math.sqrt(xMid * xMid + yMid * yMid);
      x = xSize - xMid, y = ySize - yMid, rad = Math.sqrt(x * x + y * y), rMax = rad > rMax ? rad : rMax;
      var rSize = ySize, tSize = xSize, radius, theta, conversion = 360 / tSize * Math.PI / 180, sin, cos;
      for (theta = 0; theta < tSize; theta += 1)
        for (sin = Math.sin(theta * conversion), cos = Math.cos(theta * conversion), radius = 0; radius < rSize; radius += 1)
          x = Math.floor(xMid + rMax * radius / rSize * cos), y = Math.floor(yMid + rMax * radius / rSize * sin), i = (y * xSize + x) * 4, r = srcPixels[i + 0], g = srcPixels[i + 1], b = srcPixels[i + 2], a = srcPixels[i + 3], i = (theta + radius * xSize) * 4, dstPixels[i + 0] = r, dstPixels[i + 1] = g, dstPixels[i + 2] = b, dstPixels[i + 3] = a;
    }, FromPolar = function(src, dst, opt) {
      var srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2, i, x, y, dx, dy, r = 0, g = 0, b = 0, a = 0, rad, rMax = Math.sqrt(xMid * xMid + yMid * yMid);
      x = xSize - xMid, y = ySize - yMid, rad = Math.sqrt(x * x + y * y), rMax = rad > rMax ? rad : rMax;
      var rSize = ySize, tSize = xSize, radius, theta, phaseShift = opt.polarRotation || 0, x1, y1;
      for (x = 0; x < xSize; x += 1)
        for (y = 0; y < ySize; y += 1)
          dx = x - xMid, dy = y - yMid, radius = Math.sqrt(dx * dx + dy * dy) * rSize / rMax, theta = (Math.atan2(dy, dx) * 180 / Math.PI + 360 + phaseShift) % 360, theta = theta * tSize / 360, x1 = Math.floor(theta), y1 = Math.floor(radius), i = (y1 * xSize + x1) * 4, r = srcPixels[i + 0], g = srcPixels[i + 1], b = srcPixels[i + 2], a = srcPixels[i + 3], i = (y * xSize + x) * 4, dstPixels[i + 0] = r, dstPixels[i + 1] = g, dstPixels[i + 2] = b, dstPixels[i + 3] = a;
    }, Kaleidoscope = function(imageData) {
      var xSize = imageData.width, ySize = imageData.height, x, y, xoff, i, r, g, b, a, srcPos, dstPos, power = Math.round(this.kaleidoscopePower()), angle = Math.round(this.kaleidoscopeAngle()), offset = Math.floor(xSize * (angle % 360) / 360);
      if (!(power < 1)) {
        var tempCanvas = Util_1.Util.createCanvasElement();
        tempCanvas.width = xSize, tempCanvas.height = ySize;
        var scratchData = tempCanvas.getContext("2d").getImageData(0, 0, xSize, ySize);
        Util_1.Util.releaseCanvas(tempCanvas), ToPolar(imageData, scratchData, {
          polarCenterX: xSize / 2,
          polarCenterY: ySize / 2
        });
        for (var minSectionSize = xSize / Math.pow(2, power); minSectionSize <= 8; )
          minSectionSize = minSectionSize * 2, power -= 1;
        minSectionSize = Math.ceil(minSectionSize);
        var sectionSize = minSectionSize, xStart = 0, xEnd = sectionSize, xDelta = 1;
        for (offset + minSectionSize > xSize && (xStart = sectionSize, xEnd = 0, xDelta = -1), y = 0; y < ySize; y += 1)
          for (x = xStart; x !== xEnd; x += xDelta)
            xoff = Math.round(x + offset) % xSize, srcPos = (xSize * y + xoff) * 4, r = scratchData.data[srcPos + 0], g = scratchData.data[srcPos + 1], b = scratchData.data[srcPos + 2], a = scratchData.data[srcPos + 3], dstPos = (xSize * y + x) * 4, scratchData.data[dstPos + 0] = r, scratchData.data[dstPos + 1] = g, scratchData.data[dstPos + 2] = b, scratchData.data[dstPos + 3] = a;
        for (y = 0; y < ySize; y += 1)
          for (sectionSize = Math.floor(minSectionSize), i = 0; i < power; i += 1) {
            for (x = 0; x < sectionSize + 1; x += 1)
              srcPos = (xSize * y + x) * 4, r = scratchData.data[srcPos + 0], g = scratchData.data[srcPos + 1], b = scratchData.data[srcPos + 2], a = scratchData.data[srcPos + 3], dstPos = (xSize * y + sectionSize * 2 - x - 1) * 4, scratchData.data[dstPos + 0] = r, scratchData.data[dstPos + 1] = g, scratchData.data[dstPos + 2] = b, scratchData.data[dstPos + 3] = a;
            sectionSize *= 2;
          }
        FromPolar(scratchData, imageData, { polarRotation: 0 });
      }
    };
    exports.Kaleidoscope = Kaleidoscope;
    Factory_1.Factory.addGetterSetter(Node_1.Node, "kaleidoscopePower", 2, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
    Factory_1.Factory.addGetterSetter(Node_1.Node, "kaleidoscopeAngle", 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
  }
});

// node_modules/konva/cmj/filters/Mask.js
var require_Mask = __commonJS({
  "node_modules/konva/cmj/filters/Mask.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Mask = void 0;
    var Factory_1 = require_Factory(), Node_1 = require_Node(), Validators_1 = require_Validators();
    function pixelAt(idata, x, y) {
      var idx = (y * idata.width + x) * 4, d = [];
      return d.push(idata.data[idx++], idata.data[idx++], idata.data[idx++], idata.data[idx++]), d;
    }
    function rgbDistance(p1, p2) {
      return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2) + Math.pow(p1[2] - p2[2], 2));
    }
    function rgbMean(pTab) {
      for (var m = [0, 0, 0], i = 0; i < pTab.length; i++)
        m[0] += pTab[i][0], m[1] += pTab[i][1], m[2] += pTab[i][2];
      return m[0] /= pTab.length, m[1] /= pTab.length, m[2] /= pTab.length, m;
    }
    function backgroundMask(idata, threshold) {
      var rgbv_no = pixelAt(idata, 0, 0), rgbv_ne = pixelAt(idata, idata.width - 1, 0), rgbv_so = pixelAt(idata, 0, idata.height - 1), rgbv_se = pixelAt(idata, idata.width - 1, idata.height - 1), thres = threshold || 10;
      if (rgbDistance(rgbv_no, rgbv_ne) < thres && rgbDistance(rgbv_ne, rgbv_se) < thres && rgbDistance(rgbv_se, rgbv_so) < thres && rgbDistance(rgbv_so, rgbv_no) < thres) {
        for (var mean = rgbMean([rgbv_ne, rgbv_no, rgbv_se, rgbv_so]), mask = [], i = 0; i < idata.width * idata.height; i++) {
          var d = rgbDistance(mean, [
            idata.data[i * 4],
            idata.data[i * 4 + 1],
            idata.data[i * 4 + 2]
          ]);
          mask[i] = d < thres ? 0 : 255;
        }
        return mask;
      }
    }
    function applyMask(idata, mask) {
      for (var i = 0; i < idata.width * idata.height; i++)
        idata.data[4 * i + 3] = mask[i];
    }
    function erodeMask(mask, sw, sh) {
      for (var weights = [1, 1, 1, 1, 0, 1, 1, 1, 1], side = Math.round(Math.sqrt(weights.length)), halfSide = Math.floor(side / 2), maskResult = [], y = 0; y < sh; y++)
        for (var x = 0; x < sw; x++) {
          for (var so = y * sw + x, a = 0, cy = 0; cy < side; cy++)
            for (var cx = 0; cx < side; cx++) {
              var scy = y + cy - halfSide, scx = x + cx - halfSide;
              if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                var srcOff = scy * sw + scx, wt = weights[cy * side + cx];
                a += mask[srcOff] * wt;
              }
            }
          maskResult[so] = a === 255 * 8 ? 255 : 0;
        }
      return maskResult;
    }
    function dilateMask(mask, sw, sh) {
      for (var weights = [1, 1, 1, 1, 1, 1, 1, 1, 1], side = Math.round(Math.sqrt(weights.length)), halfSide = Math.floor(side / 2), maskResult = [], y = 0; y < sh; y++)
        for (var x = 0; x < sw; x++) {
          for (var so = y * sw + x, a = 0, cy = 0; cy < side; cy++)
            for (var cx = 0; cx < side; cx++) {
              var scy = y + cy - halfSide, scx = x + cx - halfSide;
              if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                var srcOff = scy * sw + scx, wt = weights[cy * side + cx];
                a += mask[srcOff] * wt;
              }
            }
          maskResult[so] = a >= 255 * 4 ? 255 : 0;
        }
      return maskResult;
    }
    function smoothEdgeMask(mask, sw, sh) {
      for (var weights = [0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111, 0.1111111111111111], side = Math.round(Math.sqrt(weights.length)), halfSide = Math.floor(side / 2), maskResult = [], y = 0; y < sh; y++)
        for (var x = 0; x < sw; x++) {
          for (var so = y * sw + x, a = 0, cy = 0; cy < side; cy++)
            for (var cx = 0; cx < side; cx++) {
              var scy = y + cy - halfSide, scx = x + cx - halfSide;
              if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                var srcOff = scy * sw + scx, wt = weights[cy * side + cx];
                a += mask[srcOff] * wt;
              }
            }
          maskResult[so] = a;
        }
      return maskResult;
    }
    var Mask = function(imageData) {
      var threshold = this.threshold(), mask = backgroundMask(imageData, threshold);
      return mask && (mask = erodeMask(mask, imageData.width, imageData.height), mask = dilateMask(mask, imageData.width, imageData.height), mask = smoothEdgeMask(mask, imageData.width, imageData.height), applyMask(imageData, mask)), imageData;
    };
    exports.Mask = Mask;
    Factory_1.Factory.addGetterSetter(Node_1.Node, "threshold", 0, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
  }
});

// node_modules/konva/cmj/filters/Noise.js
var require_Noise = __commonJS({
  "node_modules/konva/cmj/filters/Noise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Noise = void 0;
    var Factory_1 = require_Factory(), Node_1 = require_Node(), Validators_1 = require_Validators(), Noise = function(imageData) {
      var amount = this.noise() * 255, data = imageData.data, nPixels = data.length, half = amount / 2, i;
      for (i = 0; i < nPixels; i += 4)
        data[i + 0] += half - 2 * half * Math.random(), data[i + 1] += half - 2 * half * Math.random(), data[i + 2] += half - 2 * half * Math.random();
    };
    exports.Noise = Noise;
    Factory_1.Factory.addGetterSetter(Node_1.Node, "noise", 0.2, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
  }
});

// node_modules/konva/cmj/filters/Pixelate.js
var require_Pixelate = __commonJS({
  "node_modules/konva/cmj/filters/Pixelate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Pixelate = void 0;
    var Factory_1 = require_Factory(), Util_1 = require_Util(), Node_1 = require_Node(), Validators_1 = require_Validators(), Pixelate = function(imageData) {
      var pixelSize = Math.ceil(this.pixelSize()), width = imageData.width, height = imageData.height, x, y, i, red, green, blue, alpha, nBinsX = Math.ceil(width / pixelSize), nBinsY = Math.ceil(height / pixelSize), xBinStart, xBinEnd, yBinStart, yBinEnd, xBin, yBin, pixelsInBin, data = imageData.data;
      if (pixelSize <= 0) {
        Util_1.Util.error("pixelSize value can not be <= 0");
        return;
      }
      for (xBin = 0; xBin < nBinsX; xBin += 1)
        for (yBin = 0; yBin < nBinsY; yBin += 1) {
          for (red = 0, green = 0, blue = 0, alpha = 0, xBinStart = xBin * pixelSize, xBinEnd = xBinStart + pixelSize, yBinStart = yBin * pixelSize, yBinEnd = yBinStart + pixelSize, pixelsInBin = 0, x = xBinStart; x < xBinEnd; x += 1)
            if (!(x >= width))
              for (y = yBinStart; y < yBinEnd; y += 1)
                y >= height || (i = (width * y + x) * 4, red += data[i + 0], green += data[i + 1], blue += data[i + 2], alpha += data[i + 3], pixelsInBin += 1);
          for (red = red / pixelsInBin, green = green / pixelsInBin, blue = blue / pixelsInBin, alpha = alpha / pixelsInBin, x = xBinStart; x < xBinEnd; x += 1)
            if (!(x >= width))
              for (y = yBinStart; y < yBinEnd; y += 1)
                y >= height || (i = (width * y + x) * 4, data[i + 0] = red, data[i + 1] = green, data[i + 2] = blue, data[i + 3] = alpha);
        }
    };
    exports.Pixelate = Pixelate;
    Factory_1.Factory.addGetterSetter(Node_1.Node, "pixelSize", 8, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
  }
});

// node_modules/konva/cmj/filters/Posterize.js
var require_Posterize = __commonJS({
  "node_modules/konva/cmj/filters/Posterize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Posterize = void 0;
    var Factory_1 = require_Factory(), Node_1 = require_Node(), Validators_1 = require_Validators(), Posterize = function(imageData) {
      var levels = Math.round(this.levels() * 254) + 1, data = imageData.data, len = data.length, scale = 255 / levels, i;
      for (i = 0; i < len; i += 1)
        data[i] = Math.floor(data[i] / scale) * scale;
    };
    exports.Posterize = Posterize;
    Factory_1.Factory.addGetterSetter(Node_1.Node, "levels", 0.5, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
  }
});

// node_modules/konva/cmj/filters/RGB.js
var require_RGB = __commonJS({
  "node_modules/konva/cmj/filters/RGB.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.RGB = void 0;
    var Factory_1 = require_Factory(), Node_1 = require_Node(), Validators_1 = require_Validators(), RGB = function(imageData) {
      var data = imageData.data, nPixels = data.length, red = this.red(), green = this.green(), blue = this.blue(), i, brightness;
      for (i = 0; i < nPixels; i += 4)
        brightness = (0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2]) / 255, data[i] = brightness * red, data[i + 1] = brightness * green, data[i + 2] = brightness * blue, data[i + 3] = data[i + 3];
    };
    exports.RGB = RGB;
    Factory_1.Factory.addGetterSetter(Node_1.Node, "red", 0, function(val) {
      return this._filterUpToDate = !1, val > 255 ? 255 : val < 0 ? 0 : Math.round(val);
    });
    Factory_1.Factory.addGetterSetter(Node_1.Node, "green", 0, function(val) {
      return this._filterUpToDate = !1, val > 255 ? 255 : val < 0 ? 0 : Math.round(val);
    });
    Factory_1.Factory.addGetterSetter(Node_1.Node, "blue", 0, Validators_1.RGBComponent, Factory_1.Factory.afterSetFilter);
  }
});

// node_modules/konva/cmj/filters/RGBA.js
var require_RGBA = __commonJS({
  "node_modules/konva/cmj/filters/RGBA.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.RGBA = void 0;
    var Factory_1 = require_Factory(), Node_1 = require_Node(), Validators_1 = require_Validators(), RGBA = function(imageData) {
      var data = imageData.data, nPixels = data.length, red = this.red(), green = this.green(), blue = this.blue(), alpha = this.alpha(), i, ia;
      for (i = 0; i < nPixels; i += 4)
        ia = 1 - alpha, data[i] = red * alpha + data[i] * ia, data[i + 1] = green * alpha + data[i + 1] * ia, data[i + 2] = blue * alpha + data[i + 2] * ia;
    };
    exports.RGBA = RGBA;
    Factory_1.Factory.addGetterSetter(Node_1.Node, "red", 0, function(val) {
      return this._filterUpToDate = !1, val > 255 ? 255 : val < 0 ? 0 : Math.round(val);
    });
    Factory_1.Factory.addGetterSetter(Node_1.Node, "green", 0, function(val) {
      return this._filterUpToDate = !1, val > 255 ? 255 : val < 0 ? 0 : Math.round(val);
    });
    Factory_1.Factory.addGetterSetter(Node_1.Node, "blue", 0, Validators_1.RGBComponent, Factory_1.Factory.afterSetFilter);
    Factory_1.Factory.addGetterSetter(Node_1.Node, "alpha", 1, function(val) {
      return this._filterUpToDate = !1, val > 1 ? 1 : val < 0 ? 0 : val;
    });
  }
});

// node_modules/konva/cmj/filters/Sepia.js
var require_Sepia = __commonJS({
  "node_modules/konva/cmj/filters/Sepia.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Sepia = void 0;
    var Sepia = function(imageData) {
      var data = imageData.data, nPixels = data.length, i, r, g, b;
      for (i = 0; i < nPixels; i += 4)
        r = data[i + 0], g = data[i + 1], b = data[i + 2], data[i + 0] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189), data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168), data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
    };
    exports.Sepia = Sepia;
  }
});

// node_modules/konva/cmj/filters/Solarize.js
var require_Solarize = __commonJS({
  "node_modules/konva/cmj/filters/Solarize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Solarize = void 0;
    var Solarize = function(imageData) {
      var data = imageData.data, w = imageData.width, h = imageData.height, w4 = w * 4, y = h;
      do {
        var offsetY = (y - 1) * w4, x = w;
        do {
          var offset = offsetY + (x - 1) * 4, r = data[offset], g = data[offset + 1], b = data[offset + 2];
          r > 127 && (r = 255 - r), g > 127 && (g = 255 - g), b > 127 && (b = 255 - b), data[offset] = r, data[offset + 1] = g, data[offset + 2] = b;
        } while (--x);
      } while (--y);
    };
    exports.Solarize = Solarize;
  }
});

// node_modules/konva/cmj/filters/Threshold.js
var require_Threshold = __commonJS({
  "node_modules/konva/cmj/filters/Threshold.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Threshold = void 0;
    var Factory_1 = require_Factory(), Node_1 = require_Node(), Validators_1 = require_Validators(), Threshold = function(imageData) {
      var level = this.threshold() * 255, data = imageData.data, len = data.length, i;
      for (i = 0; i < len; i += 1)
        data[i] = data[i] < level ? 0 : 255;
    };
    exports.Threshold = Threshold;
    Factory_1.Factory.addGetterSetter(Node_1.Node, "threshold", 0.5, (0, Validators_1.getNumberValidator)(), Factory_1.Factory.afterSetFilter);
  }
});

// node_modules/konva/cmj/_FullInternals.js
var require_FullInternals = __commonJS({
  "node_modules/konva/cmj/_FullInternals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Konva = void 0;
    var _CoreInternals_1 = require_CoreInternals(), Arc_1 = require_Arc(), Arrow_1 = require_Arrow(), Circle_1 = require_Circle(), Ellipse_1 = require_Ellipse(), Image_1 = require_Image(), Label_1 = require_Label2(), Line_1 = require_Line2(), Path_1 = require_Path(), Rect_1 = require_Rect(), RegularPolygon_1 = require_RegularPolygon(), Ring_1 = require_Ring(), Sprite_1 = require_Sprite(), Star_1 = require_Star(), Text_1 = require_Text2(), TextPath_1 = require_TextPath(), Transformer_1 = require_Transformer(), Wedge_1 = require_Wedge(), Blur_1 = require_Blur(), Brighten_1 = require_Brighten(), Contrast_1 = require_Contrast(), Emboss_1 = require_Emboss(), Enhance_1 = require_Enhance(), Grayscale_1 = require_Grayscale(), HSL_1 = require_HSL(), HSV_1 = require_HSV(), Invert_1 = require_Invert(), Kaleidoscope_1 = require_Kaleidoscope(), Mask_1 = require_Mask(), Noise_1 = require_Noise(), Pixelate_1 = require_Pixelate(), Posterize_1 = require_Posterize(), RGB_1 = require_RGB(), RGBA_1 = require_RGBA(), Sepia_1 = require_Sepia(), Solarize_1 = require_Solarize(), Threshold_1 = require_Threshold();
    exports.Konva = _CoreInternals_1.Konva.Util._assign(_CoreInternals_1.Konva, {
      Arc: Arc_1.Arc,
      Arrow: Arrow_1.Arrow,
      Circle: Circle_1.Circle,
      Ellipse: Ellipse_1.Ellipse,
      Image: Image_1.Image,
      Label: Label_1.Label,
      Tag: Label_1.Tag,
      Line: Line_1.Line,
      Path: Path_1.Path,
      Rect: Rect_1.Rect,
      RegularPolygon: RegularPolygon_1.RegularPolygon,
      Ring: Ring_1.Ring,
      Sprite: Sprite_1.Sprite,
      Star: Star_1.Star,
      Text: Text_1.Text,
      TextPath: TextPath_1.TextPath,
      Transformer: Transformer_1.Transformer,
      Wedge: Wedge_1.Wedge,
      Filters: {
        Blur: Blur_1.Blur,
        Brighten: Brighten_1.Brighten,
        Contrast: Contrast_1.Contrast,
        Emboss: Emboss_1.Emboss,
        Enhance: Enhance_1.Enhance,
        Grayscale: Grayscale_1.Grayscale,
        HSL: HSL_1.HSL,
        HSV: HSV_1.HSV,
        Invert: Invert_1.Invert,
        Kaleidoscope: Kaleidoscope_1.Kaleidoscope,
        Mask: Mask_1.Mask,
        Noise: Noise_1.Noise,
        Pixelate: Pixelate_1.Pixelate,
        Posterize: Posterize_1.Posterize,
        RGB: RGB_1.RGB,
        RGBA: RGBA_1.RGBA,
        Sepia: Sepia_1.Sepia,
        Solarize: Solarize_1.Solarize,
        Threshold: Threshold_1.Threshold
      }
    });
  }
});

// node_modules/konva/cmj/index-node.js
var require_index_node = __commonJS({
  "node_modules/konva/cmj/index-node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var _FullInternals_1 = require_FullInternals(), Canvas2 = require("canvas"), canvas = Canvas2.default || Canvas2;
    global.DOMMatrix = canvas.DOMMatrix;
    var isNode = typeof global.document > "u";
    isNode && (_FullInternals_1.Konva.Util.createCanvasElement = () => {
      let node = canvas.createCanvas(300, 300);
      return node.style || (node.style = {}), node;
    }, _FullInternals_1.Konva.Util.createImageElement = () => new canvas.Image());
    exports.default = _FullInternals_1.Konva;
  }
});

// node_modules/konva/lib/Global.js
var Global_exports = {};
__export(Global_exports, {
  Konva: () => Konva,
  _registerNode: () => _registerNode,
  glob: () => glob
});
function detectBrowser() {
  return typeof window < "u" && ({}.toString.call(window) === "[object Window]" || {}.toString.call(window) === "[object global]");
}
var PI_OVER_180, glob, Konva, _registerNode, init_Global = __esm({
  "node_modules/konva/lib/Global.js"() {
    PI_OVER_180 = Math.PI / 180;
    glob = typeof global < "u" ? global : typeof window < "u" ? window : typeof WorkerGlobalScope < "u" ? self : {}, Konva = {
      _global: glob,
      version: "8.3.14",
      isBrowser: detectBrowser(),
      isUnminified: /param/.test(function(param) {
      }.toString()),
      dblClickWindow: 400,
      getAngle(angle) {
        return Konva.angleDeg ? angle * PI_OVER_180 : angle;
      },
      enableTrace: !1,
      pointerEventsEnabled: !0,
      autoDrawEnabled: !0,
      hitOnDragEnabled: !1,
      capturePointerEventsEnabled: !1,
      _mouseListenClick: !1,
      _touchListenClick: !1,
      _pointerListenClick: !1,
      _mouseInDblClickWindow: !1,
      _touchInDblClickWindow: !1,
      _pointerInDblClickWindow: !1,
      _mouseDblClickPointerId: null,
      _touchDblClickPointerId: null,
      _pointerDblClickPointerId: null,
      pixelRatio: typeof window < "u" && window.devicePixelRatio || 1,
      dragDistance: 3,
      angleDeg: !0,
      showWarnings: !0,
      dragButtons: [0, 1],
      isDragging() {
        return Konva.DD.isDragging;
      },
      isDragReady() {
        return !!Konva.DD.node;
      },
      releaseCanvasOnDestroy: !0,
      document: glob.document,
      _injectGlobal(Konva3) {
        glob.Konva = Konva3;
      }
    }, _registerNode = (NodeClass) => {
      Konva[NodeClass.prototype.getClassName()] = NodeClass;
    };
    Konva._injectGlobal(Konva);
  }
});

// node_modules/konva/lib/Util.js
var Transform, OBJECT_ARRAY, OBJECT_NUMBER, OBJECT_STRING, OBJECT_BOOLEAN, PI_OVER_DEG180, DEG180_OVER_PI, HASH, EMPTY_STRING, ZERO, KONVA_WARNING, KONVA_ERROR, RGB_PAREN, COLORS, RGB_REGEX, animQueue, req, Util, init_Util = __esm({
  "node_modules/konva/lib/Util.js"() {
    init_Global();
    Transform = class {
      constructor(m = [1, 0, 0, 1, 0, 0]) {
        this.dirty = !1, this.m = m && m.slice() || [1, 0, 0, 1, 0, 0];
      }
      reset() {
        this.m[0] = 1, this.m[1] = 0, this.m[2] = 0, this.m[3] = 1, this.m[4] = 0, this.m[5] = 0;
      }
      copy() {
        return new Transform(this.m);
      }
      copyInto(tr) {
        tr.m[0] = this.m[0], tr.m[1] = this.m[1], tr.m[2] = this.m[2], tr.m[3] = this.m[3], tr.m[4] = this.m[4], tr.m[5] = this.m[5];
      }
      point(point) {
        var m = this.m;
        return {
          x: m[0] * point.x + m[2] * point.y + m[4],
          y: m[1] * point.x + m[3] * point.y + m[5]
        };
      }
      translate(x, y) {
        return this.m[4] += this.m[0] * x + this.m[2] * y, this.m[5] += this.m[1] * x + this.m[3] * y, this;
      }
      scale(sx, sy) {
        return this.m[0] *= sx, this.m[1] *= sx, this.m[2] *= sy, this.m[3] *= sy, this;
      }
      rotate(rad) {
        var c = Math.cos(rad), s = Math.sin(rad), m11 = this.m[0] * c + this.m[2] * s, m12 = this.m[1] * c + this.m[3] * s, m21 = this.m[0] * -s + this.m[2] * c, m22 = this.m[1] * -s + this.m[3] * c;
        return this.m[0] = m11, this.m[1] = m12, this.m[2] = m21, this.m[3] = m22, this;
      }
      getTranslation() {
        return {
          x: this.m[4],
          y: this.m[5]
        };
      }
      skew(sx, sy) {
        var m11 = this.m[0] + this.m[2] * sy, m12 = this.m[1] + this.m[3] * sy, m21 = this.m[2] + this.m[0] * sx, m22 = this.m[3] + this.m[1] * sx;
        return this.m[0] = m11, this.m[1] = m12, this.m[2] = m21, this.m[3] = m22, this;
      }
      multiply(matrix) {
        var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1], m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1], m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3], m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3], dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4], dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];
        return this.m[0] = m11, this.m[1] = m12, this.m[2] = m21, this.m[3] = m22, this.m[4] = dx, this.m[5] = dy, this;
      }
      invert() {
        var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]), m0 = this.m[3] * d, m1 = -this.m[1] * d, m2 = -this.m[2] * d, m3 = this.m[0] * d, m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]), m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
        return this.m[0] = m0, this.m[1] = m1, this.m[2] = m2, this.m[3] = m3, this.m[4] = m4, this.m[5] = m5, this;
      }
      getMatrix() {
        return this.m;
      }
      decompose() {
        var a = this.m[0], b = this.m[1], c = this.m[2], d = this.m[3], e = this.m[4], f = this.m[5], delta = a * d - b * c;
        let result = {
          x: e,
          y: f,
          rotation: 0,
          scaleX: 0,
          scaleY: 0,
          skewX: 0,
          skewY: 0
        };
        if (a != 0 || b != 0) {
          var r = Math.sqrt(a * a + b * b);
          result.rotation = b > 0 ? Math.acos(a / r) : -Math.acos(a / r), result.scaleX = r, result.scaleY = delta / r, result.skewX = (a * c + b * d) / delta, result.skewY = 0;
        } else if (c != 0 || d != 0) {
          var s = Math.sqrt(c * c + d * d);
          result.rotation = Math.PI / 2 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s)), result.scaleX = delta / s, result.scaleY = s, result.skewX = 0, result.skewY = (a * c + b * d) / delta;
        }
        return result.rotation = Util._getRotation(result.rotation), result;
      }
    }, OBJECT_ARRAY = "[object Array]", OBJECT_NUMBER = "[object Number]", OBJECT_STRING = "[object String]", OBJECT_BOOLEAN = "[object Boolean]", PI_OVER_DEG180 = Math.PI / 180, DEG180_OVER_PI = 180 / Math.PI, HASH = "#", EMPTY_STRING = "", ZERO = "0", KONVA_WARNING = "Konva warning: ", KONVA_ERROR = "Konva error: ", RGB_PAREN = "rgb(", COLORS = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 132, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 255, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 203],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [119, 128, 144],
      slategrey: [119, 128, 144],
      snow: [255, 255, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      transparent: [255, 255, 255, 0],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 5]
    }, RGB_REGEX = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/, animQueue = [], req = typeof requestAnimationFrame < "u" && requestAnimationFrame || function(f) {
      setTimeout(f, 60);
    }, Util = {
      _isElement(obj) {
        return !!(obj && obj.nodeType == 1);
      },
      _isFunction(obj) {
        return !!(obj && obj.constructor && obj.call && obj.apply);
      },
      _isPlainObject(obj) {
        return !!obj && obj.constructor === Object;
      },
      _isArray(obj) {
        return Object.prototype.toString.call(obj) === OBJECT_ARRAY;
      },
      _isNumber(obj) {
        return Object.prototype.toString.call(obj) === OBJECT_NUMBER && !isNaN(obj) && isFinite(obj);
      },
      _isString(obj) {
        return Object.prototype.toString.call(obj) === OBJECT_STRING;
      },
      _isBoolean(obj) {
        return Object.prototype.toString.call(obj) === OBJECT_BOOLEAN;
      },
      isObject(val) {
        return val instanceof Object;
      },
      isValidSelector(selector) {
        if (typeof selector != "string")
          return !1;
        var firstChar = selector[0];
        return firstChar === "#" || firstChar === "." || firstChar === firstChar.toUpperCase();
      },
      _sign(number) {
        return number === 0 || number > 0 ? 1 : -1;
      },
      requestAnimFrame(callback) {
        animQueue.push(callback), animQueue.length === 1 && req(function() {
          let queue = animQueue;
          animQueue = [], queue.forEach(function(cb) {
            cb();
          });
        });
      },
      createCanvasElement() {
        var canvas = document.createElement("canvas");
        try {
          canvas.style = canvas.style || {};
        } catch {
        }
        return canvas;
      },
      createImageElement() {
        return document.createElement("img");
      },
      _isInDocument(el) {
        for (; el = el.parentNode; )
          if (el == document)
            return !0;
        return !1;
      },
      _urlToImage(url, callback) {
        var imageObj = Util.createImageElement();
        imageObj.onload = function() {
          callback(imageObj);
        }, imageObj.src = url;
      },
      _rgbToHex(r, g, b) {
        return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
      },
      _hexToRgb(hex) {
        hex = hex.replace(HASH, EMPTY_STRING);
        var bigint = parseInt(hex, 16);
        return {
          r: bigint >> 16 & 255,
          g: bigint >> 8 & 255,
          b: bigint & 255
        };
      },
      getRandomColor() {
        for (var randColor = (Math.random() * 16777215 << 0).toString(16); randColor.length < 6; )
          randColor = ZERO + randColor;
        return HASH + randColor;
      },
      getRGB(color) {
        var rgb;
        return color in COLORS ? (rgb = COLORS[color], {
          r: rgb[0],
          g: rgb[1],
          b: rgb[2]
        }) : color[0] === HASH ? this._hexToRgb(color.substring(1)) : color.substr(0, 4) === RGB_PAREN ? (rgb = RGB_REGEX.exec(color.replace(/ /g, "")), {
          r: parseInt(rgb[1], 10),
          g: parseInt(rgb[2], 10),
          b: parseInt(rgb[3], 10)
        }) : {
          r: 0,
          g: 0,
          b: 0
        };
      },
      colorToRGBA(str) {
        return str = str || "black", Util._namedColorToRBA(str) || Util._hex3ColorToRGBA(str) || Util._hex6ColorToRGBA(str) || Util._rgbColorToRGBA(str) || Util._rgbaColorToRGBA(str) || Util._hslColorToRGBA(str);
      },
      _namedColorToRBA(str) {
        var c = COLORS[str.toLowerCase()];
        return c ? {
          r: c[0],
          g: c[1],
          b: c[2],
          a: 1
        } : null;
      },
      _rgbColorToRGBA(str) {
        if (str.indexOf("rgb(") === 0) {
          str = str.match(/rgb\(([^)]+)\)/)[1];
          var parts = str.split(/ *, */).map(Number);
          return {
            r: parts[0],
            g: parts[1],
            b: parts[2],
            a: 1
          };
        }
      },
      _rgbaColorToRGBA(str) {
        if (str.indexOf("rgba(") === 0) {
          str = str.match(/rgba\(([^)]+)\)/)[1];
          var parts = str.split(/ *, */).map((n, index) => n.slice(-1) === "%" ? index === 3 ? parseInt(n) / 100 : parseInt(n) / 100 * 255 : Number(n));
          return {
            r: parts[0],
            g: parts[1],
            b: parts[2],
            a: parts[3]
          };
        }
      },
      _hex6ColorToRGBA(str) {
        if (str[0] === "#" && str.length === 7)
          return {
            r: parseInt(str.slice(1, 3), 16),
            g: parseInt(str.slice(3, 5), 16),
            b: parseInt(str.slice(5, 7), 16),
            a: 1
          };
      },
      _hex3ColorToRGBA(str) {
        if (str[0] === "#" && str.length === 4)
          return {
            r: parseInt(str[1] + str[1], 16),
            g: parseInt(str[2] + str[2], 16),
            b: parseInt(str[3] + str[3], 16),
            a: 1
          };
      },
      _hslColorToRGBA(str) {
        if (/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.test(str)) {
          let [_, ...hsl] = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(str), h = Number(hsl[0]) / 360, s = Number(hsl[1]) / 100, l = Number(hsl[2]) / 100, t2, t3, val;
          if (s === 0)
            return val = l * 255, {
              r: Math.round(val),
              g: Math.round(val),
              b: Math.round(val),
              a: 1
            };
          l < 0.5 ? t2 = l * (1 + s) : t2 = l + s - l * s;
          let t1 = 2 * l - t2, rgb = [0, 0, 0];
          for (let i = 0; i < 3; i++)
            t3 = h + 1 / 3 * -(i - 1), t3 < 0 && t3++, t3 > 1 && t3--, 6 * t3 < 1 ? val = t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? val = t2 : 3 * t3 < 2 ? val = t1 + (t2 - t1) * (2 / 3 - t3) * 6 : val = t1, rgb[i] = val * 255;
          return {
            r: Math.round(rgb[0]),
            g: Math.round(rgb[1]),
            b: Math.round(rgb[2]),
            a: 1
          };
        }
      },
      haveIntersection(r1, r2) {
        return !(r2.x > r1.x + r1.width || r2.x + r2.width < r1.x || r2.y > r1.y + r1.height || r2.y + r2.height < r1.y);
      },
      cloneObject(obj) {
        var retObj = {};
        for (var key in obj)
          this._isPlainObject(obj[key]) ? retObj[key] = this.cloneObject(obj[key]) : this._isArray(obj[key]) ? retObj[key] = this.cloneArray(obj[key]) : retObj[key] = obj[key];
        return retObj;
      },
      cloneArray(arr) {
        return arr.slice(0);
      },
      degToRad(deg) {
        return deg * PI_OVER_DEG180;
      },
      radToDeg(rad) {
        return rad * DEG180_OVER_PI;
      },
      _degToRad(deg) {
        return Util.warn("Util._degToRad is removed. Please use public Util.degToRad instead."), Util.degToRad(deg);
      },
      _radToDeg(rad) {
        return Util.warn("Util._radToDeg is removed. Please use public Util.radToDeg instead."), Util.radToDeg(rad);
      },
      _getRotation(radians) {
        return Konva.angleDeg ? Util.radToDeg(radians) : radians;
      },
      _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      },
      throw(str) {
        throw new Error(KONVA_ERROR + str);
      },
      error(str) {
        console.error(KONVA_ERROR + str);
      },
      warn(str) {
        !Konva.showWarnings || console.warn(KONVA_WARNING + str);
      },
      each(obj, func) {
        for (var key in obj)
          func(key, obj[key]);
      },
      _inRange(val, left, right) {
        return left <= val && val < right;
      },
      _getProjectionToSegment(x1, y1, x2, y2, x3, y3) {
        var x, y, dist, pd2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
        if (pd2 == 0)
          x = x1, y = y1, dist = (x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2);
        else {
          var u = ((x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1)) / pd2;
          u < 0 ? (x = x1, y = y1, dist = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3)) : u > 1 ? (x = x2, y = y2, dist = (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3)) : (x = x1 + u * (x2 - x1), y = y1 + u * (y2 - y1), dist = (x - x3) * (x - x3) + (y - y3) * (y - y3));
        }
        return [x, y, dist];
      },
      _getProjectionToLine(pt, line, isClosed) {
        var pc = Util.cloneObject(pt), dist = Number.MAX_VALUE;
        return line.forEach(function(p1, i) {
          if (!(!isClosed && i === line.length - 1)) {
            var p2 = line[(i + 1) % line.length], proj = Util._getProjectionToSegment(p1.x, p1.y, p2.x, p2.y, pt.x, pt.y), px = proj[0], py = proj[1], pdist = proj[2];
            pdist < dist && (pc.x = px, pc.y = py, dist = pdist);
          }
        }), pc;
      },
      _prepareArrayForTween(startArray, endArray, isClosed) {
        var n, start = [], end = [];
        if (startArray.length > endArray.length) {
          var temp = endArray;
          endArray = startArray, startArray = temp;
        }
        for (n = 0; n < startArray.length; n += 2)
          start.push({
            x: startArray[n],
            y: startArray[n + 1]
          });
        for (n = 0; n < endArray.length; n += 2)
          end.push({
            x: endArray[n],
            y: endArray[n + 1]
          });
        var newStart = [];
        return end.forEach(function(point) {
          var pr = Util._getProjectionToLine(point, start, isClosed);
          newStart.push(pr.x), newStart.push(pr.y);
        }), newStart;
      },
      _prepareToStringify(obj) {
        var desc;
        obj.visitedByCircularReferenceRemoval = !0;
        for (var key in obj)
          if (!!(obj.hasOwnProperty(key) && obj[key] && typeof obj[key] == "object")) {
            if (desc = Object.getOwnPropertyDescriptor(obj, key), obj[key].visitedByCircularReferenceRemoval || Util._isElement(obj[key]))
              if (desc.configurable)
                delete obj[key];
              else
                return null;
            else if (Util._prepareToStringify(obj[key]) === null)
              if (desc.configurable)
                delete obj[key];
              else
                return null;
          }
        return delete obj.visitedByCircularReferenceRemoval, obj;
      },
      _assign(target, source) {
        for (var key in source)
          target[key] = source[key];
        return target;
      },
      _getFirstPointerId(evt) {
        return evt.touches ? evt.changedTouches[0].identifier : evt.pointerId || 999;
      },
      releaseCanvas(...canvases) {
        !Konva.releaseCanvasOnDestroy || canvases.forEach((c) => {
          c.width = 0, c.height = 0;
        });
      }
    };
  }
});

// node_modules/konva/lib/Validators.js
function _formatValue(val) {
  return Util._isString(val) ? '"' + val + '"' : Object.prototype.toString.call(val) === "[object Number]" || Util._isBoolean(val) ? val : Object.prototype.toString.call(val);
}
function getNumberValidator() {
  if (Konva.isUnminified)
    return function(val, attr) {
      return Util._isNumber(val) || Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a number.'), val;
    };
}
function getNumberOrAutoValidator() {
  if (Konva.isUnminified)
    return function(val, attr) {
      var isNumber = Util._isNumber(val), isAuto = val === "auto";
      return isNumber || isAuto || Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a number or "auto".'), val;
    };
}
function getStringValidator() {
  if (Konva.isUnminified)
    return function(val, attr) {
      return Util._isString(val) || Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a string.'), val;
    };
}
function getStringOrGradientValidator() {
  if (Konva.isUnminified)
    return function(val, attr) {
      let isString = Util._isString(val), isGradient = Object.prototype.toString.call(val) === "[object CanvasGradient]" || val && val.addColorStop;
      return isString || isGradient || Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a string or a native gradient.'), val;
    };
}
function getBooleanValidator() {
  if (Konva.isUnminified)
    return function(val, attr) {
      var isBool = val === !0 || val === !1;
      return isBool || Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be a boolean.'), val;
    };
}
function getComponentValidator(components2) {
  if (Konva.isUnminified)
    return function(val, attr) {
      return val == null || Util.isObject(val) || Util.warn(_formatValue(val) + ' is a not valid value for "' + attr + '" attribute. The value should be an object with properties ' + components2), val;
    };
}
var init_Validators = __esm({
  "node_modules/konva/lib/Validators.js"() {
    init_Global();
    init_Util();
  }
});

// node_modules/konva/lib/Factory.js
var GET, SET, Factory, init_Factory = __esm({
  "node_modules/konva/lib/Factory.js"() {
    init_Util();
    init_Validators();
    GET = "get", SET = "set", Factory = {
      addGetterSetter(constructor, attr, def, validator, after) {
        Factory.addGetter(constructor, attr, def), Factory.addSetter(constructor, attr, validator, after), Factory.addOverloadedGetterSetter(constructor, attr);
      },
      addGetter(constructor, attr, def) {
        var method = GET + Util._capitalize(attr);
        constructor.prototype[method] = constructor.prototype[method] || function() {
          var val = this.attrs[attr];
          return val === void 0 ? def : val;
        };
      },
      addSetter(constructor, attr, validator, after) {
        var method = SET + Util._capitalize(attr);
        constructor.prototype[method] || Factory.overWriteSetter(constructor, attr, validator, after);
      },
      overWriteSetter(constructor, attr, validator, after) {
        var method = SET + Util._capitalize(attr);
        constructor.prototype[method] = function(val) {
          return validator && val !== void 0 && val !== null && (val = validator.call(this, val, attr)), this._setAttr(attr, val), after && after.call(this), this;
        };
      },
      addComponentsGetterSetter(constructor, attr, components2, validator, after) {
        var len = components2.length, capitalize = Util._capitalize, getter = GET + capitalize(attr), setter = SET + capitalize(attr), n, component;
        constructor.prototype[getter] = function() {
          var ret = {};
          for (n = 0; n < len; n++)
            component = components2[n], ret[component] = this.getAttr(attr + capitalize(component));
          return ret;
        };
        var basicValidator = getComponentValidator(components2);
        constructor.prototype[setter] = function(val) {
          var oldVal = this.attrs[attr], key;
          validator && (val = validator.call(this, val)), basicValidator && basicValidator.call(this, val, attr);
          for (key in val)
            !val.hasOwnProperty(key) || this._setAttr(attr + capitalize(key), val[key]);
          return val || components2.forEach((component2) => {
            this._setAttr(attr + capitalize(component2), void 0);
          }), this._fireChangeEvent(attr, oldVal, val), after && after.call(this), this;
        }, Factory.addOverloadedGetterSetter(constructor, attr);
      },
      addOverloadedGetterSetter(constructor, attr) {
        var capitalizedAttr = Util._capitalize(attr), setter = SET + capitalizedAttr, getter = GET + capitalizedAttr;
        constructor.prototype[attr] = function() {
          return arguments.length ? (this[setter](arguments[0]), this) : this[getter]();
        };
      },
      addDeprecatedGetterSetter(constructor, attr, def, validator) {
        Util.error("Adding deprecated " + attr);
        var method = GET + Util._capitalize(attr), message = attr + " property is deprecated and will be removed soon. Look at Konva change log for more information.";
        constructor.prototype[method] = function() {
          Util.error(message);
          var val = this.attrs[attr];
          return val === void 0 ? def : val;
        }, Factory.addSetter(constructor, attr, validator, function() {
          Util.error(message);
        }), Factory.addOverloadedGetterSetter(constructor, attr);
      },
      backCompat(constructor, methods) {
        Util.each(methods, function(oldMethodName, newMethodName) {
          var method = constructor.prototype[newMethodName], oldGetter = GET + Util._capitalize(oldMethodName), oldSetter = SET + Util._capitalize(oldMethodName);
          function deprecated() {
            method.apply(this, arguments), Util.error('"' + oldMethodName + '" method is deprecated and will be removed soon. Use ""' + newMethodName + '" instead.');
          }
          constructor.prototype[oldMethodName] = deprecated, constructor.prototype[oldGetter] = deprecated, constructor.prototype[oldSetter] = deprecated;
        });
      },
      afterSetFilter() {
        this._filterUpToDate = !1;
      }
    };
  }
});

// node_modules/konva/lib/Context.js
function simplifyArray(arr) {
  var retArr = [], len = arr.length, util = Util, n, val;
  for (n = 0; n < len; n++)
    val = arr[n], util._isNumber(val) ? val = Math.round(val * 1e3) / 1e3 : util._isString(val) || (val = val + ""), retArr.push(val);
  return retArr;
}
var COMMA, OPEN_PAREN, CLOSE_PAREN, OPEN_PAREN_BRACKET, CLOSE_BRACKET_PAREN, SEMICOLON, DOUBLE_PAREN, EQUALS, CONTEXT_METHODS, CONTEXT_PROPERTIES, traceArrMax, Context, SceneContext, HitContext, init_Context = __esm({
  "node_modules/konva/lib/Context.js"() {
    init_Util();
    init_Global();
    COMMA = ",", OPEN_PAREN = "(", CLOSE_PAREN = ")", OPEN_PAREN_BRACKET = "([", CLOSE_BRACKET_PAREN = "])", SEMICOLON = ";", DOUBLE_PAREN = "()", EQUALS = "=", CONTEXT_METHODS = [
      "arc",
      "arcTo",
      "beginPath",
      "bezierCurveTo",
      "clearRect",
      "clip",
      "closePath",
      "createLinearGradient",
      "createPattern",
      "createRadialGradient",
      "drawImage",
      "ellipse",
      "fill",
      "fillText",
      "getImageData",
      "createImageData",
      "lineTo",
      "moveTo",
      "putImageData",
      "quadraticCurveTo",
      "rect",
      "restore",
      "rotate",
      "save",
      "scale",
      "setLineDash",
      "setTransform",
      "stroke",
      "strokeText",
      "transform",
      "translate"
    ], CONTEXT_PROPERTIES = [
      "fillStyle",
      "strokeStyle",
      "shadowColor",
      "shadowBlur",
      "shadowOffsetX",
      "shadowOffsetY",
      "lineCap",
      "lineDashOffset",
      "lineJoin",
      "lineWidth",
      "miterLimit",
      "font",
      "textAlign",
      "textBaseline",
      "globalAlpha",
      "globalCompositeOperation",
      "imageSmoothingEnabled"
    ], traceArrMax = 100, Context = class {
      constructor(canvas) {
        this.canvas = canvas, Konva.enableTrace && (this.traceArr = [], this._enableTrace());
      }
      fillShape(shape) {
        shape.fillEnabled() && this._fill(shape);
      }
      _fill(shape) {
      }
      strokeShape(shape) {
        shape.hasStroke() && this._stroke(shape);
      }
      _stroke(shape) {
      }
      fillStrokeShape(shape) {
        shape.attrs.fillAfterStrokeEnabled ? (this.strokeShape(shape), this.fillShape(shape)) : (this.fillShape(shape), this.strokeShape(shape));
      }
      getTrace(relaxed, rounded) {
        var traceArr = this.traceArr, len = traceArr.length, str = "", n, trace, method, args;
        for (n = 0; n < len; n++)
          trace = traceArr[n], method = trace.method, method ? (args = trace.args, str += method, relaxed ? str += DOUBLE_PAREN : Util._isArray(args[0]) ? str += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN : (rounded && (args = args.map((a) => typeof a == "number" ? Math.floor(a) : a)), str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN)) : (str += trace.property, relaxed || (str += EQUALS + trace.val)), str += SEMICOLON;
        return str;
      }
      clearTrace() {
        this.traceArr = [];
      }
      _trace(str) {
        var traceArr = this.traceArr, len;
        traceArr.push(str), len = traceArr.length, len >= traceArrMax && traceArr.shift();
      }
      reset() {
        var pixelRatio = this.getCanvas().getPixelRatio();
        this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);
      }
      getCanvas() {
        return this.canvas;
      }
      clear(bounds) {
        var canvas = this.getCanvas();
        bounds ? this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0) : this.clearRect(0, 0, canvas.getWidth() / canvas.pixelRatio, canvas.getHeight() / canvas.pixelRatio);
      }
      _applyLineCap(shape) {
        var lineCap = shape.getLineCap();
        lineCap && this.setAttr("lineCap", lineCap);
      }
      _applyOpacity(shape) {
        var absOpacity = shape.getAbsoluteOpacity();
        absOpacity !== 1 && this.setAttr("globalAlpha", absOpacity);
      }
      _applyLineJoin(shape) {
        var lineJoin = shape.attrs.lineJoin;
        lineJoin && this.setAttr("lineJoin", lineJoin);
      }
      setAttr(attr, val) {
        this._context[attr] = val;
      }
      arc(a0, a1, a2, a3, a4, a5) {
        this._context.arc(a0, a1, a2, a3, a4, a5);
      }
      arcTo(a0, a1, a2, a3, a4) {
        this._context.arcTo(a0, a1, a2, a3, a4);
      }
      beginPath() {
        this._context.beginPath();
      }
      bezierCurveTo(a0, a1, a2, a3, a4, a5) {
        this._context.bezierCurveTo(a0, a1, a2, a3, a4, a5);
      }
      clearRect(a0, a1, a2, a3) {
        this._context.clearRect(a0, a1, a2, a3);
      }
      clip() {
        this._context.clip();
      }
      closePath() {
        this._context.closePath();
      }
      createImageData(a0, a1) {
        var a = arguments;
        if (a.length === 2)
          return this._context.createImageData(a0, a1);
        if (a.length === 1)
          return this._context.createImageData(a0);
      }
      createLinearGradient(a0, a1, a2, a3) {
        return this._context.createLinearGradient(a0, a1, a2, a3);
      }
      createPattern(a0, a1) {
        return this._context.createPattern(a0, a1);
      }
      createRadialGradient(a0, a1, a2, a3, a4, a5) {
        return this._context.createRadialGradient(a0, a1, a2, a3, a4, a5);
      }
      drawImage(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        var a = arguments, _context = this._context;
        a.length === 3 ? _context.drawImage(a0, a1, a2) : a.length === 5 ? _context.drawImage(a0, a1, a2, a3, a4) : a.length === 9 && _context.drawImage(a0, a1, a2, a3, a4, a5, a6, a7, a8);
      }
      ellipse(a0, a1, a2, a3, a4, a5, a6, a7) {
        this._context.ellipse(a0, a1, a2, a3, a4, a5, a6, a7);
      }
      isPointInPath(x, y) {
        return this._context.isPointInPath(x, y);
      }
      fill(path2d) {
        path2d ? this._context.fill(path2d) : this._context.fill();
      }
      fillRect(x, y, width, height) {
        this._context.fillRect(x, y, width, height);
      }
      strokeRect(x, y, width, height) {
        this._context.strokeRect(x, y, width, height);
      }
      fillText(text, x, y, maxWidth) {
        maxWidth ? this._context.fillText(text, x, y, maxWidth) : this._context.fillText(text, x, y);
      }
      measureText(text) {
        return this._context.measureText(text);
      }
      getImageData(a0, a1, a2, a3) {
        return this._context.getImageData(a0, a1, a2, a3);
      }
      lineTo(a0, a1) {
        this._context.lineTo(a0, a1);
      }
      moveTo(a0, a1) {
        this._context.moveTo(a0, a1);
      }
      rect(a0, a1, a2, a3) {
        this._context.rect(a0, a1, a2, a3);
      }
      putImageData(a0, a1, a2) {
        this._context.putImageData(a0, a1, a2);
      }
      quadraticCurveTo(a0, a1, a2, a3) {
        this._context.quadraticCurveTo(a0, a1, a2, a3);
      }
      restore() {
        this._context.restore();
      }
      rotate(a0) {
        this._context.rotate(a0);
      }
      save() {
        this._context.save();
      }
      scale(a0, a1) {
        this._context.scale(a0, a1);
      }
      setLineDash(a0) {
        this._context.setLineDash ? this._context.setLineDash(a0) : "mozDash" in this._context ? this._context.mozDash = a0 : "webkitLineDash" in this._context && (this._context.webkitLineDash = a0);
      }
      getLineDash() {
        return this._context.getLineDash();
      }
      setTransform(a0, a1, a2, a3, a4, a5) {
        this._context.setTransform(a0, a1, a2, a3, a4, a5);
      }
      stroke(path2d) {
        path2d ? this._context.stroke(path2d) : this._context.stroke();
      }
      strokeText(a0, a1, a2, a3) {
        this._context.strokeText(a0, a1, a2, a3);
      }
      transform(a0, a1, a2, a3, a4, a5) {
        this._context.transform(a0, a1, a2, a3, a4, a5);
      }
      translate(a0, a1) {
        this._context.translate(a0, a1);
      }
      _enableTrace() {
        var that = this, len = CONTEXT_METHODS.length, origSetter = this.setAttr, n, args, func = function(methodName) {
          var origMethod = that[methodName], ret;
          that[methodName] = function() {
            return args = simplifyArray(Array.prototype.slice.call(arguments, 0)), ret = origMethod.apply(that, arguments), that._trace({
              method: methodName,
              args
            }), ret;
          };
        };
        for (n = 0; n < len; n++)
          func(CONTEXT_METHODS[n]);
        that.setAttr = function() {
          origSetter.apply(that, arguments);
          var prop = arguments[0], val = arguments[1];
          (prop === "shadowOffsetX" || prop === "shadowOffsetY" || prop === "shadowBlur") && (val = val / this.canvas.getPixelRatio()), that._trace({
            property: prop,
            val
          });
        };
      }
      _applyGlobalCompositeOperation(node) {
        let op = node.attrs.globalCompositeOperation;
        var def = !op || op === "source-over";
        def || this.setAttr("globalCompositeOperation", op);
      }
    };
    CONTEXT_PROPERTIES.forEach(function(prop) {
      Object.defineProperty(Context.prototype, prop, {
        get() {
          return this._context[prop];
        },
        set(val) {
          this._context[prop] = val;
        }
      });
    });
    SceneContext = class extends Context {
      constructor(canvas) {
        super(canvas), this._context = canvas._canvas.getContext("2d");
      }
      _fillColor(shape) {
        var fill = shape.fill();
        this.setAttr("fillStyle", fill), shape._fillFunc(this);
      }
      _fillPattern(shape) {
        this.setAttr("fillStyle", shape._getFillPattern()), shape._fillFunc(this);
      }
      _fillLinearGradient(shape) {
        var grd = shape._getLinearGradient();
        grd && (this.setAttr("fillStyle", grd), shape._fillFunc(this));
      }
      _fillRadialGradient(shape) {
        var grd = shape._getRadialGradient();
        grd && (this.setAttr("fillStyle", grd), shape._fillFunc(this));
      }
      _fill(shape) {
        var hasColor = shape.fill(), fillPriority = shape.getFillPriority();
        if (hasColor && fillPriority === "color") {
          this._fillColor(shape);
          return;
        }
        var hasPattern = shape.getFillPatternImage();
        if (hasPattern && fillPriority === "pattern") {
          this._fillPattern(shape);
          return;
        }
        var hasLinearGradient = shape.getFillLinearGradientColorStops();
        if (hasLinearGradient && fillPriority === "linear-gradient") {
          this._fillLinearGradient(shape);
          return;
        }
        var hasRadialGradient = shape.getFillRadialGradientColorStops();
        if (hasRadialGradient && fillPriority === "radial-gradient") {
          this._fillRadialGradient(shape);
          return;
        }
        hasColor ? this._fillColor(shape) : hasPattern ? this._fillPattern(shape) : hasLinearGradient ? this._fillLinearGradient(shape) : hasRadialGradient && this._fillRadialGradient(shape);
      }
      _strokeLinearGradient(shape) {
        var start = shape.getStrokeLinearGradientStartPoint(), end = shape.getStrokeLinearGradientEndPoint(), colorStops = shape.getStrokeLinearGradientColorStops(), grd = this.createLinearGradient(start.x, start.y, end.x, end.y);
        if (colorStops) {
          for (var n = 0; n < colorStops.length; n += 2)
            grd.addColorStop(colorStops[n], colorStops[n + 1]);
          this.setAttr("strokeStyle", grd);
        }
      }
      _stroke(shape) {
        var dash = shape.dash(), strokeScaleEnabled = shape.getStrokeScaleEnabled();
        if (shape.hasStroke()) {
          if (!strokeScaleEnabled) {
            this.save();
            var pixelRatio = this.getCanvas().getPixelRatio();
            this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
          }
          this._applyLineCap(shape), dash && shape.dashEnabled() && (this.setLineDash(dash), this.setAttr("lineDashOffset", shape.dashOffset())), this.setAttr("lineWidth", shape.strokeWidth()), shape.getShadowForStrokeEnabled() || this.setAttr("shadowColor", "rgba(0,0,0,0)");
          var hasLinearGradient = shape.getStrokeLinearGradientColorStops();
          hasLinearGradient ? this._strokeLinearGradient(shape) : this.setAttr("strokeStyle", shape.stroke()), shape._strokeFunc(this), strokeScaleEnabled || this.restore();
        }
      }
      _applyShadow(shape) {
        var _a, _b, _c, color = (_a = shape.getShadowRGBA()) !== null && _a !== void 0 ? _a : "black", blur = (_b = shape.getShadowBlur()) !== null && _b !== void 0 ? _b : 5, offset = (_c = shape.getShadowOffset()) !== null && _c !== void 0 ? _c : {
          x: 0,
          y: 0
        }, scale = shape.getAbsoluteScale(), ratio = this.canvas.getPixelRatio(), scaleX = scale.x * ratio, scaleY = scale.y * ratio;
        this.setAttr("shadowColor", color), this.setAttr("shadowBlur", blur * Math.min(Math.abs(scaleX), Math.abs(scaleY))), this.setAttr("shadowOffsetX", offset.x * scaleX), this.setAttr("shadowOffsetY", offset.y * scaleY);
      }
    }, HitContext = class extends Context {
      constructor(canvas) {
        super(canvas), this._context = canvas._canvas.getContext("2d", {
          willReadFrequently: !0
        });
      }
      _fill(shape) {
        this.save(), this.setAttr("fillStyle", shape.colorKey), shape._fillFuncHit(this), this.restore();
      }
      strokeShape(shape) {
        shape.hasHitStroke() && this._stroke(shape);
      }
      _stroke(shape) {
        if (shape.hasHitStroke()) {
          var strokeScaleEnabled = shape.getStrokeScaleEnabled();
          if (!strokeScaleEnabled) {
            this.save();
            var pixelRatio = this.getCanvas().getPixelRatio();
            this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
          }
          this._applyLineCap(shape);
          var hitStrokeWidth = shape.hitStrokeWidth(), strokeWidth = hitStrokeWidth === "auto" ? shape.strokeWidth() : hitStrokeWidth;
          this.setAttr("lineWidth", strokeWidth), this.setAttr("strokeStyle", shape.colorKey), shape._strokeFuncHit(this), strokeScaleEnabled || this.restore();
        }
      }
    };
  }
});

// node_modules/konva/lib/Canvas.js
function getDevicePixelRatio() {
  if (_pixelRatio)
    return _pixelRatio;
  var canvas = Util.createCanvasElement(), context = canvas.getContext("2d");
  return _pixelRatio = function() {
    var devicePixelRatio = Konva._global.devicePixelRatio || 1, backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
    return devicePixelRatio / backingStoreRatio;
  }(), Util.releaseCanvas(canvas), _pixelRatio;
}
var _pixelRatio, Canvas, SceneCanvas, HitCanvas, init_Canvas = __esm({
  "node_modules/konva/lib/Canvas.js"() {
    init_Util();
    init_Context();
    init_Global();
    init_Factory();
    init_Validators();
    Canvas = class {
      constructor(config) {
        this.pixelRatio = 1, this.width = 0, this.height = 0, this.isCache = !1;
        var conf = config || {}, pixelRatio = conf.pixelRatio || Konva.pixelRatio || getDevicePixelRatio();
        this.pixelRatio = pixelRatio, this._canvas = Util.createCanvasElement(), this._canvas.style.padding = "0", this._canvas.style.margin = "0", this._canvas.style.border = "0", this._canvas.style.background = "transparent", this._canvas.style.position = "absolute", this._canvas.style.top = "0", this._canvas.style.left = "0";
      }
      getContext() {
        return this.context;
      }
      getPixelRatio() {
        return this.pixelRatio;
      }
      setPixelRatio(pixelRatio) {
        var previousRatio = this.pixelRatio;
        this.pixelRatio = pixelRatio, this.setSize(this.getWidth() / previousRatio, this.getHeight() / previousRatio);
      }
      setWidth(width) {
        this.width = this._canvas.width = width * this.pixelRatio, this._canvas.style.width = width + "px";
        var pixelRatio = this.pixelRatio, _context = this.getContext()._context;
        _context.scale(pixelRatio, pixelRatio);
      }
      setHeight(height) {
        this.height = this._canvas.height = height * this.pixelRatio, this._canvas.style.height = height + "px";
        var pixelRatio = this.pixelRatio, _context = this.getContext()._context;
        _context.scale(pixelRatio, pixelRatio);
      }
      getWidth() {
        return this.width;
      }
      getHeight() {
        return this.height;
      }
      setSize(width, height) {
        this.setWidth(width || 0), this.setHeight(height || 0);
      }
      toDataURL(mimeType, quality) {
        try {
          return this._canvas.toDataURL(mimeType, quality);
        } catch {
          try {
            return this._canvas.toDataURL();
          } catch (err) {
            return Util.error("Unable to get data URL. " + err.message + " For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html."), "";
          }
        }
      }
    };
    Factory.addGetterSetter(Canvas, "pixelRatio", void 0, getNumberValidator());
    SceneCanvas = class extends Canvas {
      constructor(config = { width: 0, height: 0 }) {
        super(config), this.context = new SceneContext(this), this.setSize(config.width, config.height);
      }
    }, HitCanvas = class extends Canvas {
      constructor(config = { width: 0, height: 0 }) {
        super(config), this.hitCanvas = !0, this.context = new HitContext(this), this.setSize(config.width, config.height);
      }
    };
  }
});

// node_modules/konva/lib/DragAndDrop.js
var DD, init_DragAndDrop = __esm({
  "node_modules/konva/lib/DragAndDrop.js"() {
    init_Global();
    init_Util();
    DD = {
      get isDragging() {
        var flag = !1;
        return DD._dragElements.forEach((elem) => {
          elem.dragStatus === "dragging" && (flag = !0);
        }), flag;
      },
      justDragged: !1,
      get node() {
        var node;
        return DD._dragElements.forEach((elem) => {
          node = elem.node;
        }), node;
      },
      _dragElements: /* @__PURE__ */ new Map(),
      _drag(evt) {
        let nodesToFireEvents = [];
        DD._dragElements.forEach((elem, key) => {
          let { node } = elem, stage = node.getStage();
          stage.setPointersPositions(evt), elem.pointerId === void 0 && (elem.pointerId = Util._getFirstPointerId(evt));
          let pos = stage._changedPointerPositions.find((pos2) => pos2.id === elem.pointerId);
          if (!!pos) {
            if (elem.dragStatus !== "dragging") {
              var dragDistance = node.dragDistance(), distance = Math.max(Math.abs(pos.x - elem.startPointerPos.x), Math.abs(pos.y - elem.startPointerPos.y));
              if (distance < dragDistance || (node.startDrag({ evt }), !node.isDragging()))
                return;
            }
            node._setDragPosition(evt, elem), nodesToFireEvents.push(node);
          }
        }), nodesToFireEvents.forEach((node) => {
          node.fire("dragmove", {
            type: "dragmove",
            target: node,
            evt
          }, !0);
        });
      },
      _endDragBefore(evt) {
        let drawNodes = [];
        DD._dragElements.forEach((elem) => {
          let { node } = elem, stage = node.getStage();
          if (evt && stage.setPointersPositions(evt), !stage._changedPointerPositions.find((pos2) => pos2.id === elem.pointerId))
            return;
          (elem.dragStatus === "dragging" || elem.dragStatus === "stopped") && (DD.justDragged = !0, Konva._mouseListenClick = !1, Konva._touchListenClick = !1, Konva._pointerListenClick = !1, elem.dragStatus = "stopped");
          let drawNode = elem.node.getLayer() || elem.node instanceof Konva.Stage && elem.node;
          drawNode && drawNodes.indexOf(drawNode) === -1 && drawNodes.push(drawNode);
        }), drawNodes.forEach((drawNode) => {
          drawNode.draw();
        });
      },
      _endDragAfter(evt) {
        DD._dragElements.forEach((elem, key) => {
          elem.dragStatus === "stopped" && elem.node.fire("dragend", {
            type: "dragend",
            target: elem.node,
            evt
          }, !0), elem.dragStatus !== "dragging" && DD._dragElements.delete(key);
        });
      }
    };
    Konva.isBrowser && (window.addEventListener("mouseup", DD._endDragBefore, !0), window.addEventListener("touchend", DD._endDragBefore, !0), window.addEventListener("mousemove", DD._drag), window.addEventListener("touchmove", DD._drag), window.addEventListener("mouseup", DD._endDragAfter, !1), window.addEventListener("touchend", DD._endDragAfter, !1));
  }
});

// node_modules/konva/lib/Node.js
var ABSOLUTE_OPACITY, ALL_LISTENERS, ABSOLUTE_TRANSFORM, ABSOLUTE_SCALE, CANVAS, CHANGE, CHILDREN, KONVA, LISTENING, MOUSEENTER, MOUSELEAVE, SET2, SHAPE, SPACE, STAGE, TRANSFORM, UPPER_STAGE, VISIBLE, TRANSFORM_CHANGE_STR, idCounter, Node, addGetterSetter, init_Node = __esm({
  "node_modules/konva/lib/Node.js"() {
    init_Util();
    init_Factory();
    init_Canvas();
    init_Global();
    init_DragAndDrop();
    init_Validators();
    ABSOLUTE_OPACITY = "absoluteOpacity", ALL_LISTENERS = "allEventListeners", ABSOLUTE_TRANSFORM = "absoluteTransform", ABSOLUTE_SCALE = "absoluteScale", CANVAS = "canvas", CHANGE = "Change", CHILDREN = "children", KONVA = "konva", LISTENING = "listening", MOUSEENTER = "mouseenter", MOUSELEAVE = "mouseleave", SET2 = "set", SHAPE = "Shape", SPACE = " ", STAGE = "stage", TRANSFORM = "transform", UPPER_STAGE = "Stage", VISIBLE = "visible", TRANSFORM_CHANGE_STR = [
      "xChange.konva",
      "yChange.konva",
      "scaleXChange.konva",
      "scaleYChange.konva",
      "skewXChange.konva",
      "skewYChange.konva",
      "rotationChange.konva",
      "offsetXChange.konva",
      "offsetYChange.konva",
      "transformsEnabledChange.konva"
    ].join(SPACE), idCounter = 1, Node = class {
      constructor(config) {
        this._id = idCounter++, this.eventListeners = {}, this.attrs = {}, this.index = 0, this._allEventListeners = null, this.parent = null, this._cache = /* @__PURE__ */ new Map(), this._attachedDepsListeners = /* @__PURE__ */ new Map(), this._lastPos = null, this._batchingTransformChange = !1, this._needClearTransformCache = !1, this._filterUpToDate = !1, this._isUnderCache = !1, this._dragEventId = null, this._shouldFireChangeEvents = !1, this.setAttrs(config), this._shouldFireChangeEvents = !0;
      }
      hasChildren() {
        return !1;
      }
      _clearCache(attr) {
        (attr === TRANSFORM || attr === ABSOLUTE_TRANSFORM) && this._cache.get(attr) ? this._cache.get(attr).dirty = !0 : attr ? this._cache.delete(attr) : this._cache.clear();
      }
      _getCache(attr, privateGetter) {
        var cache = this._cache.get(attr), isTransform = attr === TRANSFORM || attr === ABSOLUTE_TRANSFORM, invalid = cache === void 0 || isTransform && cache.dirty === !0;
        return invalid && (cache = privateGetter.call(this), this._cache.set(attr, cache)), cache;
      }
      _calculate(name, deps, getter) {
        if (!this._attachedDepsListeners.get(name)) {
          let depsString = deps.map((dep) => dep + "Change.konva").join(SPACE);
          this.on(depsString, () => {
            this._clearCache(name);
          }), this._attachedDepsListeners.set(name, !0);
        }
        return this._getCache(name, getter);
      }
      _getCanvasCache() {
        return this._cache.get(CANVAS);
      }
      _clearSelfAndDescendantCache(attr) {
        this._clearCache(attr), attr === ABSOLUTE_TRANSFORM && this.fire("absoluteTransformChange");
      }
      clearCache() {
        if (this._cache.has(CANVAS)) {
          let { scene, filter, hit } = this._cache.get(CANVAS);
          Util.releaseCanvas(scene, filter, hit), this._cache.delete(CANVAS);
        }
        return this._clearSelfAndDescendantCache(), this._requestDraw(), this;
      }
      cache(config) {
        var conf = config || {}, rect = {};
        (conf.x === void 0 || conf.y === void 0 || conf.width === void 0 || conf.height === void 0) && (rect = this.getClientRect({
          skipTransform: !0,
          relativeTo: this.getParent()
        }));
        var width = Math.ceil(conf.width || rect.width), height = Math.ceil(conf.height || rect.height), pixelRatio = conf.pixelRatio, x = conf.x === void 0 ? Math.floor(rect.x) : conf.x, y = conf.y === void 0 ? Math.floor(rect.y) : conf.y, offset = conf.offset || 0, drawBorder = conf.drawBorder || !1, hitCanvasPixelRatio = conf.hitCanvasPixelRatio || 1;
        if (!width || !height) {
          Util.error("Can not cache the node. Width or height of the node equals 0. Caching is skipped.");
          return;
        }
        width += offset * 2 + 1, height += offset * 2 + 1, x -= offset, y -= offset;
        var cachedSceneCanvas = new SceneCanvas({
          pixelRatio,
          width,
          height
        }), cachedFilterCanvas = new SceneCanvas({
          pixelRatio,
          width: 0,
          height: 0
        }), cachedHitCanvas = new HitCanvas({
          pixelRatio: hitCanvasPixelRatio,
          width,
          height
        }), sceneContext = cachedSceneCanvas.getContext(), hitContext = cachedHitCanvas.getContext();
        return cachedHitCanvas.isCache = !0, cachedSceneCanvas.isCache = !0, this._cache.delete(CANVAS), this._filterUpToDate = !1, conf.imageSmoothingEnabled === !1 && (cachedSceneCanvas.getContext()._context.imageSmoothingEnabled = !1, cachedFilterCanvas.getContext()._context.imageSmoothingEnabled = !1), sceneContext.save(), hitContext.save(), sceneContext.translate(-x, -y), hitContext.translate(-x, -y), this._isUnderCache = !0, this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY), this._clearSelfAndDescendantCache(ABSOLUTE_SCALE), this.drawScene(cachedSceneCanvas, this), this.drawHit(cachedHitCanvas, this), this._isUnderCache = !1, sceneContext.restore(), hitContext.restore(), drawBorder && (sceneContext.save(), sceneContext.beginPath(), sceneContext.rect(0, 0, width, height), sceneContext.closePath(), sceneContext.setAttr("strokeStyle", "red"), sceneContext.setAttr("lineWidth", 5), sceneContext.stroke(), sceneContext.restore()), this._cache.set(CANVAS, {
          scene: cachedSceneCanvas,
          filter: cachedFilterCanvas,
          hit: cachedHitCanvas,
          x,
          y
        }), this._requestDraw(), this;
      }
      isCached() {
        return this._cache.has(CANVAS);
      }
      getClientRect(config) {
        throw new Error('abstract "getClientRect" method call');
      }
      _transformedRect(rect, top) {
        var points = [
          { x: rect.x, y: rect.y },
          { x: rect.x + rect.width, y: rect.y },
          { x: rect.x + rect.width, y: rect.y + rect.height },
          { x: rect.x, y: rect.y + rect.height }
        ], minX, minY, maxX, maxY, trans = this.getAbsoluteTransform(top);
        return points.forEach(function(point) {
          var transformed = trans.point(point);
          minX === void 0 && (minX = maxX = transformed.x, minY = maxY = transformed.y), minX = Math.min(minX, transformed.x), minY = Math.min(minY, transformed.y), maxX = Math.max(maxX, transformed.x), maxY = Math.max(maxY, transformed.y);
        }), {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
      }
      _drawCachedSceneCanvas(context) {
        context.save(), context._applyOpacity(this), context._applyGlobalCompositeOperation(this);
        let canvasCache = this._getCanvasCache();
        context.translate(canvasCache.x, canvasCache.y);
        var cacheCanvas = this._getCachedSceneCanvas(), ratio = cacheCanvas.pixelRatio;
        context.drawImage(cacheCanvas._canvas, 0, 0, cacheCanvas.width / ratio, cacheCanvas.height / ratio), context.restore();
      }
      _drawCachedHitCanvas(context) {
        var canvasCache = this._getCanvasCache(), hitCanvas = canvasCache.hit;
        context.save(), context.translate(canvasCache.x, canvasCache.y), context.drawImage(hitCanvas._canvas, 0, 0, hitCanvas.width / hitCanvas.pixelRatio, hitCanvas.height / hitCanvas.pixelRatio), context.restore();
      }
      _getCachedSceneCanvas() {
        var filters = this.filters(), cachedCanvas = this._getCanvasCache(), sceneCanvas = cachedCanvas.scene, filterCanvas = cachedCanvas.filter, filterContext = filterCanvas.getContext(), len, imageData, n, filter;
        if (filters) {
          if (!this._filterUpToDate) {
            var ratio = sceneCanvas.pixelRatio;
            filterCanvas.setSize(sceneCanvas.width / sceneCanvas.pixelRatio, sceneCanvas.height / sceneCanvas.pixelRatio);
            try {
              for (len = filters.length, filterContext.clear(), filterContext.drawImage(sceneCanvas._canvas, 0, 0, sceneCanvas.getWidth() / ratio, sceneCanvas.getHeight() / ratio), imageData = filterContext.getImageData(0, 0, filterCanvas.getWidth(), filterCanvas.getHeight()), n = 0; n < len; n++) {
                if (filter = filters[n], typeof filter != "function") {
                  Util.error("Filter should be type of function, but got " + typeof filter + " instead. Please check correct filters");
                  continue;
                }
                filter.call(this, imageData), filterContext.putImageData(imageData, 0, 0);
              }
            } catch (e) {
              Util.error("Unable to apply filter. " + e.message + " This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.");
            }
            this._filterUpToDate = !0;
          }
          return filterCanvas;
        }
        return sceneCanvas;
      }
      on(evtStr, handler) {
        if (this._cache && this._cache.delete(ALL_LISTENERS), arguments.length === 3)
          return this._delegate.apply(this, arguments);
        var events = evtStr.split(SPACE), len = events.length, n, event, parts, baseEvent, name;
        for (n = 0; n < len; n++)
          event = events[n], parts = event.split("."), baseEvent = parts[0], name = parts[1] || "", this.eventListeners[baseEvent] || (this.eventListeners[baseEvent] = []), this.eventListeners[baseEvent].push({
            name,
            handler
          });
        return this;
      }
      off(evtStr, callback) {
        var events = (evtStr || "").split(SPACE), len = events.length, n, t, event, parts, baseEvent, name;
        if (this._cache && this._cache.delete(ALL_LISTENERS), !evtStr)
          for (t in this.eventListeners)
            this._off(t);
        for (n = 0; n < len; n++)
          if (event = events[n], parts = event.split("."), baseEvent = parts[0], name = parts[1], baseEvent)
            this.eventListeners[baseEvent] && this._off(baseEvent, name, callback);
          else
            for (t in this.eventListeners)
              this._off(t, name, callback);
        return this;
      }
      dispatchEvent(evt) {
        var e = {
          target: this,
          type: evt.type,
          evt
        };
        return this.fire(evt.type, e), this;
      }
      addEventListener(type, handler) {
        return this.on(type, function(evt) {
          handler.call(this, evt.evt);
        }), this;
      }
      removeEventListener(type) {
        return this.off(type), this;
      }
      _delegate(event, selector, handler) {
        var stopNode = this;
        this.on(event, function(evt) {
          for (var targets = evt.target.findAncestors(selector, !0, stopNode), i = 0; i < targets.length; i++)
            evt = Util.cloneObject(evt), evt.currentTarget = targets[i], handler.call(targets[i], evt);
        });
      }
      remove() {
        return this.isDragging() && this.stopDrag(), DD._dragElements.delete(this._id), this._remove(), this;
      }
      _clearCaches() {
        this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM), this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY), this._clearSelfAndDescendantCache(ABSOLUTE_SCALE), this._clearSelfAndDescendantCache(STAGE), this._clearSelfAndDescendantCache(VISIBLE), this._clearSelfAndDescendantCache(LISTENING);
      }
      _remove() {
        this._clearCaches();
        var parent = this.getParent();
        parent && parent.children && (parent.children.splice(this.index, 1), parent._setChildrenIndices(), this.parent = null);
      }
      destroy() {
        return this.remove(), this.clearCache(), this;
      }
      getAttr(attr) {
        var method = "get" + Util._capitalize(attr);
        return Util._isFunction(this[method]) ? this[method]() : this.attrs[attr];
      }
      getAncestors() {
        for (var parent = this.getParent(), ancestors = []; parent; )
          ancestors.push(parent), parent = parent.getParent();
        return ancestors;
      }
      getAttrs() {
        return this.attrs || {};
      }
      setAttrs(config) {
        return this._batchTransformChanges(() => {
          var key, method;
          if (!config)
            return this;
          for (key in config)
            key !== CHILDREN && (method = SET2 + Util._capitalize(key), Util._isFunction(this[method]) ? this[method](config[key]) : this._setAttr(key, config[key]));
        }), this;
      }
      isListening() {
        return this._getCache(LISTENING, this._isListening);
      }
      _isListening(relativeTo) {
        if (!this.listening())
          return !1;
        let parent = this.getParent();
        return parent && parent !== relativeTo && this !== relativeTo ? parent._isListening(relativeTo) : !0;
      }
      isVisible() {
        return this._getCache(VISIBLE, this._isVisible);
      }
      _isVisible(relativeTo) {
        if (!this.visible())
          return !1;
        let parent = this.getParent();
        return parent && parent !== relativeTo && this !== relativeTo ? parent._isVisible(relativeTo) : !0;
      }
      shouldDrawHit(top, skipDragCheck = !1) {
        if (top)
          return this._isVisible(top) && this._isListening(top);
        var layer = this.getLayer(), layerUnderDrag = !1;
        DD._dragElements.forEach((elem) => {
          elem.dragStatus === "dragging" && (elem.node.nodeType === "Stage" || elem.node.getLayer() === layer) && (layerUnderDrag = !0);
        });
        var dragSkip = !skipDragCheck && !Konva.hitOnDragEnabled && layerUnderDrag;
        return this.isListening() && this.isVisible() && !dragSkip;
      }
      show() {
        return this.visible(!0), this;
      }
      hide() {
        return this.visible(!1), this;
      }
      getZIndex() {
        return this.index || 0;
      }
      getAbsoluteZIndex() {
        var depth = this.getDepth(), that = this, index = 0, nodes, len, n, child;
        function addChildren(children) {
          for (nodes = [], len = children.length, n = 0; n < len; n++)
            child = children[n], index++, child.nodeType !== SHAPE && (nodes = nodes.concat(child.getChildren().slice())), child._id === that._id && (n = len);
          nodes.length > 0 && nodes[0].getDepth() <= depth && addChildren(nodes);
        }
        return that.nodeType !== UPPER_STAGE && addChildren(that.getStage().getChildren()), index;
      }
      getDepth() {
        for (var depth = 0, parent = this.parent; parent; )
          depth++, parent = parent.parent;
        return depth;
      }
      _batchTransformChanges(func) {
        this._batchingTransformChange = !0, func(), this._batchingTransformChange = !1, this._needClearTransformCache && (this._clearCache(TRANSFORM), this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM)), this._needClearTransformCache = !1;
      }
      setPosition(pos) {
        return this._batchTransformChanges(() => {
          this.x(pos.x), this.y(pos.y);
        }), this;
      }
      getPosition() {
        return {
          x: this.x(),
          y: this.y()
        };
      }
      getRelativePointerPosition() {
        if (!this.getStage())
          return null;
        var pos = this.getStage().getPointerPosition();
        if (!pos)
          return null;
        var transform = this.getAbsoluteTransform().copy();
        return transform.invert(), transform.point(pos);
      }
      getAbsolutePosition(top) {
        let haveCachedParent = !1, parent = this.parent;
        for (; parent; ) {
          if (parent.isCached()) {
            haveCachedParent = !0;
            break;
          }
          parent = parent.parent;
        }
        haveCachedParent && !top && (top = !0);
        var absoluteMatrix = this.getAbsoluteTransform(top).getMatrix(), absoluteTransform = new Transform(), offset = this.offset();
        return absoluteTransform.m = absoluteMatrix.slice(), absoluteTransform.translate(offset.x, offset.y), absoluteTransform.getTranslation();
      }
      setAbsolutePosition(pos) {
        var origTrans = this._clearTransform();
        this.attrs.x = origTrans.x, this.attrs.y = origTrans.y, delete origTrans.x, delete origTrans.y, this._clearCache(TRANSFORM);
        var it = this._getAbsoluteTransform().copy();
        return it.invert(), it.translate(pos.x, pos.y), pos = {
          x: this.attrs.x + it.getTranslation().x,
          y: this.attrs.y + it.getTranslation().y
        }, this._setTransform(origTrans), this.setPosition({ x: pos.x, y: pos.y }), this._clearCache(TRANSFORM), this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM), this;
      }
      _setTransform(trans) {
        var key;
        for (key in trans)
          this.attrs[key] = trans[key];
      }
      _clearTransform() {
        var trans = {
          x: this.x(),
          y: this.y(),
          rotation: this.rotation(),
          scaleX: this.scaleX(),
          scaleY: this.scaleY(),
          offsetX: this.offsetX(),
          offsetY: this.offsetY(),
          skewX: this.skewX(),
          skewY: this.skewY()
        };
        return this.attrs.x = 0, this.attrs.y = 0, this.attrs.rotation = 0, this.attrs.scaleX = 1, this.attrs.scaleY = 1, this.attrs.offsetX = 0, this.attrs.offsetY = 0, this.attrs.skewX = 0, this.attrs.skewY = 0, trans;
      }
      move(change) {
        var changeX = change.x, changeY = change.y, x = this.x(), y = this.y();
        return changeX !== void 0 && (x += changeX), changeY !== void 0 && (y += changeY), this.setPosition({ x, y }), this;
      }
      _eachAncestorReverse(func, top) {
        var family = [], parent = this.getParent(), len, n;
        if (!(top && top._id === this._id)) {
          for (family.unshift(this); parent && (!top || parent._id !== top._id); )
            family.unshift(parent), parent = parent.parent;
          for (len = family.length, n = 0; n < len; n++)
            func(family[n]);
        }
      }
      rotate(theta) {
        return this.rotation(this.rotation() + theta), this;
      }
      moveToTop() {
        if (!this.parent)
          return Util.warn("Node has no parent. moveToTop function is ignored."), !1;
        var index = this.index, len = this.parent.getChildren().length;
        return index < len - 1 ? (this.parent.children.splice(index, 1), this.parent.children.push(this), this.parent._setChildrenIndices(), !0) : !1;
      }
      moveUp() {
        if (!this.parent)
          return Util.warn("Node has no parent. moveUp function is ignored."), !1;
        var index = this.index, len = this.parent.getChildren().length;
        return index < len - 1 ? (this.parent.children.splice(index, 1), this.parent.children.splice(index + 1, 0, this), this.parent._setChildrenIndices(), !0) : !1;
      }
      moveDown() {
        if (!this.parent)
          return Util.warn("Node has no parent. moveDown function is ignored."), !1;
        var index = this.index;
        return index > 0 ? (this.parent.children.splice(index, 1), this.parent.children.splice(index - 1, 0, this), this.parent._setChildrenIndices(), !0) : !1;
      }
      moveToBottom() {
        if (!this.parent)
          return Util.warn("Node has no parent. moveToBottom function is ignored."), !1;
        var index = this.index;
        return index > 0 ? (this.parent.children.splice(index, 1), this.parent.children.unshift(this), this.parent._setChildrenIndices(), !0) : !1;
      }
      setZIndex(zIndex) {
        if (!this.parent)
          return Util.warn("Node has no parent. zIndex parameter is ignored."), this;
        (zIndex < 0 || zIndex >= this.parent.children.length) && Util.warn("Unexpected value " + zIndex + " for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to " + (this.parent.children.length - 1) + ".");
        var index = this.index;
        return this.parent.children.splice(index, 1), this.parent.children.splice(zIndex, 0, this), this.parent._setChildrenIndices(), this;
      }
      getAbsoluteOpacity() {
        return this._getCache(ABSOLUTE_OPACITY, this._getAbsoluteOpacity);
      }
      _getAbsoluteOpacity() {
        var absOpacity = this.opacity(), parent = this.getParent();
        return parent && !parent._isUnderCache && (absOpacity *= parent.getAbsoluteOpacity()), absOpacity;
      }
      moveTo(newContainer) {
        return this.getParent() !== newContainer && (this._remove(), newContainer.add(this)), this;
      }
      toObject() {
        var obj = {}, attrs = this.getAttrs(), key, val, getter, defaultValue, nonPlainObject;
        obj.attrs = {};
        for (key in attrs)
          val = attrs[key], nonPlainObject = Util.isObject(val) && !Util._isPlainObject(val) && !Util._isArray(val), !nonPlainObject && (getter = typeof this[key] == "function" && this[key], delete attrs[key], defaultValue = getter ? getter.call(this) : null, attrs[key] = val, defaultValue !== val && (obj.attrs[key] = val));
        return obj.className = this.getClassName(), Util._prepareToStringify(obj);
      }
      toJSON() {
        return JSON.stringify(this.toObject());
      }
      getParent() {
        return this.parent;
      }
      findAncestors(selector, includeSelf, stopNode) {
        var res = [];
        includeSelf && this._isMatch(selector) && res.push(this);
        for (var ancestor = this.parent; ancestor; ) {
          if (ancestor === stopNode)
            return res;
          ancestor._isMatch(selector) && res.push(ancestor), ancestor = ancestor.parent;
        }
        return res;
      }
      isAncestorOf(node) {
        return !1;
      }
      findAncestor(selector, includeSelf, stopNode) {
        return this.findAncestors(selector, includeSelf, stopNode)[0];
      }
      _isMatch(selector) {
        if (!selector)
          return !1;
        if (typeof selector == "function")
          return selector(this);
        var selectorArr = selector.replace(/ /g, "").split(","), len = selectorArr.length, n, sel;
        for (n = 0; n < len; n++)
          if (sel = selectorArr[n], Util.isValidSelector(sel) || (Util.warn('Selector "' + sel + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".'), Util.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".'), Util.warn("Konva is awesome, right?")), sel.charAt(0) === "#") {
            if (this.id() === sel.slice(1))
              return !0;
          } else if (sel.charAt(0) === ".") {
            if (this.hasName(sel.slice(1)))
              return !0;
          } else if (this.className === sel || this.nodeType === sel)
            return !0;
        return !1;
      }
      getLayer() {
        var parent = this.getParent();
        return parent ? parent.getLayer() : null;
      }
      getStage() {
        return this._getCache(STAGE, this._getStage);
      }
      _getStage() {
        var parent = this.getParent();
        if (parent)
          return parent.getStage();
      }
      fire(eventType, evt = {}, bubble) {
        return evt.target = evt.target || this, bubble ? this._fireAndBubble(eventType, evt) : this._fire(eventType, evt), this;
      }
      getAbsoluteTransform(top) {
        return top ? this._getAbsoluteTransform(top) : this._getCache(ABSOLUTE_TRANSFORM, this._getAbsoluteTransform);
      }
      _getAbsoluteTransform(top) {
        var at;
        if (top)
          return at = new Transform(), this._eachAncestorReverse(function(node) {
            var transformsEnabled2 = node.transformsEnabled();
            transformsEnabled2 === "all" ? at.multiply(node.getTransform()) : transformsEnabled2 === "position" && at.translate(node.x() - node.offsetX(), node.y() - node.offsetY());
          }, top), at;
        at = this._cache.get(ABSOLUTE_TRANSFORM) || new Transform(), this.parent ? this.parent.getAbsoluteTransform().copyInto(at) : at.reset();
        var transformsEnabled = this.transformsEnabled();
        if (transformsEnabled === "all")
          at.multiply(this.getTransform());
        else if (transformsEnabled === "position") {
          let x = this.attrs.x || 0, y = this.attrs.y || 0, offsetX = this.attrs.offsetX || 0, offsetY = this.attrs.offsetY || 0;
          at.translate(x - offsetX, y - offsetY);
        }
        return at.dirty = !1, at;
      }
      getAbsoluteScale(top) {
        for (var parent = this; parent; )
          parent._isUnderCache && (top = parent), parent = parent.getParent();
        let attrs = this.getAbsoluteTransform(top).decompose();
        return {
          x: attrs.scaleX,
          y: attrs.scaleY
        };
      }
      getAbsoluteRotation() {
        return this.getAbsoluteTransform().decompose().rotation;
      }
      getTransform() {
        return this._getCache(TRANSFORM, this._getTransform);
      }
      _getTransform() {
        var _a, _b, m = this._cache.get(TRANSFORM) || new Transform();
        m.reset();
        var x = this.x(), y = this.y(), rotation = Konva.getAngle(this.rotation()), scaleX = (_a = this.attrs.scaleX) !== null && _a !== void 0 ? _a : 1, scaleY = (_b = this.attrs.scaleY) !== null && _b !== void 0 ? _b : 1, skewX = this.attrs.skewX || 0, skewY = this.attrs.skewY || 0, offsetX = this.attrs.offsetX || 0, offsetY = this.attrs.offsetY || 0;
        return (x !== 0 || y !== 0) && m.translate(x, y), rotation !== 0 && m.rotate(rotation), (skewX !== 0 || skewY !== 0) && m.skew(skewX, skewY), (scaleX !== 1 || scaleY !== 1) && m.scale(scaleX, scaleY), (offsetX !== 0 || offsetY !== 0) && m.translate(-1 * offsetX, -1 * offsetY), m.dirty = !1, m;
      }
      clone(obj) {
        var attrs = Util.cloneObject(this.attrs), key, allListeners, len, n, listener;
        for (key in obj)
          attrs[key] = obj[key];
        var node = new this.constructor(attrs);
        for (key in this.eventListeners)
          for (allListeners = this.eventListeners[key], len = allListeners.length, n = 0; n < len; n++)
            listener = allListeners[n], listener.name.indexOf(KONVA) < 0 && (node.eventListeners[key] || (node.eventListeners[key] = []), node.eventListeners[key].push(listener));
        return node;
      }
      _toKonvaCanvas(config) {
        config = config || {};
        var box = this.getClientRect(), stage = this.getStage(), x = config.x !== void 0 ? config.x : Math.floor(box.x), y = config.y !== void 0 ? config.y : Math.floor(box.y), pixelRatio = config.pixelRatio || 1, canvas = new SceneCanvas({
          width: config.width || Math.ceil(box.width) || (stage ? stage.width() : 0),
          height: config.height || Math.ceil(box.height) || (stage ? stage.height() : 0),
          pixelRatio
        }), context = canvas.getContext();
        return config.imageSmoothingEnabled === !1 && (context._context.imageSmoothingEnabled = !1), context.save(), (x || y) && context.translate(-1 * x, -1 * y), this.drawScene(canvas), context.restore(), canvas;
      }
      toCanvas(config) {
        return this._toKonvaCanvas(config)._canvas;
      }
      toDataURL(config) {
        config = config || {};
        var mimeType = config.mimeType || null, quality = config.quality || null, url = this._toKonvaCanvas(config).toDataURL(mimeType, quality);
        return config.callback && config.callback(url), url;
      }
      toImage(config) {
        return new Promise((resolve, reject) => {
          try {
            let callback = config == null ? void 0 : config.callback;
            callback && delete config.callback, Util._urlToImage(this.toDataURL(config), function(img) {
              resolve(img), callback == null || callback(img);
            });
          } catch (err) {
            reject(err);
          }
        });
      }
      toBlob(config) {
        return new Promise((resolve, reject) => {
          try {
            let callback = config == null ? void 0 : config.callback;
            callback && delete config.callback, this.toCanvas(config).toBlob((blob) => {
              resolve(blob), callback == null || callback(blob);
            });
          } catch (err) {
            reject(err);
          }
        });
      }
      setSize(size) {
        return this.width(size.width), this.height(size.height), this;
      }
      getSize() {
        return {
          width: this.width(),
          height: this.height()
        };
      }
      getClassName() {
        return this.className || this.nodeType;
      }
      getType() {
        return this.nodeType;
      }
      getDragDistance() {
        return this.attrs.dragDistance !== void 0 ? this.attrs.dragDistance : this.parent ? this.parent.getDragDistance() : Konva.dragDistance;
      }
      _off(type, name, callback) {
        var evtListeners = this.eventListeners[type], i, evtName, handler;
        for (i = 0; i < evtListeners.length; i++)
          if (evtName = evtListeners[i].name, handler = evtListeners[i].handler, (evtName !== "konva" || name === "konva") && (!name || evtName === name) && (!callback || callback === handler)) {
            if (evtListeners.splice(i, 1), evtListeners.length === 0) {
              delete this.eventListeners[type];
              break;
            }
            i--;
          }
      }
      _fireChangeEvent(attr, oldVal, newVal) {
        this._fire(attr + CHANGE, {
          oldVal,
          newVal
        });
      }
      addName(name) {
        if (!this.hasName(name)) {
          var oldName = this.name(), newName = oldName ? oldName + " " + name : name;
          this.name(newName);
        }
        return this;
      }
      hasName(name) {
        if (!name)
          return !1;
        let fullName = this.name();
        if (!fullName)
          return !1;
        var names = (fullName || "").split(/\s/g);
        return names.indexOf(name) !== -1;
      }
      removeName(name) {
        var names = (this.name() || "").split(/\s/g), index = names.indexOf(name);
        return index !== -1 && (names.splice(index, 1), this.name(names.join(" "))), this;
      }
      setAttr(attr, val) {
        var func = this[SET2 + Util._capitalize(attr)];
        return Util._isFunction(func) ? func.call(this, val) : this._setAttr(attr, val), this;
      }
      _requestDraw() {
        if (Konva.autoDrawEnabled) {
          let drawNode = this.getLayer() || this.getStage();
          drawNode == null || drawNode.batchDraw();
        }
      }
      _setAttr(key, val) {
        var oldVal = this.attrs[key];
        oldVal === val && !Util.isObject(val) || (val == null ? delete this.attrs[key] : this.attrs[key] = val, this._shouldFireChangeEvents && this._fireChangeEvent(key, oldVal, val), this._requestDraw());
      }
      _setComponentAttr(key, component, val) {
        var oldVal;
        val !== void 0 && (oldVal = this.attrs[key], oldVal || (this.attrs[key] = this.getAttr(key)), this.attrs[key][component] = val, this._fireChangeEvent(key, oldVal, val));
      }
      _fireAndBubble(eventType, evt, compareShape) {
        evt && this.nodeType === SHAPE && (evt.target = this);
        var shouldStop = (eventType === MOUSEENTER || eventType === MOUSELEAVE) && (compareShape && (this === compareShape || this.isAncestorOf && this.isAncestorOf(compareShape)) || this.nodeType === "Stage" && !compareShape);
        if (!shouldStop) {
          this._fire(eventType, evt);
          var stopBubble = (eventType === MOUSEENTER || eventType === MOUSELEAVE) && compareShape && compareShape.isAncestorOf && compareShape.isAncestorOf(this) && !compareShape.isAncestorOf(this.parent);
          (evt && !evt.cancelBubble || !evt) && this.parent && this.parent.isListening() && !stopBubble && (compareShape && compareShape.parent ? this._fireAndBubble.call(this.parent, eventType, evt, compareShape) : this._fireAndBubble.call(this.parent, eventType, evt));
        }
      }
      _getProtoListeners(eventType) {
        let listeners = this._cache.get(ALL_LISTENERS);
        if (!listeners) {
          listeners = {};
          let obj = Object.getPrototypeOf(this);
          for (; obj; ) {
            if (!obj.eventListeners) {
              obj = Object.getPrototypeOf(obj);
              continue;
            }
            for (var event in obj.eventListeners) {
              let newEvents = obj.eventListeners[event], oldEvents = listeners[event] || [];
              listeners[event] = newEvents.concat(oldEvents);
            }
            obj = Object.getPrototypeOf(obj);
          }
          this._cache.set(ALL_LISTENERS, listeners);
        }
        return listeners[eventType];
      }
      _fire(eventType, evt) {
        evt = evt || {}, evt.currentTarget = this, evt.type = eventType;
        let topListeners = this._getProtoListeners(eventType);
        if (topListeners)
          for (var i = 0; i < topListeners.length; i++)
            topListeners[i].handler.call(this, evt);
        let selfListeners = this.eventListeners[eventType];
        if (selfListeners)
          for (var i = 0; i < selfListeners.length; i++)
            selfListeners[i].handler.call(this, evt);
      }
      draw() {
        return this.drawScene(), this.drawHit(), this;
      }
      _createDragElement(evt) {
        var pointerId = evt ? evt.pointerId : void 0, stage = this.getStage(), ap = this.getAbsolutePosition(), pos = stage._getPointerById(pointerId) || stage._changedPointerPositions[0] || ap;
        DD._dragElements.set(this._id, {
          node: this,
          startPointerPos: pos,
          offset: {
            x: pos.x - ap.x,
            y: pos.y - ap.y
          },
          dragStatus: "ready",
          pointerId
        });
      }
      startDrag(evt, bubbleEvent = !0) {
        DD._dragElements.has(this._id) || this._createDragElement(evt);
        let elem = DD._dragElements.get(this._id);
        elem.dragStatus = "dragging", this.fire("dragstart", {
          type: "dragstart",
          target: this,
          evt: evt && evt.evt
        }, bubbleEvent);
      }
      _setDragPosition(evt, elem) {
        let pos = this.getStage()._getPointerById(elem.pointerId);
        if (!!pos) {
          var newNodePos = {
            x: pos.x - elem.offset.x,
            y: pos.y - elem.offset.y
          }, dbf = this.dragBoundFunc();
          if (dbf !== void 0) {
            let bounded = dbf.call(this, newNodePos, evt);
            bounded ? newNodePos = bounded : Util.warn("dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.");
          }
          (!this._lastPos || this._lastPos.x !== newNodePos.x || this._lastPos.y !== newNodePos.y) && (this.setAbsolutePosition(newNodePos), this._requestDraw()), this._lastPos = newNodePos;
        }
      }
      stopDrag(evt) {
        let elem = DD._dragElements.get(this._id);
        elem && (elem.dragStatus = "stopped"), DD._endDragBefore(evt), DD._endDragAfter(evt);
      }
      setDraggable(draggable) {
        this._setAttr("draggable", draggable), this._dragChange();
      }
      isDragging() {
        let elem = DD._dragElements.get(this._id);
        return elem ? elem.dragStatus === "dragging" : !1;
      }
      _listenDrag() {
        this._dragCleanup(), this.on("mousedown.konva touchstart.konva", function(evt) {
          var shouldCheckButton = evt.evt.button !== void 0, canDrag = !shouldCheckButton || Konva.dragButtons.indexOf(evt.evt.button) >= 0;
          if (!!canDrag && !this.isDragging()) {
            var hasDraggingChild = !1;
            DD._dragElements.forEach((elem) => {
              this.isAncestorOf(elem.node) && (hasDraggingChild = !0);
            }), hasDraggingChild || this._createDragElement(evt);
          }
        });
      }
      _dragChange() {
        if (this.attrs.draggable)
          this._listenDrag();
        else {
          this._dragCleanup();
          var stage = this.getStage();
          if (!stage)
            return;
          let dragElement = DD._dragElements.get(this._id), isDragging = dragElement && dragElement.dragStatus === "dragging", isReady = dragElement && dragElement.dragStatus === "ready";
          isDragging ? this.stopDrag() : isReady && DD._dragElements.delete(this._id);
        }
      }
      _dragCleanup() {
        this.off("mousedown.konva"), this.off("touchstart.konva");
      }
      isClientRectOnScreen(margin = { x: 0, y: 0 }) {
        let stage = this.getStage();
        if (!stage)
          return !1;
        let screenRect = {
          x: -margin.x,
          y: -margin.y,
          width: stage.width() + 2 * margin.x,
          height: stage.height() + 2 * margin.y
        };
        return Util.haveIntersection(screenRect, this.getClientRect());
      }
      static create(data, container) {
        return Util._isString(data) && (data = JSON.parse(data)), this._createNode(data, container);
      }
      static _createNode(obj, container) {
        var className = Node.prototype.getClassName.call(obj), children = obj.children, no, len, n;
        container && (obj.attrs.container = container), Konva[className] || (Util.warn('Can not find a node with class name "' + className + '". Fallback to "Shape".'), className = "Shape");
        let Class = Konva[className];
        if (no = new Class(obj.attrs), children)
          for (len = children.length, n = 0; n < len; n++)
            no.add(Node._createNode(children[n]));
        return no;
      }
    };
    Node.prototype.nodeType = "Node";
    Node.prototype._attrsAffectingSize = [];
    Node.prototype.eventListeners = {};
    Node.prototype.on.call(Node.prototype, TRANSFORM_CHANGE_STR, function() {
      if (this._batchingTransformChange) {
        this._needClearTransformCache = !0;
        return;
      }
      this._clearCache(TRANSFORM), this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
    });
    Node.prototype.on.call(Node.prototype, "visibleChange.konva", function() {
      this._clearSelfAndDescendantCache(VISIBLE);
    });
    Node.prototype.on.call(Node.prototype, "listeningChange.konva", function() {
      this._clearSelfAndDescendantCache(LISTENING);
    });
    Node.prototype.on.call(Node.prototype, "opacityChange.konva", function() {
      this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
    });
    addGetterSetter = Factory.addGetterSetter;
    addGetterSetter(Node, "zIndex");
    addGetterSetter(Node, "absolutePosition");
    addGetterSetter(Node, "position");
    addGetterSetter(Node, "x", 0, getNumberValidator());
    addGetterSetter(Node, "y", 0, getNumberValidator());
    addGetterSetter(Node, "globalCompositeOperation", "source-over", getStringValidator());
    addGetterSetter(Node, "opacity", 1, getNumberValidator());
    addGetterSetter(Node, "name", "", getStringValidator());
    addGetterSetter(Node, "id", "", getStringValidator());
    addGetterSetter(Node, "rotation", 0, getNumberValidator());
    Factory.addComponentsGetterSetter(Node, "scale", ["x", "y"]);
    addGetterSetter(Node, "scaleX", 1, getNumberValidator());
    addGetterSetter(Node, "scaleY", 1, getNumberValidator());
    Factory.addComponentsGetterSetter(Node, "skew", ["x", "y"]);
    addGetterSetter(Node, "skewX", 0, getNumberValidator());
    addGetterSetter(Node, "skewY", 0, getNumberValidator());
    Factory.addComponentsGetterSetter(Node, "offset", ["x", "y"]);
    addGetterSetter(Node, "offsetX", 0, getNumberValidator());
    addGetterSetter(Node, "offsetY", 0, getNumberValidator());
    addGetterSetter(Node, "dragDistance", null, getNumberValidator());
    addGetterSetter(Node, "width", 0, getNumberValidator());
    addGetterSetter(Node, "height", 0, getNumberValidator());
    addGetterSetter(Node, "listening", !0, getBooleanValidator());
    addGetterSetter(Node, "preventDefault", !0, getBooleanValidator());
    addGetterSetter(Node, "filters", null, function(val) {
      return this._filterUpToDate = !1, val;
    });
    addGetterSetter(Node, "visible", !0, getBooleanValidator());
    addGetterSetter(Node, "transformsEnabled", "all", getStringValidator());
    addGetterSetter(Node, "size");
    addGetterSetter(Node, "dragBoundFunc");
    addGetterSetter(Node, "draggable", !1, getBooleanValidator());
    Factory.backCompat(Node, {
      rotateDeg: "rotate",
      setRotationDeg: "setRotation",
      getRotationDeg: "getRotation"
    });
  }
});

// node_modules/konva/lib/Container.js
var Container, init_Container = __esm({
  "node_modules/konva/lib/Container.js"() {
    init_Factory();
    init_Node();
    init_Validators();
    Container = class extends Node {
      constructor() {
        super(...arguments), this.children = [];
      }
      getChildren(filterFunc) {
        if (!filterFunc)
          return this.children || [];
        let children = this.children || [];
        var results = [];
        return children.forEach(function(child) {
          filterFunc(child) && results.push(child);
        }), results;
      }
      hasChildren() {
        return this.getChildren().length > 0;
      }
      removeChildren() {
        return this.getChildren().forEach((child) => {
          child.parent = null, child.index = 0, child.remove();
        }), this.children = [], this._requestDraw(), this;
      }
      destroyChildren() {
        return this.getChildren().forEach((child) => {
          child.parent = null, child.index = 0, child.destroy();
        }), this.children = [], this._requestDraw(), this;
      }
      add(...children) {
        if (arguments.length > 1) {
          for (var i = 0; i < arguments.length; i++)
            this.add(arguments[i]);
          return this;
        }
        var child = children[0];
        return child.getParent() ? (child.moveTo(this), this) : (this._validateAdd(child), child.index = this.getChildren().length, child.parent = this, child._clearCaches(), this.getChildren().push(child), this._fire("add", {
          child
        }), this._requestDraw(), this);
      }
      destroy() {
        return this.hasChildren() && this.destroyChildren(), super.destroy(), this;
      }
      find(selector) {
        return this._generalFind(selector, !1);
      }
      findOne(selector) {
        var result = this._generalFind(selector, !0);
        return result.length > 0 ? result[0] : void 0;
      }
      _generalFind(selector, findOne) {
        var retArr = [];
        return this._descendants((node) => {
          let valid = node._isMatch(selector);
          return valid && retArr.push(node), !!(valid && findOne);
        }), retArr;
      }
      _descendants(fn) {
        let shouldStop = !1, children = this.getChildren();
        for (let child of children) {
          if (shouldStop = fn(child), shouldStop)
            return !0;
          if (!!child.hasChildren() && (shouldStop = child._descendants(fn), shouldStop))
            return !0;
        }
        return !1;
      }
      toObject() {
        var obj = Node.prototype.toObject.call(this);
        return obj.children = [], this.getChildren().forEach((child) => {
          obj.children.push(child.toObject());
        }), obj;
      }
      isAncestorOf(node) {
        for (var parent = node.getParent(); parent; ) {
          if (parent._id === this._id)
            return !0;
          parent = parent.getParent();
        }
        return !1;
      }
      clone(obj) {
        var node = Node.prototype.clone.call(this, obj);
        return this.getChildren().forEach(function(no) {
          node.add(no.clone());
        }), node;
      }
      getAllIntersections(pos) {
        var arr = [];
        return this.find("Shape").forEach(function(shape) {
          shape.isVisible() && shape.intersects(pos) && arr.push(shape);
        }), arr;
      }
      _clearSelfAndDescendantCache(attr) {
        var _a;
        super._clearSelfAndDescendantCache(attr), !this.isCached() && ((_a = this.children) === null || _a === void 0 || _a.forEach(function(node) {
          node._clearSelfAndDescendantCache(attr);
        }));
      }
      _setChildrenIndices() {
        var _a;
        (_a = this.children) === null || _a === void 0 || _a.forEach(function(child, n) {
          child.index = n;
        }), this._requestDraw();
      }
      drawScene(can, top) {
        var layer = this.getLayer(), canvas = can || layer && layer.getCanvas(), context = canvas && canvas.getContext(), cachedCanvas = this._getCanvasCache(), cachedSceneCanvas = cachedCanvas && cachedCanvas.scene, caching = canvas && canvas.isCache;
        if (!this.isVisible() && !caching)
          return this;
        if (cachedSceneCanvas) {
          context.save();
          var m = this.getAbsoluteTransform(top).getMatrix();
          context.transform(m[0], m[1], m[2], m[3], m[4], m[5]), this._drawCachedSceneCanvas(context), context.restore();
        } else
          this._drawChildren("drawScene", canvas, top);
        return this;
      }
      drawHit(can, top) {
        if (!this.shouldDrawHit(top))
          return this;
        var layer = this.getLayer(), canvas = can || layer && layer.hitCanvas, context = canvas && canvas.getContext(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;
        if (cachedHitCanvas) {
          context.save();
          var m = this.getAbsoluteTransform(top).getMatrix();
          context.transform(m[0], m[1], m[2], m[3], m[4], m[5]), this._drawCachedHitCanvas(context), context.restore();
        } else
          this._drawChildren("drawHit", canvas, top);
        return this;
      }
      _drawChildren(drawMethod, canvas, top) {
        var _a, context = canvas && canvas.getContext(), clipWidth = this.clipWidth(), clipHeight = this.clipHeight(), clipFunc = this.clipFunc(), hasClip = clipWidth && clipHeight || clipFunc;
        let selfCache = top === this;
        if (hasClip) {
          context.save();
          var transform = this.getAbsoluteTransform(top), m = transform.getMatrix();
          if (context.transform(m[0], m[1], m[2], m[3], m[4], m[5]), context.beginPath(), clipFunc)
            clipFunc.call(this, context, this);
          else {
            var clipX = this.clipX(), clipY = this.clipY();
            context.rect(clipX, clipY, clipWidth, clipHeight);
          }
          context.clip(), m = transform.copy().invert().getMatrix(), context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
        }
        var hasComposition = !selfCache && this.globalCompositeOperation() !== "source-over" && drawMethod === "drawScene";
        hasComposition && (context.save(), context._applyGlobalCompositeOperation(this)), (_a = this.children) === null || _a === void 0 || _a.forEach(function(child) {
          child[drawMethod](canvas, top);
        }), hasComposition && context.restore(), hasClip && context.restore();
      }
      getClientRect(config) {
        var _a;
        config = config || {};
        var skipTransform = config.skipTransform, relativeTo = config.relativeTo, minX, minY, maxX, maxY, selfRect = {
          x: 1 / 0,
          y: 1 / 0,
          width: 0,
          height: 0
        }, that = this;
        (_a = this.children) === null || _a === void 0 || _a.forEach(function(child) {
          if (!!child.visible()) {
            var rect = child.getClientRect({
              relativeTo: that,
              skipShadow: config.skipShadow,
              skipStroke: config.skipStroke
            });
            rect.width === 0 && rect.height === 0 || (minX === void 0 ? (minX = rect.x, minY = rect.y, maxX = rect.x + rect.width, maxY = rect.y + rect.height) : (minX = Math.min(minX, rect.x), minY = Math.min(minY, rect.y), maxX = Math.max(maxX, rect.x + rect.width), maxY = Math.max(maxY, rect.y + rect.height)));
          }
        });
        for (var shapes2 = this.find("Shape"), hasVisible = !1, i = 0; i < shapes2.length; i++) {
          var shape = shapes2[i];
          if (shape._isVisible(this)) {
            hasVisible = !0;
            break;
          }
        }
        return hasVisible && minX !== void 0 ? selfRect = {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        } : selfRect = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        }, skipTransform ? selfRect : this._transformedRect(selfRect, relativeTo);
      }
    };
    Factory.addComponentsGetterSetter(Container, "clip", [
      "x",
      "y",
      "width",
      "height"
    ]);
    Factory.addGetterSetter(Container, "clipX", void 0, getNumberValidator());
    Factory.addGetterSetter(Container, "clipY", void 0, getNumberValidator());
    Factory.addGetterSetter(Container, "clipWidth", void 0, getNumberValidator());
    Factory.addGetterSetter(Container, "clipHeight", void 0, getNumberValidator());
    Factory.addGetterSetter(Container, "clipFunc");
  }
});

// node_modules/konva/lib/PointerEvents.js
function getCapturedShape(pointerId) {
  return Captures.get(pointerId);
}
function createEvent(evt) {
  return {
    evt,
    pointerId: evt.pointerId
  };
}
function hasPointerCapture(pointerId, shape) {
  return Captures.get(pointerId) === shape;
}
function setPointerCapture(pointerId, shape) {
  releaseCapture(pointerId), shape.getStage() && (Captures.set(pointerId, shape), SUPPORT_POINTER_EVENTS && shape._fire("gotpointercapture", createEvent(new PointerEvent("gotpointercapture"))));
}
function releaseCapture(pointerId, target) {
  let shape = Captures.get(pointerId);
  if (!shape)
    return;
  let stage = shape.getStage();
  stage && stage.content, Captures.delete(pointerId), SUPPORT_POINTER_EVENTS && shape._fire("lostpointercapture", createEvent(new PointerEvent("lostpointercapture")));
}
var Captures, SUPPORT_POINTER_EVENTS, init_PointerEvents = __esm({
  "node_modules/konva/lib/PointerEvents.js"() {
    init_Global();
    Captures = /* @__PURE__ */ new Map(), SUPPORT_POINTER_EVENTS = Konva._global.PointerEvent !== void 0;
  }
});

// node_modules/konva/lib/Stage.js
function checkNoClip(attrs = {}) {
  return (attrs.clipFunc || attrs.clipWidth || attrs.clipHeight) && Util.warn("Stage does not support clipping. Please use clip for Layers or Groups."), attrs;
}
var STAGE2, STRING, PX, MOUSEOUT, MOUSELEAVE2, MOUSEOVER, MOUSEENTER2, MOUSEMOVE, MOUSEDOWN, MOUSEUP, POINTERMOVE, POINTERDOWN, POINTERUP, POINTERCANCEL, LOSTPOINTERCAPTURE, POINTEROUT, POINTERLEAVE, POINTEROVER, POINTERENTER, CONTEXTMENU, TOUCHSTART, TOUCHEND, TOUCHMOVE, TOUCHCANCEL, WHEEL, MAX_LAYERS_NUMBER, EVENTS, EVENTS_MAP, getEventType, getEventsMap, NO_POINTERS_MESSAGE, stages, Stage, init_Stage = __esm({
  "node_modules/konva/lib/Stage.js"() {
    init_Util();
    init_Factory();
    init_Container();
    init_Global();
    init_Canvas();
    init_DragAndDrop();
    init_Global();
    init_PointerEvents();
    STAGE2 = "Stage", STRING = "string", PX = "px", MOUSEOUT = "mouseout", MOUSELEAVE2 = "mouseleave", MOUSEOVER = "mouseover", MOUSEENTER2 = "mouseenter", MOUSEMOVE = "mousemove", MOUSEDOWN = "mousedown", MOUSEUP = "mouseup", POINTERMOVE = "pointermove", POINTERDOWN = "pointerdown", POINTERUP = "pointerup", POINTERCANCEL = "pointercancel", LOSTPOINTERCAPTURE = "lostpointercapture", POINTEROUT = "pointerout", POINTERLEAVE = "pointerleave", POINTEROVER = "pointerover", POINTERENTER = "pointerenter", CONTEXTMENU = "contextmenu", TOUCHSTART = "touchstart", TOUCHEND = "touchend", TOUCHMOVE = "touchmove", TOUCHCANCEL = "touchcancel", WHEEL = "wheel", MAX_LAYERS_NUMBER = 5, EVENTS = [
      [MOUSEENTER2, "_pointerenter"],
      [MOUSEDOWN, "_pointerdown"],
      [MOUSEMOVE, "_pointermove"],
      [MOUSEUP, "_pointerup"],
      [MOUSELEAVE2, "_pointerleave"],
      [TOUCHSTART, "_pointerdown"],
      [TOUCHMOVE, "_pointermove"],
      [TOUCHEND, "_pointerup"],
      [TOUCHCANCEL, "_pointercancel"],
      [MOUSEOVER, "_pointerover"],
      [WHEEL, "_wheel"],
      [CONTEXTMENU, "_contextmenu"],
      [POINTERDOWN, "_pointerdown"],
      [POINTERMOVE, "_pointermove"],
      [POINTERUP, "_pointerup"],
      [POINTERCANCEL, "_pointercancel"],
      [LOSTPOINTERCAPTURE, "_lostpointercapture"]
    ], EVENTS_MAP = {
      mouse: {
        [POINTEROUT]: MOUSEOUT,
        [POINTERLEAVE]: MOUSELEAVE2,
        [POINTEROVER]: MOUSEOVER,
        [POINTERENTER]: MOUSEENTER2,
        [POINTERMOVE]: MOUSEMOVE,
        [POINTERDOWN]: MOUSEDOWN,
        [POINTERUP]: MOUSEUP,
        [POINTERCANCEL]: "mousecancel",
        pointerclick: "click",
        pointerdblclick: "dblclick"
      },
      touch: {
        [POINTEROUT]: "touchout",
        [POINTERLEAVE]: "touchleave",
        [POINTEROVER]: "touchover",
        [POINTERENTER]: "touchenter",
        [POINTERMOVE]: TOUCHMOVE,
        [POINTERDOWN]: TOUCHSTART,
        [POINTERUP]: TOUCHEND,
        [POINTERCANCEL]: TOUCHCANCEL,
        pointerclick: "tap",
        pointerdblclick: "dbltap"
      },
      pointer: {
        [POINTEROUT]: POINTEROUT,
        [POINTERLEAVE]: POINTERLEAVE,
        [POINTEROVER]: POINTEROVER,
        [POINTERENTER]: POINTERENTER,
        [POINTERMOVE]: POINTERMOVE,
        [POINTERDOWN]: POINTERDOWN,
        [POINTERUP]: POINTERUP,
        [POINTERCANCEL]: POINTERCANCEL,
        pointerclick: "pointerclick",
        pointerdblclick: "pointerdblclick"
      }
    }, getEventType = (type) => type.indexOf("pointer") >= 0 ? "pointer" : type.indexOf("touch") >= 0 ? "touch" : "mouse", getEventsMap = (eventType) => {
      let type = getEventType(eventType);
      if (type === "pointer")
        return Konva.pointerEventsEnabled && EVENTS_MAP.pointer;
      if (type === "touch")
        return EVENTS_MAP.touch;
      if (type === "mouse")
        return EVENTS_MAP.mouse;
    };
    NO_POINTERS_MESSAGE = "Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);", stages = [], Stage = class extends Container {
      constructor(config) {
        super(checkNoClip(config)), this._pointerPositions = [], this._changedPointerPositions = [], this._buildDOM(), this._bindContentEvents(), stages.push(this), this.on("widthChange.konva heightChange.konva", this._resizeDOM), this.on("visibleChange.konva", this._checkVisibility), this.on("clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva", () => {
          checkNoClip(this.attrs);
        }), this._checkVisibility();
      }
      _validateAdd(child) {
        let isLayer = child.getType() === "Layer", isFastLayer = child.getType() === "FastLayer";
        isLayer || isFastLayer || Util.throw("You may only add layers to the stage.");
      }
      _checkVisibility() {
        if (!this.content)
          return;
        let style = this.visible() ? "" : "none";
        this.content.style.display = style;
      }
      setContainer(container) {
        if (typeof container === STRING) {
          if (container.charAt(0) === ".") {
            var className = container.slice(1);
            container = document.getElementsByClassName(className)[0];
          } else {
            var id;
            container.charAt(0) !== "#" ? id = container : id = container.slice(1), container = document.getElementById(id);
          }
          if (!container)
            throw "Can not find container in document with id " + id;
        }
        return this._setAttr("container", container), this.content && (this.content.parentElement && this.content.parentElement.removeChild(this.content), container.appendChild(this.content)), this;
      }
      shouldDrawHit() {
        return !0;
      }
      clear() {
        var layers = this.children, len = layers.length, n;
        for (n = 0; n < len; n++)
          layers[n].clear();
        return this;
      }
      clone(obj) {
        return obj || (obj = {}), obj.container = typeof document < "u" && document.createElement("div"), Container.prototype.clone.call(this, obj);
      }
      destroy() {
        super.destroy();
        var content = this.content;
        content && Util._isInDocument(content) && this.container().removeChild(content);
        var index = stages.indexOf(this);
        return index > -1 && stages.splice(index, 1), Util.releaseCanvas(this.bufferCanvas._canvas, this.bufferHitCanvas._canvas), this;
      }
      getPointerPosition() {
        let pos = this._pointerPositions[0] || this._changedPointerPositions[0];
        return pos ? {
          x: pos.x,
          y: pos.y
        } : (Util.warn(NO_POINTERS_MESSAGE), null);
      }
      _getPointerById(id) {
        return this._pointerPositions.find((p) => p.id === id);
      }
      getPointersPositions() {
        return this._pointerPositions;
      }
      getStage() {
        return this;
      }
      getContent() {
        return this.content;
      }
      _toKonvaCanvas(config) {
        config = config || {}, config.x = config.x || 0, config.y = config.y || 0, config.width = config.width || this.width(), config.height = config.height || this.height();
        var canvas = new SceneCanvas({
          width: config.width,
          height: config.height,
          pixelRatio: config.pixelRatio || 1
        }), _context = canvas.getContext()._context, layers = this.children;
        return (config.x || config.y) && _context.translate(-1 * config.x, -1 * config.y), layers.forEach(function(layer) {
          if (!!layer.isVisible()) {
            var layerCanvas = layer._toKonvaCanvas(config);
            _context.drawImage(layerCanvas._canvas, config.x, config.y, layerCanvas.getWidth() / layerCanvas.getPixelRatio(), layerCanvas.getHeight() / layerCanvas.getPixelRatio());
          }
        }), canvas;
      }
      getIntersection(pos) {
        if (!pos)
          return null;
        var layers = this.children, len = layers.length, end = len - 1, n;
        for (n = end; n >= 0; n--) {
          let shape = layers[n].getIntersection(pos);
          if (shape)
            return shape;
        }
        return null;
      }
      _resizeDOM() {
        var width = this.width(), height = this.height();
        this.content && (this.content.style.width = width + PX, this.content.style.height = height + PX), this.bufferCanvas.setSize(width, height), this.bufferHitCanvas.setSize(width, height), this.children.forEach((layer) => {
          layer.setSize({ width, height }), layer.draw();
        });
      }
      add(layer, ...rest) {
        if (arguments.length > 1) {
          for (var i = 0; i < arguments.length; i++)
            this.add(arguments[i]);
          return this;
        }
        super.add(layer);
        var length = this.children.length;
        return length > MAX_LAYERS_NUMBER && Util.warn("The stage has " + length + " layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group."), layer.setSize({ width: this.width(), height: this.height() }), layer.draw(), Konva.isBrowser && this.content.appendChild(layer.canvas._canvas), this;
      }
      getParent() {
        return null;
      }
      getLayer() {
        return null;
      }
      hasPointerCapture(pointerId) {
        return hasPointerCapture(pointerId, this);
      }
      setPointerCapture(pointerId) {
        setPointerCapture(pointerId, this);
      }
      releaseCapture(pointerId) {
        releaseCapture(pointerId, this);
      }
      getLayers() {
        return this.children;
      }
      _bindContentEvents() {
        !Konva.isBrowser || EVENTS.forEach(([event, methodName]) => {
          this.content.addEventListener(event, (evt) => {
            this[methodName](evt);
          }, { passive: !1 });
        });
      }
      _pointerenter(evt) {
        this.setPointersPositions(evt);
        let events = getEventsMap(evt.type);
        this._fire(events.pointerenter, {
          evt,
          target: this,
          currentTarget: this
        });
      }
      _pointerover(evt) {
        this.setPointersPositions(evt);
        let events = getEventsMap(evt.type);
        this._fire(events.pointerover, {
          evt,
          target: this,
          currentTarget: this
        });
      }
      _getTargetShape(evenType) {
        let shape = this[evenType + "targetShape"];
        return shape && !shape.getStage() && (shape = null), shape;
      }
      _pointerleave(evt) {
        let events = getEventsMap(evt.type), eventType = getEventType(evt.type);
        if (!!events) {
          this.setPointersPositions(evt);
          var targetShape = this._getTargetShape(eventType), eventsEnabled = !DD.isDragging || Konva.hitOnDragEnabled;
          targetShape && eventsEnabled ? (targetShape._fireAndBubble(events.pointerout, { evt }), targetShape._fireAndBubble(events.pointerleave, { evt }), this._fire(events.pointerleave, {
            evt,
            target: this,
            currentTarget: this
          }), this[eventType + "targetShape"] = null) : eventsEnabled && (this._fire(events.pointerleave, {
            evt,
            target: this,
            currentTarget: this
          }), this._fire(events.pointerout, {
            evt,
            target: this,
            currentTarget: this
          })), this.pointerPos = void 0, this._pointerPositions = [];
        }
      }
      _pointerdown(evt) {
        let events = getEventsMap(evt.type), eventType = getEventType(evt.type);
        if (!!events) {
          this.setPointersPositions(evt);
          var triggeredOnShape = !1;
          this._changedPointerPositions.forEach((pos) => {
            var shape = this.getIntersection(pos);
            if (DD.justDragged = !1, Konva["_" + eventType + "ListenClick"] = !0, !(shape && shape.isListening()))
              return;
            Konva.capturePointerEventsEnabled && shape.setPointerCapture(pos.id), this[eventType + "ClickStartShape"] = shape, shape._fireAndBubble(events.pointerdown, {
              evt,
              pointerId: pos.id
            }), triggeredOnShape = !0;
            let isTouch = evt.type.indexOf("touch") >= 0;
            shape.preventDefault() && evt.cancelable && isTouch && evt.preventDefault();
          }), triggeredOnShape || this._fire(events.pointerdown, {
            evt,
            target: this,
            currentTarget: this,
            pointerId: this._pointerPositions[0].id
          });
        }
      }
      _pointermove(evt) {
        let events = getEventsMap(evt.type), eventType = getEventType(evt.type);
        if (!events)
          return;
        DD.isDragging && DD.node.preventDefault() && evt.cancelable && evt.preventDefault(), this.setPointersPositions(evt);
        var eventsEnabled = !DD.isDragging || Konva.hitOnDragEnabled;
        if (!eventsEnabled)
          return;
        var processedShapesIds = {};
        let triggeredOnShape = !1;
        var targetShape = this._getTargetShape(eventType);
        this._changedPointerPositions.forEach((pos) => {
          let shape = getCapturedShape(pos.id) || this.getIntersection(pos), pointerId = pos.id, event = { evt, pointerId };
          var differentTarget = targetShape !== shape;
          if (differentTarget && targetShape && (targetShape._fireAndBubble(events.pointerout, Object.assign({}, event), shape), targetShape._fireAndBubble(events.pointerleave, Object.assign({}, event), shape)), shape) {
            if (processedShapesIds[shape._id])
              return;
            processedShapesIds[shape._id] = !0;
          }
          shape && shape.isListening() ? (triggeredOnShape = !0, differentTarget && (shape._fireAndBubble(events.pointerover, Object.assign({}, event), targetShape), shape._fireAndBubble(events.pointerenter, Object.assign({}, event), targetShape), this[eventType + "targetShape"] = shape), shape._fireAndBubble(events.pointermove, Object.assign({}, event))) : targetShape && (this._fire(events.pointerover, {
            evt,
            target: this,
            currentTarget: this,
            pointerId
          }), this[eventType + "targetShape"] = null);
        }), triggeredOnShape || this._fire(events.pointermove, {
          evt,
          target: this,
          currentTarget: this,
          pointerId: this._changedPointerPositions[0].id
        });
      }
      _pointerup(evt) {
        let events = getEventsMap(evt.type), eventType = getEventType(evt.type);
        if (!events)
          return;
        this.setPointersPositions(evt);
        let clickStartShape = this[eventType + "ClickStartShape"], clickEndShape = this[eventType + "ClickEndShape"];
        var processedShapesIds = {};
        let triggeredOnShape = !1;
        this._changedPointerPositions.forEach((pos) => {
          let shape = getCapturedShape(pos.id) || this.getIntersection(pos);
          if (shape) {
            if (shape.releaseCapture(pos.id), processedShapesIds[shape._id])
              return;
            processedShapesIds[shape._id] = !0;
          }
          let pointerId = pos.id, event = { evt, pointerId }, fireDblClick = !1;
          Konva["_" + eventType + "InDblClickWindow"] ? (fireDblClick = !0, clearTimeout(this[eventType + "DblTimeout"])) : DD.justDragged || (Konva["_" + eventType + "InDblClickWindow"] = !0, clearTimeout(this[eventType + "DblTimeout"])), this[eventType + "DblTimeout"] = setTimeout(function() {
            Konva["_" + eventType + "InDblClickWindow"] = !1;
          }, Konva.dblClickWindow), shape && shape.isListening() ? (triggeredOnShape = !0, this[eventType + "ClickEndShape"] = shape, shape._fireAndBubble(events.pointerup, Object.assign({}, event)), Konva["_" + eventType + "ListenClick"] && clickStartShape && clickStartShape === shape && (shape._fireAndBubble(events.pointerclick, Object.assign({}, event)), fireDblClick && clickEndShape && clickEndShape === shape && shape._fireAndBubble(events.pointerdblclick, Object.assign({}, event)))) : (this[eventType + "ClickEndShape"] = null, Konva["_" + eventType + "ListenClick"] && this._fire(events.pointerclick, {
            evt,
            target: this,
            currentTarget: this,
            pointerId
          }), fireDblClick && this._fire(events.pointerdblclick, {
            evt,
            target: this,
            currentTarget: this,
            pointerId
          }));
        }), triggeredOnShape || this._fire(events.pointerup, {
          evt,
          target: this,
          currentTarget: this,
          pointerId: this._changedPointerPositions[0].id
        }), Konva["_" + eventType + "ListenClick"] = !1, evt.cancelable && eventType !== "touch" && evt.preventDefault();
      }
      _contextmenu(evt) {
        this.setPointersPositions(evt);
        var shape = this.getIntersection(this.getPointerPosition());
        shape && shape.isListening() ? shape._fireAndBubble(CONTEXTMENU, { evt }) : this._fire(CONTEXTMENU, {
          evt,
          target: this,
          currentTarget: this
        });
      }
      _wheel(evt) {
        this.setPointersPositions(evt);
        var shape = this.getIntersection(this.getPointerPosition());
        shape && shape.isListening() ? shape._fireAndBubble(WHEEL, { evt }) : this._fire(WHEEL, {
          evt,
          target: this,
          currentTarget: this
        });
      }
      _pointercancel(evt) {
        this.setPointersPositions(evt);
        let shape = getCapturedShape(evt.pointerId) || this.getIntersection(this.getPointerPosition());
        shape && shape._fireAndBubble(POINTERUP, createEvent(evt)), releaseCapture(evt.pointerId);
      }
      _lostpointercapture(evt) {
        releaseCapture(evt.pointerId);
      }
      setPointersPositions(evt) {
        var contentPosition = this._getContentPosition(), x = null, y = null;
        evt = evt || window.event, evt.touches !== void 0 ? (this._pointerPositions = [], this._changedPointerPositions = [], Array.prototype.forEach.call(evt.touches, (touch) => {
          this._pointerPositions.push({
            id: touch.identifier,
            x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,
            y: (touch.clientY - contentPosition.top) / contentPosition.scaleY
          });
        }), Array.prototype.forEach.call(evt.changedTouches || evt.touches, (touch) => {
          this._changedPointerPositions.push({
            id: touch.identifier,
            x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,
            y: (touch.clientY - contentPosition.top) / contentPosition.scaleY
          });
        })) : (x = (evt.clientX - contentPosition.left) / contentPosition.scaleX, y = (evt.clientY - contentPosition.top) / contentPosition.scaleY, this.pointerPos = {
          x,
          y
        }, this._pointerPositions = [{ x, y, id: Util._getFirstPointerId(evt) }], this._changedPointerPositions = [
          { x, y, id: Util._getFirstPointerId(evt) }
        ]);
      }
      _setPointerPosition(evt) {
        Util.warn('Method _setPointerPosition is deprecated. Use "stage.setPointersPositions(event)" instead.'), this.setPointersPositions(evt);
      }
      _getContentPosition() {
        if (!this.content || !this.content.getBoundingClientRect)
          return {
            top: 0,
            left: 0,
            scaleX: 1,
            scaleY: 1
          };
        var rect = this.content.getBoundingClientRect();
        return {
          top: rect.top,
          left: rect.left,
          scaleX: rect.width / this.content.clientWidth || 1,
          scaleY: rect.height / this.content.clientHeight || 1
        };
      }
      _buildDOM() {
        if (this.bufferCanvas = new SceneCanvas({
          width: this.width(),
          height: this.height()
        }), this.bufferHitCanvas = new HitCanvas({
          pixelRatio: 1,
          width: this.width(),
          height: this.height()
        }), !!Konva.isBrowser) {
          var container = this.container();
          if (!container)
            throw "Stage has no container. A container is required.";
          container.innerHTML = "", this.content = document.createElement("div"), this.content.style.position = "relative", this.content.style.userSelect = "none", this.content.className = "konvajs-content", this.content.setAttribute("role", "presentation"), container.appendChild(this.content), this._resizeDOM();
        }
      }
      cache() {
        return Util.warn("Cache function is not allowed for stage. You may use cache only for layers, groups and shapes."), this;
      }
      clearCache() {
        return this;
      }
      batchDraw() {
        return this.getChildren().forEach(function(layer) {
          layer.batchDraw();
        }), this;
      }
    };
    Stage.prototype.nodeType = STAGE2;
    _registerNode(Stage);
    Factory.addGetterSetter(Stage, "container");
  }
});

// node_modules/konva/lib/Shape.js
function getDummyContext() {
  return dummyContext || (dummyContext = Util.createCanvasElement().getContext("2d"), dummyContext);
}
function _fillFunc(context) {
  context.fill();
}
function _strokeFunc(context) {
  context.stroke();
}
function _fillFuncHit(context) {
  context.fill();
}
function _strokeFuncHit(context) {
  context.stroke();
}
function _clearHasShadowCache() {
  this._clearCache(HAS_SHADOW);
}
function _clearGetShadowRGBACache() {
  this._clearCache(SHADOW_RGBA);
}
function _clearFillPatternCache() {
  this._clearCache(patternImage);
}
function _clearLinearGradientCache() {
  this._clearCache(linearGradient);
}
function _clearRadialGradientCache() {
  this._clearCache(radialGradient);
}
var HAS_SHADOW, SHADOW_RGBA, patternImage, linearGradient, radialGradient, dummyContext, shapes, Shape, init_Shape = __esm({
  "node_modules/konva/lib/Shape.js"() {
    init_Global();
    init_Util();
    init_Factory();
    init_Node();
    init_Validators();
    init_Global();
    init_PointerEvents();
    HAS_SHADOW = "hasShadow", SHADOW_RGBA = "shadowRGBA", patternImage = "patternImage", linearGradient = "linearGradient", radialGradient = "radialGradient";
    shapes = {};
    Shape = class extends Node {
      constructor(config) {
        super(config);
        let key;
        for (; key = Util.getRandomColor(), !(key && !(key in shapes)); )
          ;
        this.colorKey = key, shapes[key] = this;
      }
      getContext() {
        return Util.warn("shape.getContext() method is deprecated. Please do not use it."), this.getLayer().getContext();
      }
      getCanvas() {
        return Util.warn("shape.getCanvas() method is deprecated. Please do not use it."), this.getLayer().getCanvas();
      }
      getSceneFunc() {
        return this.attrs.sceneFunc || this._sceneFunc;
      }
      getHitFunc() {
        return this.attrs.hitFunc || this._hitFunc;
      }
      hasShadow() {
        return this._getCache(HAS_SHADOW, this._hasShadow);
      }
      _hasShadow() {
        return this.shadowEnabled() && this.shadowOpacity() !== 0 && !!(this.shadowColor() || this.shadowBlur() || this.shadowOffsetX() || this.shadowOffsetY());
      }
      _getFillPattern() {
        return this._getCache(patternImage, this.__getFillPattern);
      }
      __getFillPattern() {
        if (this.fillPatternImage()) {
          var ctx = getDummyContext();
          let pattern = ctx.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || "repeat");
          if (pattern && pattern.setTransform) {
            let tr = new Transform();
            tr.translate(this.fillPatternX(), this.fillPatternY()), tr.rotate(Konva.getAngle(this.fillPatternRotation())), tr.scale(this.fillPatternScaleX(), this.fillPatternScaleY()), tr.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());
            let m = tr.getMatrix(), matrix = typeof DOMMatrix > "u" ? {
              a: m[0],
              b: m[1],
              c: m[2],
              d: m[3],
              e: m[4],
              f: m[5]
            } : new DOMMatrix(m);
            pattern.setTransform(matrix);
          }
          return pattern;
        }
      }
      _getLinearGradient() {
        return this._getCache(linearGradient, this.__getLinearGradient);
      }
      __getLinearGradient() {
        var colorStops = this.fillLinearGradientColorStops();
        if (colorStops) {
          for (var ctx = getDummyContext(), start = this.fillLinearGradientStartPoint(), end = this.fillLinearGradientEndPoint(), grd = ctx.createLinearGradient(start.x, start.y, end.x, end.y), n = 0; n < colorStops.length; n += 2)
            grd.addColorStop(colorStops[n], colorStops[n + 1]);
          return grd;
        }
      }
      _getRadialGradient() {
        return this._getCache(radialGradient, this.__getRadialGradient);
      }
      __getRadialGradient() {
        var colorStops = this.fillRadialGradientColorStops();
        if (colorStops) {
          for (var ctx = getDummyContext(), start = this.fillRadialGradientStartPoint(), end = this.fillRadialGradientEndPoint(), grd = ctx.createRadialGradient(start.x, start.y, this.fillRadialGradientStartRadius(), end.x, end.y, this.fillRadialGradientEndRadius()), n = 0; n < colorStops.length; n += 2)
            grd.addColorStop(colorStops[n], colorStops[n + 1]);
          return grd;
        }
      }
      getShadowRGBA() {
        return this._getCache(SHADOW_RGBA, this._getShadowRGBA);
      }
      _getShadowRGBA() {
        if (!!this.hasShadow()) {
          var rgba = Util.colorToRGBA(this.shadowColor());
          if (rgba)
            return "rgba(" + rgba.r + "," + rgba.g + "," + rgba.b + "," + rgba.a * (this.shadowOpacity() || 1) + ")";
        }
      }
      hasFill() {
        return this._calculate("hasFill", [
          "fillEnabled",
          "fill",
          "fillPatternImage",
          "fillLinearGradientColorStops",
          "fillRadialGradientColorStops"
        ], () => this.fillEnabled() && !!(this.fill() || this.fillPatternImage() || this.fillLinearGradientColorStops() || this.fillRadialGradientColorStops()));
      }
      hasStroke() {
        return this._calculate("hasStroke", [
          "strokeEnabled",
          "strokeWidth",
          "stroke",
          "strokeLinearGradientColorStops"
        ], () => this.strokeEnabled() && this.strokeWidth() && !!(this.stroke() || this.strokeLinearGradientColorStops()));
      }
      hasHitStroke() {
        let width = this.hitStrokeWidth();
        return width === "auto" ? this.hasStroke() : this.strokeEnabled() && !!width;
      }
      intersects(point) {
        var stage = this.getStage(), bufferHitCanvas = stage.bufferHitCanvas, p;
        return bufferHitCanvas.getContext().clear(), this.drawHit(bufferHitCanvas, null, !0), p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data, p[3] > 0;
      }
      destroy() {
        return Node.prototype.destroy.call(this), delete shapes[this.colorKey], delete this.colorKey, this;
      }
      _useBufferCanvas(forceFill) {
        var _a;
        if (!this.getStage() || !((_a = this.attrs.perfectDrawEnabled) !== null && _a !== void 0 ? _a : !0))
          return !1;
        let hasFill = forceFill || this.hasFill(), hasStroke = this.hasStroke(), isTransparent = this.getAbsoluteOpacity() !== 1;
        if (hasFill && hasStroke && isTransparent)
          return !0;
        let hasShadow = this.hasShadow(), strokeForShadow = this.shadowForStrokeEnabled();
        return !!(hasFill && hasStroke && hasShadow && strokeForShadow);
      }
      setStrokeHitEnabled(val) {
        Util.warn("strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead."), val ? this.hitStrokeWidth("auto") : this.hitStrokeWidth(0);
      }
      getStrokeHitEnabled() {
        return this.hitStrokeWidth() !== 0;
      }
      getSelfRect() {
        var size = this.size();
        return {
          x: this._centroid ? -size.width / 2 : 0,
          y: this._centroid ? -size.height / 2 : 0,
          width: size.width,
          height: size.height
        };
      }
      getClientRect(config = {}) {
        let skipTransform = config.skipTransform, relativeTo = config.relativeTo, fillRect = this.getSelfRect(), strokeWidth = !config.skipStroke && this.hasStroke() && this.strokeWidth() || 0, fillAndStrokeWidth = fillRect.width + strokeWidth, fillAndStrokeHeight = fillRect.height + strokeWidth, applyShadow = !config.skipShadow && this.hasShadow(), shadowOffsetX = applyShadow ? this.shadowOffsetX() : 0, shadowOffsetY = applyShadow ? this.shadowOffsetY() : 0, preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX), preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY), blurRadius = applyShadow && this.shadowBlur() || 0, width = preWidth + blurRadius * 2, height = preHeight + blurRadius * 2, rect = {
          width,
          height,
          x: -(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetX, 0) + fillRect.x,
          y: -(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetY, 0) + fillRect.y
        };
        return skipTransform ? rect : this._transformedRect(rect, relativeTo);
      }
      drawScene(can, top) {
        var layer = this.getLayer(), canvas = can || layer.getCanvas(), context = canvas.getContext(), cachedCanvas = this._getCanvasCache(), drawFunc = this.getSceneFunc(), hasShadow = this.hasShadow(), stage, bufferCanvas, bufferContext, skipBuffer = canvas.isCache, cachingSelf = top === this;
        if (!this.isVisible() && !cachingSelf)
          return this;
        if (cachedCanvas) {
          context.save();
          var m = this.getAbsoluteTransform(top).getMatrix();
          return context.transform(m[0], m[1], m[2], m[3], m[4], m[5]), this._drawCachedSceneCanvas(context), context.restore(), this;
        }
        if (!drawFunc)
          return this;
        if (context.save(), this._useBufferCanvas() && !skipBuffer) {
          stage = this.getStage(), bufferCanvas = stage.bufferCanvas, bufferContext = bufferCanvas.getContext(), bufferContext.clear(), bufferContext.save(), bufferContext._applyLineJoin(this);
          var o = this.getAbsoluteTransform(top).getMatrix();
          bufferContext.transform(o[0], o[1], o[2], o[3], o[4], o[5]), drawFunc.call(this, bufferContext, this), bufferContext.restore();
          var ratio = bufferCanvas.pixelRatio;
          hasShadow && context._applyShadow(this), context._applyOpacity(this), context._applyGlobalCompositeOperation(this), context.drawImage(bufferCanvas._canvas, 0, 0, bufferCanvas.width / ratio, bufferCanvas.height / ratio);
        } else {
          if (context._applyLineJoin(this), !cachingSelf) {
            var o = this.getAbsoluteTransform(top).getMatrix();
            context.transform(o[0], o[1], o[2], o[3], o[4], o[5]), context._applyOpacity(this), context._applyGlobalCompositeOperation(this);
          }
          hasShadow && context._applyShadow(this), drawFunc.call(this, context, this);
        }
        return context.restore(), this;
      }
      drawHit(can, top, skipDragCheck = !1) {
        if (!this.shouldDrawHit(top, skipDragCheck))
          return this;
        var layer = this.getLayer(), canvas = can || layer.hitCanvas, context = canvas && canvas.getContext(), drawFunc = this.hitFunc() || this.sceneFunc(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;
        if (this.colorKey || Util.warn("Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()"), cachedHitCanvas) {
          context.save();
          var m = this.getAbsoluteTransform(top).getMatrix();
          return context.transform(m[0], m[1], m[2], m[3], m[4], m[5]), this._drawCachedHitCanvas(context), context.restore(), this;
        }
        if (!drawFunc)
          return this;
        if (context.save(), context._applyLineJoin(this), !(this === top)) {
          var o = this.getAbsoluteTransform(top).getMatrix();
          context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
        }
        return drawFunc.call(this, context, this), context.restore(), this;
      }
      drawHitFromCache(alphaThreshold = 0) {
        var cachedCanvas = this._getCanvasCache(), sceneCanvas = this._getCachedSceneCanvas(), hitCanvas = cachedCanvas.hit, hitContext = hitCanvas.getContext(), hitWidth = hitCanvas.getWidth(), hitHeight = hitCanvas.getHeight(), hitImageData, hitData, len, rgbColorKey, i, alpha;
        hitContext.clear(), hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);
        try {
          for (hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight), hitData = hitImageData.data, len = hitData.length, rgbColorKey = Util._hexToRgb(this.colorKey), i = 0; i < len; i += 4)
            alpha = hitData[i + 3], alpha > alphaThreshold ? (hitData[i] = rgbColorKey.r, hitData[i + 1] = rgbColorKey.g, hitData[i + 2] = rgbColorKey.b, hitData[i + 3] = 255) : hitData[i + 3] = 0;
          hitContext.putImageData(hitImageData, 0, 0);
        } catch (e) {
          Util.error("Unable to draw hit graph from cached scene canvas. " + e.message);
        }
        return this;
      }
      hasPointerCapture(pointerId) {
        return hasPointerCapture(pointerId, this);
      }
      setPointerCapture(pointerId) {
        setPointerCapture(pointerId, this);
      }
      releaseCapture(pointerId) {
        releaseCapture(pointerId, this);
      }
    };
    Shape.prototype._fillFunc = _fillFunc;
    Shape.prototype._strokeFunc = _strokeFunc;
    Shape.prototype._fillFuncHit = _fillFuncHit;
    Shape.prototype._strokeFuncHit = _strokeFuncHit;
    Shape.prototype._centroid = !1;
    Shape.prototype.nodeType = "Shape";
    _registerNode(Shape);
    Shape.prototype.eventListeners = {};
    Shape.prototype.on.call(Shape.prototype, "shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", _clearHasShadowCache);
    Shape.prototype.on.call(Shape.prototype, "shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", _clearGetShadowRGBACache);
    Shape.prototype.on.call(Shape.prototype, "fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva", _clearFillPatternCache);
    Shape.prototype.on.call(Shape.prototype, "fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva", _clearLinearGradientCache);
    Shape.prototype.on.call(Shape.prototype, "fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva", _clearRadialGradientCache);
    Factory.addGetterSetter(Shape, "stroke", void 0, getStringOrGradientValidator());
    Factory.addGetterSetter(Shape, "strokeWidth", 2, getNumberValidator());
    Factory.addGetterSetter(Shape, "fillAfterStrokeEnabled", !1);
    Factory.addGetterSetter(Shape, "hitStrokeWidth", "auto", getNumberOrAutoValidator());
    Factory.addGetterSetter(Shape, "strokeHitEnabled", !0, getBooleanValidator());
    Factory.addGetterSetter(Shape, "perfectDrawEnabled", !0, getBooleanValidator());
    Factory.addGetterSetter(Shape, "shadowForStrokeEnabled", !0, getBooleanValidator());
    Factory.addGetterSetter(Shape, "lineJoin");
    Factory.addGetterSetter(Shape, "lineCap");
    Factory.addGetterSetter(Shape, "sceneFunc");
    Factory.addGetterSetter(Shape, "hitFunc");
    Factory.addGetterSetter(Shape, "dash");
    Factory.addGetterSetter(Shape, "dashOffset", 0, getNumberValidator());
    Factory.addGetterSetter(Shape, "shadowColor", void 0, getStringValidator());
    Factory.addGetterSetter(Shape, "shadowBlur", 0, getNumberValidator());
    Factory.addGetterSetter(Shape, "shadowOpacity", 1, getNumberValidator());
    Factory.addComponentsGetterSetter(Shape, "shadowOffset", ["x", "y"]);
    Factory.addGetterSetter(Shape, "shadowOffsetX", 0, getNumberValidator());
    Factory.addGetterSetter(Shape, "shadowOffsetY", 0, getNumberValidator());
    Factory.addGetterSetter(Shape, "fillPatternImage");
    Factory.addGetterSetter(Shape, "fill", void 0, getStringOrGradientValidator());
    Factory.addGetterSetter(Shape, "fillPatternX", 0, getNumberValidator());
    Factory.addGetterSetter(Shape, "fillPatternY", 0, getNumberValidator());
    Factory.addGetterSetter(Shape, "fillLinearGradientColorStops");
    Factory.addGetterSetter(Shape, "strokeLinearGradientColorStops");
    Factory.addGetterSetter(Shape, "fillRadialGradientStartRadius", 0);
    Factory.addGetterSetter(Shape, "fillRadialGradientEndRadius", 0);
    Factory.addGetterSetter(Shape, "fillRadialGradientColorStops");
    Factory.addGetterSetter(Shape, "fillPatternRepeat", "repeat");
    Factory.addGetterSetter(Shape, "fillEnabled", !0);
    Factory.addGetterSetter(Shape, "strokeEnabled", !0);
    Factory.addGetterSetter(Shape, "shadowEnabled", !0);
    Factory.addGetterSetter(Shape, "dashEnabled", !0);
    Factory.addGetterSetter(Shape, "strokeScaleEnabled", !0);
    Factory.addGetterSetter(Shape, "fillPriority", "color");
    Factory.addComponentsGetterSetter(Shape, "fillPatternOffset", ["x", "y"]);
    Factory.addGetterSetter(Shape, "fillPatternOffsetX", 0, getNumberValidator());
    Factory.addGetterSetter(Shape, "fillPatternOffsetY", 0, getNumberValidator());
    Factory.addComponentsGetterSetter(Shape, "fillPatternScale", ["x", "y"]);
    Factory.addGetterSetter(Shape, "fillPatternScaleX", 1, getNumberValidator());
    Factory.addGetterSetter(Shape, "fillPatternScaleY", 1, getNumberValidator());
    Factory.addComponentsGetterSetter(Shape, "fillLinearGradientStartPoint", [
      "x",
      "y"
    ]);
    Factory.addComponentsGetterSetter(Shape, "strokeLinearGradientStartPoint", [
      "x",
      "y"
    ]);
    Factory.addGetterSetter(Shape, "fillLinearGradientStartPointX", 0);
    Factory.addGetterSetter(Shape, "strokeLinearGradientStartPointX", 0);
    Factory.addGetterSetter(Shape, "fillLinearGradientStartPointY", 0);
    Factory.addGetterSetter(Shape, "strokeLinearGradientStartPointY", 0);
    Factory.addComponentsGetterSetter(Shape, "fillLinearGradientEndPoint", [
      "x",
      "y"
    ]);
    Factory.addComponentsGetterSetter(Shape, "strokeLinearGradientEndPoint", [
      "x",
      "y"
    ]);
    Factory.addGetterSetter(Shape, "fillLinearGradientEndPointX", 0);
    Factory.addGetterSetter(Shape, "strokeLinearGradientEndPointX", 0);
    Factory.addGetterSetter(Shape, "fillLinearGradientEndPointY", 0);
    Factory.addGetterSetter(Shape, "strokeLinearGradientEndPointY", 0);
    Factory.addComponentsGetterSetter(Shape, "fillRadialGradientStartPoint", [
      "x",
      "y"
    ]);
    Factory.addGetterSetter(Shape, "fillRadialGradientStartPointX", 0);
    Factory.addGetterSetter(Shape, "fillRadialGradientStartPointY", 0);
    Factory.addComponentsGetterSetter(Shape, "fillRadialGradientEndPoint", [
      "x",
      "y"
    ]);
    Factory.addGetterSetter(Shape, "fillRadialGradientEndPointX", 0);
    Factory.addGetterSetter(Shape, "fillRadialGradientEndPointY", 0);
    Factory.addGetterSetter(Shape, "fillPatternRotation", 0);
    Factory.backCompat(Shape, {
      dashArray: "dash",
      getDashArray: "getDash",
      setDashArray: "getDash",
      drawFunc: "sceneFunc",
      getDrawFunc: "getSceneFunc",
      setDrawFunc: "setSceneFunc",
      drawHitFunc: "hitFunc",
      getDrawHitFunc: "getHitFunc",
      setDrawHitFunc: "setHitFunc"
    });
  }
});

// node_modules/konva/lib/Layer.js
var HASH2, BEFORE_DRAW, DRAW, INTERSECTION_OFFSETS, INTERSECTION_OFFSETS_LEN, Layer, init_Layer = __esm({
  "node_modules/konva/lib/Layer.js"() {
    init_Util();
    init_Container();
    init_Node();
    init_Factory();
    init_Canvas();
    init_Validators();
    init_Shape();
    init_Global();
    HASH2 = "#", BEFORE_DRAW = "beforeDraw", DRAW = "draw", INTERSECTION_OFFSETS = [
      { x: 0, y: 0 },
      { x: -1, y: -1 },
      { x: 1, y: -1 },
      { x: 1, y: 1 },
      { x: -1, y: 1 }
    ], INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length, Layer = class extends Container {
      constructor(config) {
        super(config), this.canvas = new SceneCanvas(), this.hitCanvas = new HitCanvas({
          pixelRatio: 1
        }), this._waitingForDraw = !1, this.on("visibleChange.konva", this._checkVisibility), this._checkVisibility(), this.on("imageSmoothingEnabledChange.konva", this._setSmoothEnabled), this._setSmoothEnabled();
      }
      createPNGStream() {
        return this.canvas._canvas.createPNGStream();
      }
      getCanvas() {
        return this.canvas;
      }
      getNativeCanvasElement() {
        return this.canvas._canvas;
      }
      getHitCanvas() {
        return this.hitCanvas;
      }
      getContext() {
        return this.getCanvas().getContext();
      }
      clear(bounds) {
        return this.getContext().clear(bounds), this.getHitCanvas().getContext().clear(bounds), this;
      }
      setZIndex(index) {
        super.setZIndex(index);
        var stage = this.getStage();
        return stage && stage.content && (stage.content.removeChild(this.getNativeCanvasElement()), index < stage.children.length - 1 ? stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[index + 1].getCanvas()._canvas) : stage.content.appendChild(this.getNativeCanvasElement())), this;
      }
      moveToTop() {
        Node.prototype.moveToTop.call(this);
        var stage = this.getStage();
        return stage && stage.content && (stage.content.removeChild(this.getNativeCanvasElement()), stage.content.appendChild(this.getNativeCanvasElement())), !0;
      }
      moveUp() {
        var moved = Node.prototype.moveUp.call(this);
        if (!moved)
          return !1;
        var stage = this.getStage();
        return !stage || !stage.content ? !1 : (stage.content.removeChild(this.getNativeCanvasElement()), this.index < stage.children.length - 1 ? stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[this.index + 1].getCanvas()._canvas) : stage.content.appendChild(this.getNativeCanvasElement()), !0);
      }
      moveDown() {
        if (Node.prototype.moveDown.call(this)) {
          var stage = this.getStage();
          if (stage) {
            var children = stage.children;
            stage.content && (stage.content.removeChild(this.getNativeCanvasElement()), stage.content.insertBefore(this.getNativeCanvasElement(), children[this.index + 1].getCanvas()._canvas));
          }
          return !0;
        }
        return !1;
      }
      moveToBottom() {
        if (Node.prototype.moveToBottom.call(this)) {
          var stage = this.getStage();
          if (stage) {
            var children = stage.children;
            stage.content && (stage.content.removeChild(this.getNativeCanvasElement()), stage.content.insertBefore(this.getNativeCanvasElement(), children[1].getCanvas()._canvas));
          }
          return !0;
        }
        return !1;
      }
      getLayer() {
        return this;
      }
      remove() {
        var _canvas = this.getNativeCanvasElement();
        return Node.prototype.remove.call(this), _canvas && _canvas.parentNode && Util._isInDocument(_canvas) && _canvas.parentNode.removeChild(_canvas), this;
      }
      getStage() {
        return this.parent;
      }
      setSize({ width, height }) {
        return this.canvas.setSize(width, height), this.hitCanvas.setSize(width, height), this._setSmoothEnabled(), this;
      }
      _validateAdd(child) {
        var type = child.getType();
        type !== "Group" && type !== "Shape" && Util.throw("You may only add groups and shapes to a layer.");
      }
      _toKonvaCanvas(config) {
        return config = config || {}, config.width = config.width || this.getWidth(), config.height = config.height || this.getHeight(), config.x = config.x !== void 0 ? config.x : this.x(), config.y = config.y !== void 0 ? config.y : this.y(), Node.prototype._toKonvaCanvas.call(this, config);
      }
      _checkVisibility() {
        this.visible() ? this.canvas._canvas.style.display = "block" : this.canvas._canvas.style.display = "none";
      }
      _setSmoothEnabled() {
        this.getContext()._context.imageSmoothingEnabled = this.imageSmoothingEnabled();
      }
      getWidth() {
        if (this.parent)
          return this.parent.width();
      }
      setWidth() {
        Util.warn('Can not change width of layer. Use "stage.width(value)" function instead.');
      }
      getHeight() {
        if (this.parent)
          return this.parent.height();
      }
      setHeight() {
        Util.warn('Can not change height of layer. Use "stage.height(value)" function instead.');
      }
      batchDraw() {
        return this._waitingForDraw || (this._waitingForDraw = !0, Util.requestAnimFrame(() => {
          this.draw(), this._waitingForDraw = !1;
        })), this;
      }
      getIntersection(pos) {
        if (!this.isListening() || !this.isVisible())
          return null;
        for (var spiralSearchDistance = 1, continueSearch = !1; ; ) {
          for (let i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {
            let intersectionOffset = INTERSECTION_OFFSETS[i], obj = this._getIntersection({
              x: pos.x + intersectionOffset.x * spiralSearchDistance,
              y: pos.y + intersectionOffset.y * spiralSearchDistance
            }), shape = obj.shape;
            if (shape)
              return shape;
            if (continueSearch = !!obj.antialiased, !obj.antialiased)
              break;
          }
          if (continueSearch)
            spiralSearchDistance += 1;
          else
            return null;
        }
      }
      _getIntersection(pos) {
        let ratio = this.hitCanvas.pixelRatio, p = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio), Math.round(pos.y * ratio), 1, 1).data, p3 = p[3];
        if (p3 === 255) {
          let colorKey = Util._rgbToHex(p[0], p[1], p[2]), shape = shapes[HASH2 + colorKey];
          return shape ? {
            shape
          } : {
            antialiased: !0
          };
        } else if (p3 > 0)
          return {
            antialiased: !0
          };
        return {};
      }
      drawScene(can, top) {
        var layer = this.getLayer(), canvas = can || layer && layer.getCanvas();
        return this._fire(BEFORE_DRAW, {
          node: this
        }), this.clearBeforeDraw() && canvas.getContext().clear(), Container.prototype.drawScene.call(this, canvas, top), this._fire(DRAW, {
          node: this
        }), this;
      }
      drawHit(can, top) {
        var layer = this.getLayer(), canvas = can || layer && layer.hitCanvas;
        return layer && layer.clearBeforeDraw() && layer.getHitCanvas().getContext().clear(), Container.prototype.drawHit.call(this, canvas, top), this;
      }
      enableHitGraph() {
        return this.hitGraphEnabled(!0), this;
      }
      disableHitGraph() {
        return this.hitGraphEnabled(!1), this;
      }
      setHitGraphEnabled(val) {
        Util.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening(val);
      }
      getHitGraphEnabled(val) {
        return Util.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening();
      }
      toggleHitCanvas() {
        if (!(!this.parent || !this.parent.content)) {
          var parent = this.parent, added = !!this.hitCanvas._canvas.parentNode;
          added ? parent.content.removeChild(this.hitCanvas._canvas) : parent.content.appendChild(this.hitCanvas._canvas);
        }
      }
      destroy() {
        return Util.releaseCanvas(this.getNativeCanvasElement(), this.getHitCanvas()._canvas), super.destroy();
      }
    };
    Layer.prototype.nodeType = "Layer";
    _registerNode(Layer);
    Factory.addGetterSetter(Layer, "imageSmoothingEnabled", !0);
    Factory.addGetterSetter(Layer, "clearBeforeDraw", !0);
    Factory.addGetterSetter(Layer, "hitGraphEnabled", !0, getBooleanValidator());
  }
});

// node_modules/konva/lib/FastLayer.js
var FastLayer, init_FastLayer = __esm({
  "node_modules/konva/lib/FastLayer.js"() {
    init_Util();
    init_Layer();
    init_Global();
    FastLayer = class extends Layer {
      constructor(attrs) {
        super(attrs), this.listening(!1), Util.warn('Konva.Fast layer is deprecated. Please use "new Konva.Layer({ listening: false })" instead.');
      }
    };
    FastLayer.prototype.nodeType = "FastLayer";
    _registerNode(FastLayer);
  }
});

// node_modules/konva/lib/Group.js
var Group, init_Group = __esm({
  "node_modules/konva/lib/Group.js"() {
    init_Util();
    init_Container();
    init_Global();
    Group = class extends Container {
      _validateAdd(child) {
        var type = child.getType();
        type !== "Group" && type !== "Shape" && Util.throw("You may only add groups and shapes to groups.");
      }
    };
    Group.prototype.nodeType = "Group";
    _registerNode(Group);
  }
});

// node_modules/konva/lib/Animation.js
var now, Animation, init_Animation = __esm({
  "node_modules/konva/lib/Animation.js"() {
    init_Global();
    init_Util();
    now = function() {
      return glob.performance && glob.performance.now ? function() {
        return glob.performance.now();
      } : function() {
        return new Date().getTime();
      };
    }(), Animation = class {
      constructor(func, layers) {
        this.id = Animation.animIdCounter++, this.frame = {
          time: 0,
          timeDiff: 0,
          lastTime: now(),
          frameRate: 0
        }, this.func = func, this.setLayers(layers);
      }
      setLayers(layers) {
        var lays = [];
        return layers ? layers.length > 0 ? lays = layers : lays = [layers] : lays = [], this.layers = lays, this;
      }
      getLayers() {
        return this.layers;
      }
      addLayer(layer) {
        var layers = this.layers, len = layers.length, n;
        for (n = 0; n < len; n++)
          if (layers[n]._id === layer._id)
            return !1;
        return this.layers.push(layer), !0;
      }
      isRunning() {
        var a = Animation, animations = a.animations, len = animations.length, n;
        for (n = 0; n < len; n++)
          if (animations[n].id === this.id)
            return !0;
        return !1;
      }
      start() {
        return this.stop(), this.frame.timeDiff = 0, this.frame.lastTime = now(), Animation._addAnimation(this), this;
      }
      stop() {
        return Animation._removeAnimation(this), this;
      }
      _updateFrameObject(time) {
        this.frame.timeDiff = time - this.frame.lastTime, this.frame.lastTime = time, this.frame.time += this.frame.timeDiff, this.frame.frameRate = 1e3 / this.frame.timeDiff;
      }
      static _addAnimation(anim) {
        this.animations.push(anim), this._handleAnimation();
      }
      static _removeAnimation(anim) {
        var id = anim.id, animations = this.animations, len = animations.length, n;
        for (n = 0; n < len; n++)
          if (animations[n].id === id) {
            this.animations.splice(n, 1);
            break;
          }
      }
      static _runFrames() {
        var layerHash = {}, animations = this.animations, anim, layers, func, n, i, layersLen, layer, key, needRedraw;
        for (n = 0; n < animations.length; n++)
          if (anim = animations[n], layers = anim.layers, func = anim.func, anim._updateFrameObject(now()), layersLen = layers.length, func ? needRedraw = func.call(anim, anim.frame) !== !1 : needRedraw = !0, !!needRedraw)
            for (i = 0; i < layersLen; i++)
              layer = layers[i], layer._id !== void 0 && (layerHash[layer._id] = layer);
        for (key in layerHash)
          !layerHash.hasOwnProperty(key) || layerHash[key].batchDraw();
      }
      static _animationLoop() {
        var Anim = Animation;
        Anim.animations.length ? (Anim._runFrames(), Util.requestAnimFrame(Anim._animationLoop)) : Anim.animRunning = !1;
      }
      static _handleAnimation() {
        this.animRunning || (this.animRunning = !0, Util.requestAnimFrame(this._animationLoop));
      }
    };
    Animation.animations = [];
    Animation.animIdCounter = 0;
    Animation.animRunning = !1;
  }
});

// node_modules/konva/lib/Tween.js
var blacklist, PAUSED, PLAYING, REVERSING, idCounter2, colorAttrs, TweenEngine, Tween, Easings, init_Tween = __esm({
  "node_modules/konva/lib/Tween.js"() {
    init_Util();
    init_Animation();
    init_Node();
    init_Global();
    blacklist = {
      node: 1,
      duration: 1,
      easing: 1,
      onFinish: 1,
      yoyo: 1
    }, PAUSED = 1, PLAYING = 2, REVERSING = 3, idCounter2 = 0, colorAttrs = ["fill", "stroke", "shadowColor"], TweenEngine = class {
      constructor(prop, propFunc, func, begin, finish, duration, yoyo) {
        this.prop = prop, this.propFunc = propFunc, this.begin = begin, this._pos = begin, this.duration = duration, this._change = 0, this.prevPos = 0, this.yoyo = yoyo, this._time = 0, this._position = 0, this._startTime = 0, this._finish = 0, this.func = func, this._change = finish - this.begin, this.pause();
      }
      fire(str) {
        var handler = this[str];
        handler && handler();
      }
      setTime(t) {
        t > this.duration ? this.yoyo ? (this._time = this.duration, this.reverse()) : this.finish() : t < 0 ? this.yoyo ? (this._time = 0, this.play()) : this.reset() : (this._time = t, this.update());
      }
      getTime() {
        return this._time;
      }
      setPosition(p) {
        this.prevPos = this._pos, this.propFunc(p), this._pos = p;
      }
      getPosition(t) {
        return t === void 0 && (t = this._time), this.func(t, this.begin, this._change, this.duration);
      }
      play() {
        this.state = PLAYING, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onPlay");
      }
      reverse() {
        this.state = REVERSING, this._time = this.duration - this._time, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onReverse");
      }
      seek(t) {
        this.pause(), this._time = t, this.update(), this.fire("onSeek");
      }
      reset() {
        this.pause(), this._time = 0, this.update(), this.fire("onReset");
      }
      finish() {
        this.pause(), this._time = this.duration, this.update(), this.fire("onFinish");
      }
      update() {
        this.setPosition(this.getPosition(this._time)), this.fire("onUpdate");
      }
      onEnterFrame() {
        var t = this.getTimer() - this._startTime;
        this.state === PLAYING ? this.setTime(t) : this.state === REVERSING && this.setTime(this.duration - t);
      }
      pause() {
        this.state = PAUSED, this.fire("onPause");
      }
      getTimer() {
        return new Date().getTime();
      }
    }, Tween = class {
      constructor(config) {
        var that = this, node = config.node, nodeId = node._id, duration, easing = config.easing || Easings.Linear, yoyo = !!config.yoyo, key;
        typeof config.duration > "u" ? duration = 0.3 : config.duration === 0 ? duration = 1e-3 : duration = config.duration, this.node = node, this._id = idCounter2++;
        var layers = node.getLayer() || (node instanceof Konva.Stage ? node.getLayers() : null);
        layers || Util.error("Tween constructor have `node` that is not in a layer. Please add node into layer first."), this.anim = new Animation(function() {
          that.tween.onEnterFrame();
        }, layers), this.tween = new TweenEngine(key, function(i) {
          that._tweenFunc(i);
        }, easing, 0, 1, duration * 1e3, yoyo), this._addListeners(), Tween.attrs[nodeId] || (Tween.attrs[nodeId] = {}), Tween.attrs[nodeId][this._id] || (Tween.attrs[nodeId][this._id] = {}), Tween.tweens[nodeId] || (Tween.tweens[nodeId] = {});
        for (key in config)
          blacklist[key] === void 0 && this._addAttr(key, config[key]);
        this.reset(), this.onFinish = config.onFinish, this.onReset = config.onReset, this.onUpdate = config.onUpdate;
      }
      _addAttr(key, end) {
        var node = this.node, nodeId = node._id, start, diff, tweenId, n, len, trueEnd, trueStart, endRGBA;
        if (tweenId = Tween.tweens[nodeId][key], tweenId && delete Tween.attrs[nodeId][tweenId][key], start = node.getAttr(key), Util._isArray(end))
          if (diff = [], len = Math.max(end.length, start.length), key === "points" && end.length !== start.length && (end.length > start.length ? (trueStart = start, start = Util._prepareArrayForTween(start, end, node.closed())) : (trueEnd = end, end = Util._prepareArrayForTween(end, start, node.closed()))), key.indexOf("fill") === 0)
            for (n = 0; n < len; n++)
              if (n % 2 === 0)
                diff.push(end[n] - start[n]);
              else {
                var startRGBA = Util.colorToRGBA(start[n]);
                endRGBA = Util.colorToRGBA(end[n]), start[n] = startRGBA, diff.push({
                  r: endRGBA.r - startRGBA.r,
                  g: endRGBA.g - startRGBA.g,
                  b: endRGBA.b - startRGBA.b,
                  a: endRGBA.a - startRGBA.a
                });
              }
          else
            for (n = 0; n < len; n++)
              diff.push(end[n] - start[n]);
        else
          colorAttrs.indexOf(key) !== -1 ? (start = Util.colorToRGBA(start), endRGBA = Util.colorToRGBA(end), diff = {
            r: endRGBA.r - start.r,
            g: endRGBA.g - start.g,
            b: endRGBA.b - start.b,
            a: endRGBA.a - start.a
          }) : diff = end - start;
        Tween.attrs[nodeId][this._id][key] = {
          start,
          diff,
          end,
          trueEnd,
          trueStart
        }, Tween.tweens[nodeId][key] = this._id;
      }
      _tweenFunc(i) {
        var node = this.node, attrs = Tween.attrs[node._id][this._id], key, attr, start, diff, newVal, n, len, end;
        for (key in attrs) {
          if (attr = attrs[key], start = attr.start, diff = attr.diff, end = attr.end, Util._isArray(start))
            if (newVal = [], len = Math.max(start.length, end.length), key.indexOf("fill") === 0)
              for (n = 0; n < len; n++)
                n % 2 === 0 ? newVal.push((start[n] || 0) + diff[n] * i) : newVal.push("rgba(" + Math.round(start[n].r + diff[n].r * i) + "," + Math.round(start[n].g + diff[n].g * i) + "," + Math.round(start[n].b + diff[n].b * i) + "," + (start[n].a + diff[n].a * i) + ")");
            else
              for (n = 0; n < len; n++)
                newVal.push((start[n] || 0) + diff[n] * i);
          else
            colorAttrs.indexOf(key) !== -1 ? newVal = "rgba(" + Math.round(start.r + diff.r * i) + "," + Math.round(start.g + diff.g * i) + "," + Math.round(start.b + diff.b * i) + "," + (start.a + diff.a * i) + ")" : newVal = start + diff * i;
          node.setAttr(key, newVal);
        }
      }
      _addListeners() {
        this.tween.onPlay = () => {
          this.anim.start();
        }, this.tween.onReverse = () => {
          this.anim.start();
        }, this.tween.onPause = () => {
          this.anim.stop();
        }, this.tween.onFinish = () => {
          var node = this.node, attrs = Tween.attrs[node._id][this._id];
          attrs.points && attrs.points.trueEnd && node.setAttr("points", attrs.points.trueEnd), this.onFinish && this.onFinish.call(this);
        }, this.tween.onReset = () => {
          var node = this.node, attrs = Tween.attrs[node._id][this._id];
          attrs.points && attrs.points.trueStart && node.points(attrs.points.trueStart), this.onReset && this.onReset();
        }, this.tween.onUpdate = () => {
          this.onUpdate && this.onUpdate.call(this);
        };
      }
      play() {
        return this.tween.play(), this;
      }
      reverse() {
        return this.tween.reverse(), this;
      }
      reset() {
        return this.tween.reset(), this;
      }
      seek(t) {
        return this.tween.seek(t * 1e3), this;
      }
      pause() {
        return this.tween.pause(), this;
      }
      finish() {
        return this.tween.finish(), this;
      }
      destroy() {
        var nodeId = this.node._id, thisId = this._id, attrs = Tween.tweens[nodeId], key;
        this.pause();
        for (key in attrs)
          delete Tween.tweens[nodeId][key];
        delete Tween.attrs[nodeId][thisId];
      }
    };
    Tween.attrs = {};
    Tween.tweens = {};
    Node.prototype.to = function(params) {
      var onFinish = params.onFinish;
      params.node = this, params.onFinish = function() {
        this.destroy(), onFinish && onFinish();
      };
      var tween = new Tween(params);
      tween.play();
    };
    Easings = {
      BackEaseIn(t, b, c, d) {
        var s = 1.70158;
        return c * (t /= d) * t * ((s + 1) * t - s) + b;
      },
      BackEaseOut(t, b, c, d) {
        var s = 1.70158;
        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
      },
      BackEaseInOut(t, b, c, d) {
        var s = 1.70158;
        return (t /= d / 2) < 1 ? c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b : c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
      },
      ElasticEaseIn(t, b, c, d, a, p) {
        var s = 0;
        return t === 0 ? b : (t /= d) === 1 ? b + c : (p || (p = d * 0.3), !a || a < Math.abs(c) ? (a = c, s = p / 4) : s = p / (2 * Math.PI) * Math.asin(c / a), -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b);
      },
      ElasticEaseOut(t, b, c, d, a, p) {
        var s = 0;
        return t === 0 ? b : (t /= d) === 1 ? b + c : (p || (p = d * 0.3), !a || a < Math.abs(c) ? (a = c, s = p / 4) : s = p / (2 * Math.PI) * Math.asin(c / a), a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b);
      },
      ElasticEaseInOut(t, b, c, d, a, p) {
        var s = 0;
        return t === 0 ? b : (t /= d / 2) === 2 ? b + c : (p || (p = d * (0.3 * 1.5)), !a || a < Math.abs(c) ? (a = c, s = p / 4) : s = p / (2 * Math.PI) * Math.asin(c / a), t < 1 ? -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b : a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b);
      },
      BounceEaseOut(t, b, c, d) {
        return (t /= d) < 1 / 2.75 ? c * (7.5625 * t * t) + b : t < 2 / 2.75 ? c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b : t < 2.5 / 2.75 ? c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b : c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
      },
      BounceEaseIn(t, b, c, d) {
        return c - Easings.BounceEaseOut(d - t, 0, c, d) + b;
      },
      BounceEaseInOut(t, b, c, d) {
        return t < d / 2 ? Easings.BounceEaseIn(t * 2, 0, c, d) * 0.5 + b : Easings.BounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
      },
      EaseIn(t, b, c, d) {
        return c * (t /= d) * t + b;
      },
      EaseOut(t, b, c, d) {
        return -c * (t /= d) * (t - 2) + b;
      },
      EaseInOut(t, b, c, d) {
        return (t /= d / 2) < 1 ? c / 2 * t * t + b : -c / 2 * (--t * (t - 2) - 1) + b;
      },
      StrongEaseIn(t, b, c, d) {
        return c * (t /= d) * t * t * t * t + b;
      },
      StrongEaseOut(t, b, c, d) {
        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
      },
      StrongEaseInOut(t, b, c, d) {
        return (t /= d / 2) < 1 ? c / 2 * t * t * t * t * t + b : c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
      },
      Linear(t, b, c, d) {
        return c * t / d + b;
      }
    };
  }
});

// node_modules/konva/lib/_CoreInternals.js
var Konva2, init_CoreInternals = __esm({
  "node_modules/konva/lib/_CoreInternals.js"() {
    init_Global();
    init_Util();
    init_Node();
    init_Container();
    init_Stage();
    init_Layer();
    init_FastLayer();
    init_Group();
    init_DragAndDrop();
    init_Shape();
    init_Animation();
    init_Tween();
    init_Context();
    init_Canvas();
    Konva2 = Util._assign(Konva, {
      Util,
      Transform,
      Node,
      Container,
      Stage,
      stages,
      Layer,
      FastLayer,
      Group,
      DD,
      Shape,
      shapes,
      Animation,
      Tween,
      Easings,
      Context,
      Canvas
    });
  }
});

// node_modules/konva/lib/Core.js
var Core_exports = {};
__export(Core_exports, {
  Konva: () => Konva2,
  default: () => Core_default
});
var Core_default, init_Core = __esm({
  "node_modules/konva/lib/Core.js"() {
    init_CoreInternals();
    init_CoreInternals();
    Core_default = Konva2;
  }
});

// node_modules/react-konva/lib/makeUpdates.js
var require_makeUpdates = __commonJS({
  "node_modules/react-konva/lib/makeUpdates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.updatePicture = exports.applyNodeProps = exports.toggleStrictMode = exports.EVENTS_NAMESPACE = void 0;
    var Global_1 = (init_Global(), __toCommonJS(Global_exports)), propsToSkip = {
      children: !0,
      ref: !0,
      key: !0,
      style: !0,
      forwardedRef: !0,
      unstable_applyCache: !0,
      unstable_applyDrawHitFromCache: !0
    }, zIndexWarningShowed = !1, dragWarningShowed = !1;
    exports.EVENTS_NAMESPACE = ".react-konva-event";
    var useStrictMode = !1;
    function toggleStrictMode(value) {
      useStrictMode = value;
    }
    exports.toggleStrictMode = toggleStrictMode;
    var DRAGGABLE_WARNING = `ReactKonva: You have a Konva node with draggable = true and position defined but no onDragMove or onDragEnd events are handled.
Position of a node will be changed during drag&drop, so you should update state of the react app as well.
Consider to add onDragMove or onDragEnd events.
For more info see: https://github.com/konvajs/react-konva/issues/256
`, Z_INDEX_WARNING = `ReactKonva: You are using "zIndex" attribute for a Konva node.
react-konva may get confused with ordering. Just define correct order of elements in your render function of a component.
For more info see: https://github.com/konvajs/react-konva/issues/194
`, EMPTY_PROPS = {};
    function applyNodeProps(instance, props, oldProps = EMPTY_PROPS) {
      if (!zIndexWarningShowed && "zIndex" in props && (console.warn(Z_INDEX_WARNING), zIndexWarningShowed = !0), !dragWarningShowed && props.draggable) {
        var hasPosition = props.x !== void 0 || props.y !== void 0, hasEvents = props.onDragEnd || props.onDragMove;
        hasPosition && !hasEvents && (console.warn(DRAGGABLE_WARNING), dragWarningShowed = !0);
      }
      for (var key in oldProps)
        if (!propsToSkip[key]) {
          var isEvent = key.slice(0, 2) === "on", propChanged = oldProps[key] !== props[key];
          if (isEvent && propChanged) {
            var eventName = key.substr(2).toLowerCase();
            eventName.substr(0, 7) === "content" && (eventName = "content" + eventName.substr(7, 1).toUpperCase() + eventName.substr(8)), instance.off(eventName, oldProps[key]);
          }
          var toRemove = !props.hasOwnProperty(key);
          toRemove && instance.setAttr(key, void 0);
        }
      var strictUpdate = useStrictMode || props._useStrictMode, updatedProps = {}, hasUpdates = !1;
      let newEvents = {};
      for (var key in props)
        if (!propsToSkip[key]) {
          var isEvent = key.slice(0, 2) === "on", toAdd = oldProps[key] !== props[key];
          if (isEvent && toAdd) {
            var eventName = key.substr(2).toLowerCase();
            eventName.substr(0, 7) === "content" && (eventName = "content" + eventName.substr(7, 1).toUpperCase() + eventName.substr(8)), props[key] && (newEvents[eventName] = props[key]);
          }
          !isEvent && (props[key] !== oldProps[key] || strictUpdate && props[key] !== instance.getAttr(key)) && (hasUpdates = !0, updatedProps[key] = props[key]);
        }
      hasUpdates && (instance.setAttrs(updatedProps), updatePicture(instance));
      for (var eventName in newEvents)
        instance.on(eventName + exports.EVENTS_NAMESPACE, newEvents[eventName]);
    }
    exports.applyNodeProps = applyNodeProps;
    function updatePicture(node) {
      if (!Global_1.Konva.autoDrawEnabled) {
        var drawingNode = node.getLayer() || node.getStage();
        drawingNode && drawingNode.batchDraw();
      }
    }
    exports.updatePicture = updatePicture;
  }
});

// node_modules/react-konva/lib/ReactKonvaHostConfig.js
var require_ReactKonvaHostConfig = __commonJS({
  "node_modules/react-konva/lib/ReactKonvaHostConfig.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getCurrentEventPriority = exports.detachDeletedInstance = exports.clearContainer = exports.unhideTextInstance = exports.unhideInstance = exports.hideTextInstance = exports.hideInstance = exports.commitUpdate = exports.commitMount = exports.commitTextUpdate = exports.removeChildFromContainer = exports.removeChild = exports.insertInContainerBefore = exports.insertBefore = exports.appendChildToContainer = exports.appendChild = exports.supportsMutation = exports.warnsIfNotActing = exports.isPrimaryRenderer = exports.shouldSetTextContent = exports.noTimeout = exports.cancelTimeout = exports.scheduleTimeout = exports.getChildHostContext = exports.getRootHostContext = exports.shouldDeprioritizeSubtree = exports.resetTextContent = exports.resetAfterCommit = exports.prepareUpdate = exports.preparePortalMount = exports.prepareForCommit = exports.getPublicInstance = exports.finalizeInitialChildren = exports.createTextInstance = exports.createInstance = exports.appendInitialChild = exports.run = exports.idlePriority = exports.now = void 0;
    var Core_1 = __importDefault((init_Core(), __toCommonJS(Core_exports))), makeUpdates_1 = require_makeUpdates(), scheduler_1 = require("scheduler");
    Object.defineProperty(exports, "now", { enumerable: !0, get: function() {
      return scheduler_1.unstable_now;
    } });
    Object.defineProperty(exports, "idlePriority", { enumerable: !0, get: function() {
      return scheduler_1.unstable_IdlePriority;
    } });
    Object.defineProperty(exports, "run", { enumerable: !0, get: function() {
      return scheduler_1.unstable_runWithPriority;
    } });
    var constants_1 = require("react-reconciler/constants"), NO_CONTEXT = {}, UPDATE_SIGNAL = {};
    Core_1.default.Node.prototype._applyProps = makeUpdates_1.applyNodeProps;
    function appendInitialChild(parentInstance, child) {
      if (typeof child == "string") {
        console.error(`Do not use plain text as child of Konva.Node. You are using text: ${child}`);
        return;
      }
      parentInstance.add(child), (0, makeUpdates_1.updatePicture)(parentInstance);
    }
    exports.appendInitialChild = appendInitialChild;
    function createInstance(type, props, internalInstanceHandle) {
      let NodeClass = Core_1.default[type];
      NodeClass || (console.error(`Konva has no node with the type ${type}. Group will be used instead. If you use minimal version of react-konva, just import required nodes into Konva: "import "konva/lib/shapes/${type}"  If you want to render DOM elements as part of canvas tree take a look into this demo: https://konvajs.github.io/docs/react/DOM_Portal.html`), NodeClass = Core_1.default.Group);
      let propsWithoutEvents = {}, propsWithOnlyEvents = {};
      for (var key in props) {
        var isEvent = key.slice(0, 2) === "on";
        isEvent ? propsWithOnlyEvents[key] = props[key] : propsWithoutEvents[key] = props[key];
      }
      let instance = new NodeClass(propsWithoutEvents);
      return (0, makeUpdates_1.applyNodeProps)(instance, propsWithOnlyEvents), instance;
    }
    exports.createInstance = createInstance;
    function createTextInstance(text, rootContainerInstance, internalInstanceHandle) {
      console.error(`Text components are not supported for now in ReactKonva. Your text is: "${text}"`);
    }
    exports.createTextInstance = createTextInstance;
    function finalizeInitialChildren(domElement, type, props) {
      return !1;
    }
    exports.finalizeInitialChildren = finalizeInitialChildren;
    function getPublicInstance(instance) {
      return instance;
    }
    exports.getPublicInstance = getPublicInstance;
    function prepareForCommit() {
      return null;
    }
    exports.prepareForCommit = prepareForCommit;
    function preparePortalMount() {
      return null;
    }
    exports.preparePortalMount = preparePortalMount;
    function prepareUpdate(domElement, type, oldProps, newProps) {
      return UPDATE_SIGNAL;
    }
    exports.prepareUpdate = prepareUpdate;
    function resetAfterCommit() {
    }
    exports.resetAfterCommit = resetAfterCommit;
    function resetTextContent(domElement) {
    }
    exports.resetTextContent = resetTextContent;
    function shouldDeprioritizeSubtree(type, props) {
      return !1;
    }
    exports.shouldDeprioritizeSubtree = shouldDeprioritizeSubtree;
    function getRootHostContext() {
      return NO_CONTEXT;
    }
    exports.getRootHostContext = getRootHostContext;
    function getChildHostContext() {
      return NO_CONTEXT;
    }
    exports.getChildHostContext = getChildHostContext;
    exports.scheduleTimeout = setTimeout;
    exports.cancelTimeout = clearTimeout;
    exports.noTimeout = -1;
    function shouldSetTextContent(type, props) {
      return !1;
    }
    exports.shouldSetTextContent = shouldSetTextContent;
    exports.isPrimaryRenderer = !1;
    exports.warnsIfNotActing = !0;
    exports.supportsMutation = !0;
    function appendChild(parentInstance, child) {
      child.parent === parentInstance ? child.moveToTop() : parentInstance.add(child), (0, makeUpdates_1.updatePicture)(parentInstance);
    }
    exports.appendChild = appendChild;
    function appendChildToContainer(parentInstance, child) {
      child.parent === parentInstance ? child.moveToTop() : parentInstance.add(child), (0, makeUpdates_1.updatePicture)(parentInstance);
    }
    exports.appendChildToContainer = appendChildToContainer;
    function insertBefore(parentInstance, child, beforeChild) {
      child._remove(), parentInstance.add(child), child.setZIndex(beforeChild.getZIndex()), (0, makeUpdates_1.updatePicture)(parentInstance);
    }
    exports.insertBefore = insertBefore;
    function insertInContainerBefore(parentInstance, child, beforeChild) {
      insertBefore(parentInstance, child, beforeChild);
    }
    exports.insertInContainerBefore = insertInContainerBefore;
    function removeChild(parentInstance, child) {
      child.destroy(), child.off(makeUpdates_1.EVENTS_NAMESPACE), (0, makeUpdates_1.updatePicture)(parentInstance);
    }
    exports.removeChild = removeChild;
    function removeChildFromContainer(parentInstance, child) {
      child.destroy(), child.off(makeUpdates_1.EVENTS_NAMESPACE), (0, makeUpdates_1.updatePicture)(parentInstance);
    }
    exports.removeChildFromContainer = removeChildFromContainer;
    function commitTextUpdate(textInstance, oldText, newText) {
      console.error(`Text components are not yet supported in ReactKonva. You text is: "${newText}"`);
    }
    exports.commitTextUpdate = commitTextUpdate;
    function commitMount(instance, type, newProps) {
    }
    exports.commitMount = commitMount;
    function commitUpdate(instance, updatePayload, type, oldProps, newProps) {
      (0, makeUpdates_1.applyNodeProps)(instance, newProps, oldProps);
    }
    exports.commitUpdate = commitUpdate;
    function hideInstance(instance) {
      instance.hide(), (0, makeUpdates_1.updatePicture)(instance);
    }
    exports.hideInstance = hideInstance;
    function hideTextInstance(textInstance) {
    }
    exports.hideTextInstance = hideTextInstance;
    function unhideInstance(instance, props) {
      (props.visible == null || props.visible) && instance.show();
    }
    exports.unhideInstance = unhideInstance;
    function unhideTextInstance(textInstance, text) {
    }
    exports.unhideTextInstance = unhideTextInstance;
    function clearContainer(container) {
    }
    exports.clearContainer = clearContainer;
    function detachDeletedInstance() {
    }
    exports.detachDeletedInstance = detachDeletedInstance;
    var getCurrentEventPriority = () => constants_1.DefaultEventPriority;
    exports.getCurrentEventPriority = getCurrentEventPriority;
  }
});

// node_modules/react-konva/lib/ReactKonvaCore.js
var require_ReactKonvaCore = __commonJS({
  "node_modules/react-konva/lib/ReactKonvaCore.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
        return m[k];
      } }), Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: !0, value: v });
    } : function(o, v) {
      o.default = v;
    }), __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null)
        for (var k in mod)
          k !== "default" && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
      return __setModuleDefault(result, mod), result;
    }, __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.useStrictMode = exports.Stage = exports.KonvaRenderer = exports.Transformer = exports.Shape = exports.Arrow = exports.RegularPolygon = exports.Path = exports.Tag = exports.Arc = exports.Ring = exports.Star = exports.TextPath = exports.Text = exports.Image = exports.Sprite = exports.Line = exports.Wedge = exports.Ellipse = exports.Circle = exports.Rect = exports.Label = exports.Group = exports.FastLayer = exports.Layer = void 0;
    var react_1 = __importDefault(require("react")), Core_1 = __importDefault((init_Core(), __toCommonJS(Core_exports))), react_reconciler_1 = __importDefault(require("react-reconciler")), constants_1 = require("react-reconciler/constants"), HostConfig = __importStar(require_ReactKonvaHostConfig()), makeUpdates_1 = require_makeUpdates(), its_fine_1 = require("its-fine");
    function usePrevious(value) {
      let ref = react_1.default.useRef();
      return react_1.default.useLayoutEffect(() => {
        ref.current = value;
      }), ref.current;
    }
    var StageWrap = (props) => {
      let container = react_1.default.useRef(), stage = react_1.default.useRef(), fiberRef = react_1.default.useRef(), oldProps = usePrevious(props), Bridge = (0, its_fine_1.useContextBridge)(), _setRef = (stage2) => {
        let { forwardedRef } = props;
        !forwardedRef || (typeof forwardedRef == "function" ? forwardedRef(stage2) : forwardedRef.current = stage2);
      };
      return react_1.default.useLayoutEffect(() => (stage.current = new Core_1.default.Stage({
        width: props.width,
        height: props.height,
        container: container.current
      }), _setRef(stage.current), fiberRef.current = exports.KonvaRenderer.createContainer(stage.current, constants_1.LegacyRoot, !1, null), exports.KonvaRenderer.updateContainer(react_1.default.createElement(Bridge, {}, props.children), fiberRef.current), () => {
        !Core_1.default.isBrowser || (_setRef(null), exports.KonvaRenderer.updateContainer(null, fiberRef.current, null), stage.current.destroy());
      }), []), react_1.default.useLayoutEffect(() => {
        _setRef(stage.current), (0, makeUpdates_1.applyNodeProps)(stage.current, props, oldProps), exports.KonvaRenderer.updateContainer(react_1.default.createElement(Bridge, {}, props.children), fiberRef.current, null);
      }), react_1.default.createElement("div", {
        ref: container,
        accessKey: props.accessKey,
        className: props.className,
        role: props.role,
        style: props.style,
        tabIndex: props.tabIndex,
        title: props.title
      });
    };
    exports.Layer = "Layer";
    exports.FastLayer = "FastLayer";
    exports.Group = "Group";
    exports.Label = "Label";
    exports.Rect = "Rect";
    exports.Circle = "Circle";
    exports.Ellipse = "Ellipse";
    exports.Wedge = "Wedge";
    exports.Line = "Line";
    exports.Sprite = "Sprite";
    exports.Image = "Image";
    exports.Text = "Text";
    exports.TextPath = "TextPath";
    exports.Star = "Star";
    exports.Ring = "Ring";
    exports.Arc = "Arc";
    exports.Tag = "Tag";
    exports.Path = "Path";
    exports.RegularPolygon = "RegularPolygon";
    exports.Arrow = "Arrow";
    exports.Shape = "Shape";
    exports.Transformer = "Transformer";
    exports.KonvaRenderer = (0, react_reconciler_1.default)(HostConfig);
    exports.KonvaRenderer.injectIntoDevTools({
      findHostInstanceByFiber: () => null,
      bundleType: 1,
      version: react_1.default.version,
      rendererPackageName: "react-konva"
    });
    exports.Stage = react_1.default.forwardRef((props, ref) => react_1.default.createElement(its_fine_1.FiberProvider, {}, react_1.default.createElement(StageWrap, { ...props, forwardedRef: ref })));
    exports.useStrictMode = makeUpdates_1.toggleStrictMode;
  }
});

// node_modules/react-konva/lib/ReactKonva.js
var require_ReactKonva = __commonJS({
  "node_modules/react-konva/lib/ReactKonva.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
        return m[k];
      } }), Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    require_index_node();
    __exportStar(require_ReactKonvaCore(), exports);
  }
});

// <stdin>
var stdin_exports = {};
__export(stdin_exports, {
  assets: () => assets_manifest_default,
  assetsBuildDirectory: () => assetsBuildDirectory,
  entry: () => entry,
  future: () => future,
  publicPath: () => publicPath,
  routes: () => routes
});
module.exports = __toCommonJS(stdin_exports);

// app/entry.server.tsx
var entry_server_exports = {};
__export(entry_server_exports, {
  default: () => handleRequest
});
var import_stream = require("stream"), import_node = require("@remix-run/node"), import_react = require("@remix-run/react"), import_server = require("react-dom/server"), import_jsx_dev_runtime = require("react/jsx-dev-runtime"), ABORT_DELAY = 5e3;
function handleRequest(request, responseStatusCode, responseHeaders, remixContext) {
  return new Promise((resolve, reject) => {
    let didError = !1, { pipe, abort } = (0, import_server.renderToPipeableStream)(
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_react.RemixServer, { context: remixContext, url: request.url }, void 0, !1, {
        fileName: "app/entry.server.tsx",
        lineNumber: 19,
        columnNumber: 7
      }, this),
      {
        onShellReady: () => {
          let body = new import_stream.PassThrough();
          responseHeaders.set("Content-Type", "text/html"), resolve(
            new import_node.Response(body, {
              headers: responseHeaders,
              status: didError ? 500 : responseStatusCode
            })
          ), pipe(body);
        },
        onShellError: (err) => {
          reject(err);
        },
        onError: (error) => {
          didError = !0, console.error(error);
        }
      }
    );
    setTimeout(abort, ABORT_DELAY);
  });
}

// app/root.tsx
var root_exports = {};
__export(root_exports, {
  ErrorBoundary: () => ErrorBoundary,
  action: () => action,
  default: () => App,
  links: () => links,
  loader: () => loader,
  meta: () => meta,
  metaTitlePostfix: () => metaTitlePostfix
});
var import_node4 = require("@remix-run/node"), import_react21 = require("@remix-run/react");

// app/styles/app.css
var app_default = "/build/_assets/app-V5MAPIXH.css";

// app/components/layout/index.tsx
var import_react12 = require("react");

// app/components/sider/sider.tsx
var import_react10 = require("@remix-run/react"), import_react11 = __toESM(require("react"));

// app/icons/basket.tsx
var import_jsx_dev_runtime2 = require("react/jsx-dev-runtime"), SvgIonBasketOutline = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(
  "svg",
  {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...props,
    children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(
        "path",
        {
          d: "M3.206 9a.955.955 0 0 0-.956.947.838.838 0 0 0 .038.258L4.71 18.75a1.897 1.897 0 0 0 1.833 1.383h10.912a1.916 1.916 0 0 0 1.842-1.383l2.424-8.545.028-.258A.955.955 0 0 0 20.794 9H3.206Zm9.062 7.503a1.973 1.973 0 1 1 1.982-1.972 1.981 1.981 0 0 1-1.982 1.972Z",
          stroke: "currentColor",
          strokeWidth: 1.5,
          strokeLinejoin: "round"
        },
        void 0,
        !1,
        {
          fileName: "app/icons/basket.tsx",
          lineNumber: 13,
          columnNumber: 5
        },
        this
      ),
      /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(
        "path",
        {
          d: "M7.5 9 12 3l4.5 6",
          stroke: "currentColor",
          strokeWidth: 1.5,
          strokeLinejoin: "round"
        },
        void 0,
        !1,
        {
          fileName: "app/icons/basket.tsx",
          lineNumber: 19,
          columnNumber: 5
        },
        this
      )
    ]
  },
  void 0,
  !0,
  {
    fileName: "app/icons/basket.tsx",
    lineNumber: 5,
    columnNumber: 3
  },
  this
), basket_default = SvgIonBasketOutline;

// app/icons/favorite.tsx
var import_jsx_dev_runtime3 = require("react/jsx-dev-runtime"), SvgAntDesignHeartOutlined = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(
  "svg",
  {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...props,
    children: /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(
      "path",
      {
        d: "M21.633 6.647a6.093 6.093 0 0 0-1.334-1.94A6.219 6.219 0 0 0 15.93 2.93 6.26 6.26 0 0 0 12 4.315 6.26 6.26 0 0 0 8.07 2.93 6.219 6.219 0 0 0 3.7 4.706a6.057 6.057 0 0 0-1.825 4.33c0 .78.16 1.593.476 2.42.265.692.644 1.409 1.13 2.133.768 1.146 1.825 2.341 3.138 3.553a35.071 35.071 0 0 0 4.42 3.453l.556.356a.753.753 0 0 0 .808 0l.556-.357a35.517 35.517 0 0 0 4.42-3.452c1.312-1.211 2.37-2.407 3.138-3.553.485-.724.867-1.441 1.13-2.133.316-.827.476-1.64.476-2.42a5.968 5.968 0 0 0-.49-2.39ZM12 19.097S3.656 13.75 3.656 9.035c0-2.388 1.976-4.324 4.414-4.324 1.713 0 3.199.956 3.93 2.353a4.426 4.426 0 0 1 3.93-2.353c2.438 0 4.414 1.936 4.414 4.324 0 4.716-8.344 10.062-8.344 10.062Z",
        fill: "currentColor"
      },
      void 0,
      !1,
      {
        fileName: "app/icons/favorite.tsx",
        lineNumber: 13,
        columnNumber: 5
      },
      this
    )
  },
  void 0,
  !1,
  {
    fileName: "app/icons/favorite.tsx",
    lineNumber: 5,
    columnNumber: 3
  },
  this
), favorite_default = SvgAntDesignHeartOutlined;

// app/icons/recipe.tsx
var import_jsx_dev_runtime4 = require("react/jsx-dev-runtime"), SvgFluentFood24Filled = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(
  "svg",
  {
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...props,
    children: /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(
      "path",
      {
        d: "M18 3a1 1 0 0 1 .993.883L19 4v16a1 1 0 0 1-1.993.117L17 20v-5h-1a1 1 0 0 1-.993-.883L15 14V8c0-2.21 1.5-5 3-5Zm-6 0a1 1 0 0 1 .993.883L13 4v5a4.002 4.002 0 0 1-3 3.874V20a1 1 0 0 1-1.993.117L8 20v-7.126a4.002 4.002 0 0 1-2.995-3.668L5 9V4a1 1 0 0 1 1.993-.117L7 4v5a2 2 0 0 0 1 1.732V4a1 1 0 0 1 1.993-.117L10 4l.001 6.732a2 2 0 0 0 .992-1.563L11 9V4a1 1 0 0 1 1-1Z",
        fill: "currentColor"
      },
      void 0,
      !1,
      {
        fileName: "app/icons/recipe.tsx",
        lineNumber: 13,
        columnNumber: 5
      },
      this
    )
  },
  void 0,
  !1,
  {
    fileName: "app/icons/recipe.tsx",
    lineNumber: 5,
    columnNumber: 3
  },
  this
), recipe_default = SvgFluentFood24Filled;

// app/icons/logo.tsx
var import_jsx_dev_runtime5 = require("react/jsx-dev-runtime"), SvgLogo = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(
  "svg",
  {
    viewBox: "0 0 92 31",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...props,
    children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(
        "path",
        {
          d: "M16.28 25.28a4.721 4.721 0 0 1-2.8-.896c-.84-.616-1.717-1.67-2.632-3.164l-2.8-4.676h-1.12V25H3.26V10.16c0-.952-.13-1.652-.392-2.1-.261-.467-.784-.7-1.568-.7h-.28v-.84h7.728c1.941 0 3.687.355 5.236 1.064 1.55.71 2.324 2.072 2.324 4.088 0 2.333-1.512 3.883-4.536 4.648l2.94 4.9c1.101 1.848 2.259 2.875 3.472 3.08v.7c-.15.075-.42.14-.812.196a7.754 7.754 0 0 1-1.092.084Zm-7.672-9.856c1.045 0 1.932-.308 2.66-.924.747-.635 1.12-1.624 1.12-2.968 0-1.325-.364-2.305-1.092-2.94a3.757 3.757 0 0 0-2.548-.952c-.541 0-.961.037-1.26.112l-.56.084v7.588h1.68Zm16.503 9.856c-1.288 0-2.417-.299-3.388-.896a6.198 6.198 0 0 1-2.268-2.436c-.522-1.045-.784-2.221-.784-3.528 0-1.456.262-2.697.784-3.724.542-1.027 1.279-1.801 2.212-2.324.934-.541 1.988-.812 3.164-.812 1.158 0 2.203.233 3.136.7a5.43 5.43 0 0 1 2.212 1.988c.542.84.812 1.81.812 2.912 0 .355-.018.756-.056 1.204l-.056.56h-8.428c0 1.773.27 3.07.812 3.892.542.803 1.298 1.204 2.268 1.204.896 0 1.643-.196 2.24-.588.616-.41 1.204-.99 1.764-1.736l.868.644a7.305 7.305 0 0 1-2.044 2.1c-.802.56-1.885.84-3.248.84Zm2.1-7.616c0-1.755-.205-2.996-.616-3.724-.41-.747-.998-1.12-1.764-1.12-.71 0-1.288.383-1.736 1.148-.43.747-.644 1.979-.644 3.696h4.76ZM39.61 25.28c-1.437 0-2.66-.308-3.668-.924a6.073 6.073 0 0 1-2.296-2.464c-.504-1.045-.756-2.203-.756-3.472 0-1.27.252-2.417.756-3.444a6.03 6.03 0 0 1 2.296-2.492c1.008-.616 2.231-.924 3.668-.924 2.24 0 3.687.327 4.34.98.318.317.514.737.588 1.26.075.523.112 1.41.112 2.66h-.84c-.074-1.176-.438-2.072-1.092-2.688-.653-.635-1.549-.952-2.688-.952-1.026 0-1.848.476-2.464 1.428-.597.933-.896 2.324-.896 4.172 0 3.733 1.167 5.6 3.5 5.6.896 0 1.643-.196 2.24-.588.616-.41 1.204-.99 1.764-1.736l.868.644a7.303 7.303 0 0 1-2.044 2.1c-.821.56-1.95.84-3.388.84Zm10.195-14.952c-.672 0-1.195-.205-1.568-.616-.355-.41-.532-.915-.532-1.512 0-.485.14-.868.42-1.148.299-.28.672-.42 1.12-.42.672 0 1.185.205 1.54.616.373.41.56.915.56 1.512 0 .485-.15.868-.448 1.148-.28.28-.644.42-1.092.42Zm-1.82 5.152c0-.952-.13-1.652-.392-2.1-.261-.467-.784-.7-1.568-.7h-.28v-.84h3.36c.672 0 1.185.112 1.54.336.355.224.607.597.756 1.12.15.504.224 1.232.224 2.184V25h-3.64v-9.52Z",
          className: "fill-black"
        },
        void 0,
        !1,
        {
          fileName: "app/icons/logo.tsx",
          lineNumber: 11,
          columnNumber: 5
        },
        this
      ),
      /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(
        "path",
        {
          d: "M55.84 15.48c0-.952-.13-1.652-.392-2.1-.243-.467-.756-.7-1.54-.7h-.28v-.84H56.4c.653 0 1.157.093 1.512.28.355.168.635.467.84.896 1.101-.97 2.37-1.456 3.808-1.456 1.885 0 3.332.644 4.34 1.932 1.027 1.27 1.54 2.912 1.54 4.928s-.523 3.668-1.568 4.956c-1.027 1.27-2.51 1.904-4.452 1.904-.765 0-1.484-.14-2.156-.42a3.128 3.128 0 0 1-.784-.42v5.88h-3.64V15.48Zm6.02 8.54c1.867 0 2.8-1.867 2.8-5.6 0-1.717-.215-3.08-.644-4.088-.43-1.008-1.101-1.512-2.016-1.512-1.045 0-1.95.383-2.716 1.148l.084.392c.075.224.112.541.112.952v7.868c.205.168.43.308.672.42a3.56 3.56 0 0 0 1.708.42ZM73.52 10.328c-.672 0-1.195-.205-1.568-.616-.355-.41-.532-.915-.532-1.512 0-.485.14-.868.42-1.148.299-.28.672-.42 1.12-.42.672 0 1.185.205 1.54.616.373.41.56.915.56 1.512 0 .485-.15.868-.448 1.148-.28.28-.644.42-1.092.42Zm-1.82 5.152c0-.952-.13-1.652-.392-2.1-.261-.467-.784-.7-1.568-.7h-.28v-.84h3.36c.672 0 1.185.112 1.54.336.355.224.607.597.756 1.12.15.504.224 1.232.224 2.184V25h-3.64v-9.52Zm12.729 9.8c-1.288 0-2.418-.299-3.388-.896a6.198 6.198 0 0 1-2.268-2.436c-.523-1.045-.784-2.221-.784-3.528 0-1.456.261-2.697.784-3.724.541-1.027 1.278-1.801 2.212-2.324.933-.541 1.988-.812 3.164-.812 1.157 0 2.202.233 3.136.7a5.43 5.43 0 0 1 2.212 1.988c.541.84.812 1.81.812 2.912 0 .355-.019.756-.056 1.204l-.056.56h-8.428c0 1.773.27 3.07.812 3.892.541.803 1.297 1.204 2.268 1.204.896 0 1.642-.196 2.24-.588.616-.41 1.204-.99 1.764-1.736l.868.644a7.305 7.305 0 0 1-2.044 2.1c-.803.56-1.886.84-3.248.84Zm2.1-7.616c0-1.755-.206-2.996-.616-3.724-.411-.747-.999-1.12-1.764-1.12-.71 0-1.288.383-1.736 1.148-.43.747-.644 1.979-.644 3.696h4.76Z",
          className: "fill-primary"
        },
        void 0,
        !1,
        {
          fileName: "app/icons/logo.tsx",
          lineNumber: 16,
          columnNumber: 5
        },
        this
      )
    ]
  },
  void 0,
  !0,
  {
    fileName: "app/icons/logo.tsx",
    lineNumber: 5,
    columnNumber: 3
  },
  this
), logo_default = SvgLogo;

// app/components/auth/auth-check.tsx
var import_react5 = require("@remix-run/react"), import_react6 = require("react"), import_react_router_dom = require("react-router-dom");

// app/lib/domain/auth/user-context.tsx
var import_react2 = __toESM(require("react")), import_react3 = require("react"), UserContext = import_react2.default.createContext(null);
function useUser() {
  return (0, import_react3.useContext)(UserContext);
}

// app/components/layout/modal.tsx
var import_react4 = require("react"), import_react_dom = __toESM(require("react-dom")), import_jsx_dev_runtime6 = require("react/jsx-dev-runtime");
function Modal({
  onClose,
  open,
  children,
  className,
  dialogClassName
}) {
  let dialogRef = (0, import_react4.useRef)(null), modalContainer = document.getElementById("modal-container");
  if ((0, import_react4.useEffect)(() => {
    let onClick = (e) => {
      !e.target.contains(dialogRef.current) || dialogRef.current && onClose();
    };
    return document.addEventListener("click", onClick), () => {
      document.removeEventListener("click", onClick);
    };
  }, [onClose]), (0, import_react4.useEffect)(() => {
    !dialogRef.current || (open ? dialogRef.current.showModal() : dialogRef.current.close());
  }, [open]), !modalContainer)
    throw new Error("modal-container not found!");
  return import_react_dom.default.createPortal(
    /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(
      "dialog",
      {
        className: ` p-0 bg-transparent ${dialogClassName ?? ""}`,
        ref: dialogRef,
        children: /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("div", { className: ` bg-white ${className ?? ""}`, children }, void 0, !1, {
          fileName: "app/components/layout/modal.tsx",
          lineNumber: 54,
          columnNumber: 7
        }, this)
      },
      void 0,
      !1,
      {
        fileName: "app/components/layout/modal.tsx",
        lineNumber: 50,
        columnNumber: 5
      },
      this
    ),
    modalContainer
  );
}

// app/components/auth/auth-check.tsx
var import_jsx_dev_runtime7 = require("react/jsx-dev-runtime");
function AuthCheck({
  children,
  loginConfirmModal = !0
}) {
  let user = useUser(), location = (0, import_react5.useLocation)(), [open, setOpen] = (0, import_react6.useState)(!1);
  return (0, import_react6.useEffect)(() => {
    setOpen(!1);
  }, [location.pathname]), !user || !user.id ? /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
    "div",
    {
      onClick: (e) => {
        loginConfirmModal && setOpen(!0);
      },
      children: [
        children(user),
        loginConfirmModal ? /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
          Modal,
          {
            onClose: () => setOpen(!1),
            open,
            className: "w-96 rounded-xl layout-px layout-py",
            children: [
              /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("h3", { className: "mb-10 text-center", children: "Login to continue" }, void 0, !1, {
                fileName: "app/components/auth/auth-check.tsx",
                lineNumber: 39,
                columnNumber: 13
              }, this),
              /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("div", { className: "flex justify-center gap-6", children: [
                /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
                  import_react_router_dom.Link,
                  {
                    to: `/login?redirectTo=${window.location.href}`,
                    className: "btn-sm btn-secondary",
                    onClick: (e) => e.stopPropagation(),
                    children: "Login"
                  },
                  void 0,
                  !1,
                  {
                    fileName: "app/components/auth/auth-check.tsx",
                    lineNumber: 41,
                    columnNumber: 15
                  },
                  this
                ),
                /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)(
                  "button",
                  {
                    className: "btn-sm btn-gray",
                    onClick: (e) => {
                      e.stopPropagation(), setOpen(!1);
                    },
                    children: "Cancel"
                  },
                  void 0,
                  !1,
                  {
                    fileName: "app/components/auth/auth-check.tsx",
                    lineNumber: 48,
                    columnNumber: 15
                  },
                  this
                )
              ] }, void 0, !0, {
                fileName: "app/components/auth/auth-check.tsx",
                lineNumber: 40,
                columnNumber: 13
              }, this)
            ]
          },
          void 0,
          !0,
          {
            fileName: "app/components/auth/auth-check.tsx",
            lineNumber: 34,
            columnNumber: 11
          },
          this
        ) : null
      ]
    },
    void 0,
    !0,
    {
      fileName: "app/components/auth/auth-check.tsx",
      lineNumber: 25,
      columnNumber: 7
    },
    this
  ) : children(user);
}

// app/components/logout-form.tsx
var import_jsx_dev_runtime8 = require("react/jsx-dev-runtime");
function LogoutForm({
  btnClassName,
  formProps
}) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("form", { action: "/logout", method: "post", ...formProps, children: /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)(
    "button",
    {
      type: "submit",
      className: `w-full h-full ${btnClassName || ""}`,
      children: "Logout"
    },
    void 0,
    !1,
    {
      fileName: "app/components/logout-form.tsx",
      lineNumber: 12,
      columnNumber: 7
    },
    this
  ) }, void 0, !1, {
    fileName: "app/components/logout-form.tsx",
    lineNumber: 11,
    columnNumber: 5
  }, this);
}

// app/components/sider/sider-context.tsx
var import_react7 = require("@remix-run/react"), import_react8 = require("react"), import_react9 = require("react"), import_jsx_dev_runtime9 = require("react/jsx-dev-runtime");
var SiderContext = (0, import_react9.createContext)({
  hidden: !1,
  setHidden: () => {
  },
  close: !1,
  setClose: () => {
  }
}), { Provider } = SiderContext;
function SiderProvider({
  children
}) {
  let location = (0, import_react7.useLocation)(), [hidden, setHidden] = (0, import_react8.useState)(!1), [close, setClose] = (0, import_react8.useState)(!1);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)(Provider, { value: { hidden, setHidden, close, setClose }, children }, void 0, !1, {
    fileName: "app/components/sider/sider-context.tsx",
    lineNumber: 102,
    columnNumber: 5
  }, this);
}

// app/components/sider/sider.tsx
var import_jsx_dev_runtime10 = require("react/jsx-dev-runtime");
function SiderItem({
  icon,
  value,
  hasChild = !1,
  route
}) {
  return route ? /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(
    import_react10.NavLink,
    {
      to: route,
      onClick: () => {
      },
      className: ({ isActive }) => `
          sider-item sider-item-svg relative 
          flex
          items-center gap-4 
         
          transition-colors
          hover:bg-primary
          
          ${hasChild ? `
            after:absolute
            after:bottom-0
            after:-ml-9
            after:block
            after:h-[1px]
            after:w-full
            after:bg-white
            after:content-['']
            ` : ""}
          ${isActive ? "  bg-primary" : " text-black "}
          `,
      children: [
        icon,
        value
      ]
    },
    void 0,
    !0,
    {
      fileName: "app/components/sider/sider.tsx",
      lineNumber: 30,
      columnNumber: 7
    },
    this
  ) : typeof value != "string" && import_react11.default.isValidElement(value) ? value : /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(
    "span",
    {
      className: `
          ml-5 !mt-8 flex 
          select-none items-center
          gap-4 text-sm
          uppercase
          tracking-wider
          text-gray-400
  `,
      children: value
    },
    void 0,
    !1,
    {
      fileName: "app/components/sider/sider.tsx",
      lineNumber: 82,
      columnNumber: 5
    },
    this
  );
}
function Sider() {
  let defaultSiderValue = [
    { value: "Pages" },
    { icon: /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(recipe_default, {}, void 0, !1, {
      fileName: "app/components/sider/sider.tsx",
      lineNumber: 104,
      columnNumber: 13
    }, this), value: "My Recipes", route: "my-recipes" },
    { icon: /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(favorite_default, {}, void 0, !1, {
      fileName: "app/components/sider/sider.tsx",
      lineNumber: 105,
      columnNumber: 13
    }, this), value: "Favorite", route: "favorite" },
    { icon: /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(basket_default, {}, void 0, !1, {
      fileName: "app/components/sider/sider.tsx",
      lineNumber: 106,
      columnNumber: 13
    }, this), value: "Basket", route: "basket" },
    { value: "Authentication" }
  ], { hidden, close } = (0, import_react11.useContext)(SiderContext);
  return hidden ? null : /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(
    "nav",
    {
      className: `
      fixed top-0 
      z-20 
      flex h-screen 
      w-[255px] 
      flex-shrink-0 flex-col 
      space-y-4 
      overflow-auto 
      bg-white 
      pt-4 
      shadow-xl
      transition-transform
     ${close ? "-translate-x-full" : ""}
     `,
      children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(import_react10.NavLink, { to: "/", children: /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)("div", { className: "sider-item flex h-7 p-0", children: /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(logo_default, {}, void 0, !1, {
          fileName: "app/components/sider/sider.tsx",
          lineNumber: 133,
          columnNumber: 11
        }, this) }, void 0, !1, {
          fileName: "app/components/sider/sider.tsx",
          lineNumber: 132,
          columnNumber: 9
        }, this) }, void 0, !1, {
          fileName: "app/components/sider/sider.tsx",
          lineNumber: 131,
          columnNumber: 7
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)("div", { className: "flex-1 space-y-4", children: [
          defaultSiderValue.map(
            ({ icon, value, children, route, isBtn }, idx) => isBtn ? /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)("div", { className: "sider-item px-0 pb-8", children: route ? /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(import_react10.Link, { to: route, className: "btn-md btn-primary", children: value }, void 0, !1, {
              fileName: "app/components/sider/sider.tsx",
              lineNumber: 161,
              columnNumber: 21
            }, this) : value }, idx, !1, {
              fileName: "app/components/sider/sider.tsx",
              lineNumber: 159,
              columnNumber: 17
            }, this) : /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(import_react11.default.Fragment, { children: [
              /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(
                SiderItem,
                {
                  value,
                  icon,
                  hasChild: typeof children < "u",
                  route,
                  idx
                },
                void 0,
                !1,
                {
                  fileName: "app/components/sider/sider.tsx",
                  lineNumber: 172,
                  columnNumber: 17
                },
                this
              ),
              children && /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)("div", { className: "space-y-4", children: children.map((child, idx2) => /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(
                SiderItem,
                {
                  icon: child.icon,
                  value: child.value,
                  route: child.route
                },
                `${child.value}_${idx2}`,
                !1,
                {
                  fileName: "app/components/sider/sider.tsx",
                  lineNumber: 184,
                  columnNumber: 23
                },
                this
              )) }, void 0, !1, {
                fileName: "app/components/sider/sider.tsx",
                lineNumber: 182,
                columnNumber: 19
              }, this)
            ] }, idx, !0, {
              fileName: "app/components/sider/sider.tsx",
              lineNumber: 171,
              columnNumber: 15
            }, this)
          ),
          /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(AuthCheck, { loginConfirmModal: !1, children: (user) => user && user.id !== null ? /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(
            LogoutForm,
            {
              formProps: { className: "flex items-center" },
              btnClassName: ` gap-4 relative
          sider-item sider-item-svg 
          text-left
          transition-colors hover:bg-primary`
            },
            void 0,
            !1,
            {
              fileName: "app/components/sider/sider.tsx",
              lineNumber: 201,
              columnNumber: 17
            },
            this
          ) : /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)(
            SiderItem,
            {
              value: "Login",
              route: `/login?redirectTo=${window ? window.location.href : ""}`
            },
            void 0,
            !1,
            {
              fileName: "app/components/sider/sider.tsx",
              lineNumber: 211,
              columnNumber: 15
            },
            this
          ) }, void 0, !1, {
            fileName: "app/components/sider/sider.tsx",
            lineNumber: 197,
            columnNumber: 9
          }, this)
        ] }, void 0, !0, {
          fileName: "app/components/sider/sider.tsx",
          lineNumber: 154,
          columnNumber: 7
        }, this)
      ]
    },
    void 0,
    !0,
    {
      fileName: "app/components/sider/sider.tsx",
      lineNumber: 115,
      columnNumber: 5
    },
    this
  );
}

// app/components/layout/index.tsx
var import_jsx_dev_runtime11 = require("react/jsx-dev-runtime"), LayoutChildren = ({ children }) => {
  let { close } = (0, import_react12.useContext)(SiderContext);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)("div", { className: `min-h-screen flex-1 pt-16 ${close ? "" : "pl-[255px]"}`, children }, void 0, !1, {
    fileName: "app/components/layout/index.tsx",
    lineNumber: 10,
    columnNumber: 5
  }, this);
};
function Layout({
  children,
  toolbar
}) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(SiderProvider, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)("div", { className: "flex bg-gray-100", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(Sider, {}, void 0, !1, {
      fileName: "app/components/layout/index.tsx",
      lineNumber: 26,
      columnNumber: 9
    }, this),
    toolbar,
    /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)(LayoutChildren, { children }, void 0, !1, {
      fileName: "app/components/layout/index.tsx",
      lineNumber: 28,
      columnNumber: 9
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/layout/index.tsx",
    lineNumber: 25,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "app/components/layout/index.tsx",
    lineNumber: 24,
    columnNumber: 5
  }, this);
}

// app/utils/db.server.ts
var import_client = require("@prisma/client"), db;
global.__db || (global.__db = new import_client.PrismaClient()), db = global.__db;

// app/root.tsx
var import_react_redux2 = require("react-redux"), import_react22 = __toESM(require_react());

// app/store/configure-store.ts
var import_toolkit6 = require("@reduxjs/toolkit"), import_redux_persist = __toESM(require_lib());

// node_modules/redux-persist/es/constants.js
var KEY_PREFIX = "persist:", FLUSH = "persist/FLUSH", REHYDRATE = "persist/REHYDRATE", PAUSE = "persist/PAUSE", PERSIST = "persist/PERSIST", PURGE = "persist/PURGE";
var DEFAULT_VERSION = -1;

// node_modules/redux-persist/es/stateReconciler/autoMergeLevel1.js
function _typeof(obj) {
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof = function(obj2) {
    return typeof obj2;
  } : _typeof = function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys(source, !0).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(source).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
}
function autoMergeLevel1(inboundState, originalState, reducedState, _ref) {
  var debug = _ref.debug, newState = _objectSpread({}, reducedState);
  return inboundState && _typeof(inboundState) === "object" && Object.keys(inboundState).forEach(function(key) {
    if (key !== "_persist") {
      if (originalState[key] !== reducedState[key]) {
        debug && console.log("redux-persist/stateReconciler: sub state for key `%s` modified, skipping.", key);
        return;
      }
      newState[key] = inboundState[key];
    }
  }), debug && inboundState && _typeof(inboundState) === "object" && console.log("redux-persist/stateReconciler: rehydrated keys '".concat(Object.keys(inboundState).join(", "), "'")), newState;
}

// node_modules/redux-persist/es/createPersistoid.js
function createPersistoid(config) {
  var blacklist2 = config.blacklist || null, whitelist = config.whitelist || null, transforms = config.transforms || [], throttle = config.throttle || 0, storageKey = "".concat(config.keyPrefix !== void 0 ? config.keyPrefix : KEY_PREFIX).concat(config.key), storage3 = config.storage, serialize;
  config.serialize === !1 ? serialize = function(x) {
    return x;
  } : typeof config.serialize == "function" ? serialize = config.serialize : serialize = defaultSerialize;
  var writeFailHandler = config.writeFailHandler || null, lastState = {}, stagedState = {}, keysToProcess = [], timeIterator = null, writePromise = null, update = function(state) {
    Object.keys(state).forEach(function(key) {
      !passWhitelistBlacklist(key) || lastState[key] !== state[key] && keysToProcess.indexOf(key) === -1 && keysToProcess.push(key);
    }), Object.keys(lastState).forEach(function(key) {
      state[key] === void 0 && passWhitelistBlacklist(key) && keysToProcess.indexOf(key) === -1 && lastState[key] !== void 0 && keysToProcess.push(key);
    }), timeIterator === null && (timeIterator = setInterval(processNextKey, throttle)), lastState = state;
  };
  function processNextKey() {
    if (keysToProcess.length === 0) {
      timeIterator && clearInterval(timeIterator), timeIterator = null;
      return;
    }
    var key = keysToProcess.shift(), endState = transforms.reduce(function(subState, transformer) {
      return transformer.in(subState, key, lastState);
    }, lastState[key]);
    if (endState !== void 0)
      try {
        stagedState[key] = serialize(endState);
      } catch (err) {
        console.error("redux-persist/createPersistoid: error serializing state", err);
      }
    else
      delete stagedState[key];
    keysToProcess.length === 0 && writeStagedState();
  }
  function writeStagedState() {
    Object.keys(stagedState).forEach(function(key) {
      lastState[key] === void 0 && delete stagedState[key];
    }), writePromise = storage3.setItem(storageKey, serialize(stagedState)).catch(onWriteFail);
  }
  function passWhitelistBlacklist(key) {
    return !(whitelist && whitelist.indexOf(key) === -1 && key !== "_persist" || blacklist2 && blacklist2.indexOf(key) !== -1);
  }
  function onWriteFail(err) {
    writeFailHandler && writeFailHandler(err), err && console.error("Error storing data", err);
  }
  var flush = function() {
    for (; keysToProcess.length !== 0; )
      processNextKey();
    return writePromise || Promise.resolve();
  };
  return {
    update,
    flush
  };
}
function defaultSerialize(data) {
  return JSON.stringify(data);
}

// node_modules/redux-persist/es/getStoredState.js
function getStoredState(config) {
  var transforms = config.transforms || [], storageKey = "".concat(config.keyPrefix !== void 0 ? config.keyPrefix : KEY_PREFIX).concat(config.key), storage3 = config.storage, debug = config.debug, deserialize;
  return config.deserialize === !1 ? deserialize = function(x) {
    return x;
  } : typeof config.deserialize == "function" ? deserialize = config.deserialize : deserialize = defaultDeserialize, storage3.getItem(storageKey).then(function(serialized) {
    if (serialized)
      try {
        var state = {}, rawState = deserialize(serialized);
        return Object.keys(rawState).forEach(function(key) {
          state[key] = transforms.reduceRight(function(subState, transformer) {
            return transformer.out(subState, key, rawState);
          }, deserialize(rawState[key]));
        }), state;
      } catch (err) {
        throw debug && console.log("redux-persist/getStoredState: Error restoring data ".concat(serialized), err), err;
      }
    else
      return;
  });
}
function defaultDeserialize(serial) {
  return JSON.parse(serial);
}

// node_modules/redux-persist/es/purgeStoredState.js
function purgeStoredState(config) {
  var storage3 = config.storage, storageKey = "".concat(config.keyPrefix !== void 0 ? config.keyPrefix : KEY_PREFIX).concat(config.key);
  return storage3.removeItem(storageKey, warnIfRemoveError);
}
function warnIfRemoveError(err) {
  err && console.error("redux-persist/purgeStoredState: Error purging data stored state", err);
}

// node_modules/redux-persist/es/persistReducer.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys2(source, !0).forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(source).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty2(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded), key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++)
      key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source, key) || (target[key] = source[key]));
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {}, sourceKeys = Object.keys(source), key, i;
  for (i = 0; i < sourceKeys.length; i++)
    key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
  return target;
}
var DEFAULT_TIMEOUT = 5e3;
function persistReducer(config, baseReducer) {
  if (!config)
    throw new Error("config is required for persistReducer");
  if (!config.key)
    throw new Error("key is required in persistor config");
  if (!config.storage)
    throw new Error("redux-persist: config.storage is required. Try using one of the provided storage engines `import storage from 'redux-persist/lib/storage'`");
  var version = config.version !== void 0 ? config.version : DEFAULT_VERSION, debug = config.debug || !1, stateReconciler = config.stateReconciler === void 0 ? autoMergeLevel1 : config.stateReconciler, getStoredState2 = config.getStoredState || getStoredState, timeout = config.timeout !== void 0 ? config.timeout : DEFAULT_TIMEOUT, _persistoid = null, _purge = !1, _paused = !0, conditionalUpdate = function(state) {
    return state._persist.rehydrated && _persistoid && !_paused && _persistoid.update(state), state;
  };
  return function(state, action8) {
    var _ref = state || {}, _persist = _ref._persist, rest = _objectWithoutProperties(_ref, ["_persist"]), restState = rest;
    if (action8.type === PERSIST) {
      var _sealed = !1, _rehydrate = function(payload, err) {
        _sealed && console.error('redux-persist: rehydrate for "'.concat(config.key, '" called after timeout.'), payload, err), _sealed || (action8.rehydrate(config.key, payload, err), _sealed = !0);
      };
      if (timeout && setTimeout(function() {
        !_sealed && _rehydrate(void 0, new Error('redux-persist: persist timed out for persist key "'.concat(config.key, '"')));
      }, timeout), _paused = !1, _persistoid || (_persistoid = createPersistoid(config)), _persist)
        return _objectSpread2({}, baseReducer(restState, action8), {
          _persist
        });
      if (typeof action8.rehydrate != "function" || typeof action8.register != "function")
        throw new Error("redux-persist: either rehydrate or register is not a function on the PERSIST action. This can happen if the action is being replayed. This is an unexplored use case, please open an issue and we will figure out a resolution.");
      return action8.register(config.key), getStoredState2(config).then(function(restoredState) {
        var migrate = config.migrate || function(s, v) {
          return Promise.resolve(s);
        };
        migrate(restoredState, version).then(function(migratedState) {
          _rehydrate(migratedState);
        }, function(migrateErr) {
          migrateErr && console.error("redux-persist: migration error", migrateErr), _rehydrate(void 0, migrateErr);
        });
      }, function(err) {
        _rehydrate(void 0, err);
      }), _objectSpread2({}, baseReducer(restState, action8), {
        _persist: {
          version,
          rehydrated: !1
        }
      });
    } else {
      if (action8.type === PURGE)
        return _purge = !0, action8.result(purgeStoredState(config)), _objectSpread2({}, baseReducer(restState, action8), {
          _persist
        });
      if (action8.type === FLUSH)
        return action8.result(_persistoid && _persistoid.flush()), _objectSpread2({}, baseReducer(restState, action8), {
          _persist
        });
      if (action8.type === PAUSE)
        _paused = !0;
      else if (action8.type === REHYDRATE) {
        if (_purge)
          return _objectSpread2({}, restState, {
            _persist: _objectSpread2({}, _persist, {
              rehydrated: !0
            })
          });
        if (action8.key === config.key) {
          var reducedState = baseReducer(restState, action8), inboundState = action8.payload, reconciledRest = stateReconciler !== !1 && inboundState !== void 0 ? stateReconciler(inboundState, state, reducedState, config) : reducedState, _newState = _objectSpread2({}, reconciledRest, {
            _persist: _objectSpread2({}, _persist, {
              rehydrated: !0
            })
          });
          return conditionalUpdate(_newState);
        }
      }
    }
    if (!_persist)
      return baseReducer(state, action8);
    var newState = baseReducer(restState, action8);
    return newState === restState ? state : conditionalUpdate(_objectSpread2({}, newState, {
      _persist
    }));
  };
}

// app/store/reducer.ts
var import_toolkit5 = require("@reduxjs/toolkit");

// app/store/ingredients-slice.ts
var import_toolkit = require("@reduxjs/toolkit"), initialState = [], basketSlice = (0, import_toolkit.createSlice)({
  name: "ingredients",
  initialState,
  reducers: {
    addIngredient: (state, action8) => {
      state.find(
        (item) => item.name === action8.payload.name
      ) || state.push(action8.payload);
    },
    deleteIngredient: (state, action8) => state.filter((item) => item.name !== action8.payload),
    updateHadQuan: (state, action8) => {
      let index = state.findIndex((item) => item.name === action8.payload.name);
      index !== -1 && (state[index].hadQant = action8.payload.hadQant);
    },
    addRecipeId: (state, action8) => {
      let ingredientIdx = state.findIndex(
        (item) => item.name === action8.payload.name
      );
      state[ingredientIdx].recipeIds.findIndex(
        (id) => id === action8.payload.recipeId
      ) === -1 && state[ingredientIdx].recipeIds.push(action8.payload.recipeId);
    },
    deleteRecipeId: (state, action8) => {
      let ingredientIdx = state.findIndex(
        (item) => item.name === action8.payload.name
      );
      if (state[ingredientIdx].recipeIds.findIndex(
        (id) => id === action8.payload.recipeId
      ) !== -1) {
        let filterState = [...state][ingredientIdx].recipeIds.filter(
          (id) => id !== action8.payload.recipeId
        );
        if (filterState.length === 0)
          return state.filter((item) => item.name !== action8.payload.name);
        state[ingredientIdx].recipeIds = filterState;
      }
    }
  }
}), ingredients_slice_default = basketSlice.reducer, {
  addIngredient,
  deleteIngredient,
  updateHadQuan,
  addRecipeId,
  deleteRecipeId
} = basketSlice.actions;

// app/store/recipe-servings-slice.ts
var import_toolkit2 = require("@reduxjs/toolkit"), initialState2 = [], recipeServingsSlice = (0, import_toolkit2.createSlice)({
  name: "recipe-servings",
  initialState: initialState2,
  reducers: {
    addRecipeServings: (state, action8) => {
      state.push({ ...action8.payload });
    },
    deleteRecipeServings: (state, action8) => state.filter((item) => item.recipeId !== action8.payload.recipeId),
    updateRecipeServings: (state, action8) => {
      let recipeIdx = state.findIndex(
        (item) => item.recipeId === action8.payload.recipeId
      );
      recipeIdx !== -1 && (state[recipeIdx].servings = action8.payload.servings);
    }
  }
}), recipe_servings_slice_default = recipeServingsSlice.reducer, { addRecipeServings, deleteRecipeServings, updateRecipeServings } = recipeServingsSlice.actions;

// app/store/upload-temp/step-form-slice.ts
var import_toolkit3 = require("@reduxjs/toolkit"), initialState3 = [], stepFormSlice = (0, import_toolkit3.createSlice)({
  name: "step-form",
  initialState: initialState3,
  reducers: {
    addStep: (state, action8) => {
      state.push(action8.payload);
    },
    updateStep: (state, action8) => {
      let idx = state.findIndex((step) => step.id === action8.payload.id);
      idx > -1 && (state[idx] = action8.payload);
    },
    deleteStep: (state, action8) => state.filter((step) => step.id !== action8.payload.id)
  }
}), step_form_slice_default = stepFormSlice.reducer, { addStep, updateStep, deleteStep } = stepFormSlice.actions;

// app/store/upload-temp/details-form-slice.ts
var import_toolkit4 = require("@reduxjs/toolkit"), initialState4 = {
  tags: [],
  title: "",
  difficulty: "EASY1",
  thumbnail: { name: "", src: "", type: "", size: "" }
}, detailsFormSlice = (0, import_toolkit4.createSlice)({
  name: "details-form",
  initialState: initialState4,
  reducers: {
    updateDetails: (state, action8) => action8.payload
  }
}), details_form_slice_default = detailsFormSlice.reducer, { updateDetails } = detailsFormSlice.actions;

// app/store/reducer.ts
var rootReducer = (0, import_toolkit5.combineReducers)({
  ingredients: ingredients_slice_default,
  recipeServings: recipe_servings_slice_default,
  stepForm: step_form_slice_default,
  detailsForm: details_form_slice_default
}), reducer_default = rootReducer;

// app/store/configure-store.ts
var import_react_redux = require("react-redux"), import_autoMergeLevel2 = __toESM(require_autoMergeLevel2());

// app/store/storage.ts
var import_createWebStorage = __toESM(require_createWebStorage()), createNoopStorage = () => ({
  getItem(_key) {
    return Promise.resolve(null);
  },
  setItem(_key, value) {
    return Promise.resolve(value);
  },
  removeItem(_key) {
    return Promise.resolve();
  }
}), storage = typeof window < "u" ? (0, import_createWebStorage.default)("local") : createNoopStorage(), storage_default = storage;

// app/store/configure-store.ts
var persistConfig = {
  key: "root",
  storage: storage_default,
  stateReconciler: import_autoMergeLevel2.default
}, persistedReducer = persistReducer(
  persistConfig,
  reducer_default
), store = (0, import_toolkit6.configureStore)({
  reducer: persistedReducer,
  devTools: !0,
  middleware: (getDefaultMiddleware) => getDefaultMiddleware({
    serializableCheck: {
      ignoredActions: [import_redux_persist.FLUSH, import_redux_persist.REHYDRATE, import_redux_persist.PAUSE, import_redux_persist.PERSIST, import_redux_persist.PURGE, import_redux_persist.REGISTER]
    }
  })
}), persistor = (0, import_redux_persist.persistStore)(store), useAppDispatch = import_react_redux.useDispatch, useAppSelector = import_react_redux.useSelector;

// app/components/layout/basket-modal.tsx
var import_react17 = require("@remix-run/react");

// app/components/basket/recipe-servings-form.tsx
var import_react14 = require("@remix-run/react"), import_react15 = require("react"), import_react_hook_form2 = require("react-hook-form");

// app/components/inputs/number-input.tsx
var import_react13 = require("react"), import_react_hook_form = require("react-hook-form"), import_error_message = require("@hookform/error-message"), import_jsx_dev_runtime12 = require("react/jsx-dev-runtime"), NumberInput = ({
  hasSetBtn,
  unit,
  registerName,
  maxValue,
  showErrors,
  onChange,
  onSubmit
}) => {
  var _a;
  let {
    watch,
    register: register2,
    setValue,
    handleSubmit,
    formState: { errors }
  } = (0, import_react_hook_form.useFormContext)(), input = watch(registerName), inputRef = (0, import_react13.useRef)(null);
  return (0, import_react13.useEffect)(() => {
    let subscription = watch(() => {
      onSubmit && handleSubmit(onSubmit)();
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [handleSubmit, onSubmit, watch]), /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)("div", { className: "flex", children: [
    hasSetBtn ? /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(
      "button",
      {
        className: " flex items-center rounded-l-lg border border-r-0 border-gray-200 disabled:text-gray-400",
        type: "button",
        onClick: () => {
          inputRef.current && parseInt(inputRef.current.value) > 1 && (inputRef.current.value = parseInt(inputRef.current.value) - 1 + "", setValue("input", parseInt(inputRef.current.value)));
        },
        disabled: input <= 1,
        children: /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)("span", { className: "material-symbols-outlined", children: "remove" }, void 0, !1, {
          fileName: "app/components/inputs/number-input.tsx",
          lineNumber: 58,
          columnNumber: 11
        }, this)
      },
      void 0,
      !1,
      {
        fileName: "app/components/inputs/number-input.tsx",
        lineNumber: 46,
        columnNumber: 9
      },
      this
    ) : null,
    /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(
      "input",
      {
        ...register2(registerName, {
          valueAsNumber: !0,
          max: maxValue ? { value: maxValue, message: "Out of original quantity" } : void 0,
          min: 0
        }),
        type: "number",
        className: `input max-w-[60px] text-right ${(_a = errors.input) != null && _a.message ? "outline-red-500 bg-red-50 border-red-500 text-red-500" : ""}
        ${hasSetBtn ? "rounded-none" : ""}
        `,
        placeholder: "0",
        onKeyDown: (e) => {
          (!input || input && input.toString().length === 0) && e.key === "0" && e.preventDefault(), maxValue !== void 0 && !isNaN(input) && (input + "").replace(".", "").length === (maxValue + "").replace(".", "").length && [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].includes(parseInt(e.key)) && e.preventDefault(), e.key === "-" && e.preventDefault();
        },
        ref: (el) => {
          inputRef.current = el, register2("input").ref(el);
        }
      },
      void 0,
      !1,
      {
        fileName: "app/components/inputs/number-input.tsx",
        lineNumber: 61,
        columnNumber: 7
      },
      this
    ),
    hasSetBtn ? /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(
      "button",
      {
        type: "button",
        className: "flex items-center border border-l-0 border-gray-200 rounded-r-lg",
        onClick: () => {
          inputRef.current && (inputRef.current.value = parseInt(inputRef.current.value) + 1 + "", setValue("input", parseInt(inputRef.current.value)));
        },
        children: /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)("span", { className: "material-symbols-outlined", children: "add" }, void 0, !1, {
          fileName: "app/components/inputs/number-input.tsx",
          lineNumber: 114,
          columnNumber: 11
        }, this)
      },
      void 0,
      !1,
      {
        fileName: "app/components/inputs/number-input.tsx",
        lineNumber: 104,
        columnNumber: 9
      },
      this
    ) : null,
    unit ? /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)("span", { className: "ml-2 flex items-center", children: unit }, void 0, !1, {
      fileName: "app/components/inputs/number-input.tsx",
      lineNumber: 117,
      columnNumber: 15
    }, this) : null,
    showErrors && /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)(
      import_error_message.ErrorMessage,
      {
        name: registerName,
        errors,
        render: ({ message }) => /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)("span", { className: "absolute left-0 top-full text-red-500 text-xs", children: message }, void 0, !1, {
          fileName: "app/components/inputs/number-input.tsx",
          lineNumber: 123,
          columnNumber: 13
        }, this)
      },
      void 0,
      !1,
      {
        fileName: "app/components/inputs/number-input.tsx",
        lineNumber: 119,
        columnNumber: 9
      },
      this
    )
  ] }, void 0, !0, {
    fileName: "app/components/inputs/number-input.tsx",
    lineNumber: 44,
    columnNumber: 5
  }, this);
}, number_input_default = NumberInput;

// app/components/basket/recipe-servings-form.tsx
var import_jsx_dev_runtime13 = require("react/jsx-dev-runtime"), ServingsForm = ({
  recipeId,
  defaultValue = 1
}) => {
  let methods = (0, import_react_hook_form2.useForm)({
    defaultValues: { input: defaultValue },
    mode: "onChange"
  }), dispatch = useAppDispatch(), onChangeSubmit = (0, import_react15.useCallback)(
    (value) => {
      dispatch(
        updateRecipeServings({
          servings: value.input,
          recipeId
        })
      );
    },
    [dispatch, recipeId]
  );
  return (0, import_react15.useEffect)(() => {
    methods.reset({ input: defaultValue });
  }, [defaultValue, methods]), /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(import_react_hook_form2.FormProvider, { ...methods, children: /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(import_react14.Form, { onSubmit: (e) => void e.preventDefault(), children: /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)(
    number_input_default,
    {
      registerName: "input",
      hasSetBtn: !0,
      onSubmit: (v) => {
        onChangeSubmit(v);
      }
    },
    void 0,
    !1,
    {
      fileName: "app/components/basket/recipe-servings-form.tsx",
      lineNumber: 41,
      columnNumber: 9
    },
    this
  ) }, void 0, !1, {
    fileName: "app/components/basket/recipe-servings-form.tsx",
    lineNumber: 39,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "app/components/basket/recipe-servings-form.tsx",
    lineNumber: 38,
    columnNumber: 5
  }, this);
}, recipe_servings_form_default = ServingsForm;

// app/components/card/card-list-item.tsx
var import_react16 = require("@remix-run/react");

// public/assets/img1.jpeg
var img1_default = "/build/_assets/img1-L5MTI6MD.jpeg";

// app/components/card/card-list-item.tsx
var import_jsx_dev_runtime14 = require("react/jsx-dev-runtime");
function CardListItem({
  title,
  onDelete,
  recipeId,
  subTitle
}) {
  let location = (0, import_react16.useLocation)();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)("div", { className: "flex gap-4 ", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)("div", { className: "w-24", children: /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)("div", { className: "aspect-w-4 aspect-h-3 overflow-hidden rounded-lg shadow-md", children: /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)(
      "img",
      {
        className: "w-full h-full object-cover object-center ",
        src: img1_default
      },
      void 0,
      !1,
      {
        fileName: "app/components/card/card-list-item.tsx",
        lineNumber: 23,
        columnNumber: 11
      },
      this
    ) }, void 0, !1, {
      fileName: "app/components/card/card-list-item.tsx",
      lineNumber: 21,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "app/components/card/card-list-item.tsx",
      lineNumber: 20,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)("div", { className: "flex-1 flex flex-col justify-between", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)("h4", { className: "flex-1 text-black font-medium", children: title }, void 0, !1, {
        fileName: "app/components/card/card-list-item.tsx",
        lineNumber: 32,
        columnNumber: 9
      }, this),
      subTitle
    ] }, void 0, !0, {
      fileName: "app/components/card/card-list-item.tsx",
      lineNumber: 31,
      columnNumber: 7
    }, this),
    onDelete ? /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)(import_react16.Form, { className: "flex ", onSubmit: onDelete, method: "post", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)(
        "input",
        {
          type: "hidden",
          name: "redirectTo",
          value: `${location.pathname}${location.search}`
        },
        void 0,
        !1,
        {
          fileName: "app/components/card/card-list-item.tsx",
          lineNumber: 37,
          columnNumber: 11
        },
        this
      ),
      /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)("input", { type: "hidden", name: "deleteId", value: recipeId }, void 0, !1, {
        fileName: "app/components/card/card-list-item.tsx",
        lineNumber: 42,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)(
        "button",
        {
          className: "flex p-1 rounded-full",
          type: "submit",
          children: /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)("span", { className: "material-symbols-rounded text-lg leading-none text-gray-500", children: "close" }, void 0, !1, {
            fileName: "app/components/card/card-list-item.tsx",
            lineNumber: 48,
            columnNumber: 13
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "app/components/card/card-list-item.tsx",
          lineNumber: 43,
          columnNumber: 11
        },
        this
      )
    ] }, void 0, !0, {
      fileName: "app/components/card/card-list-item.tsx",
      lineNumber: 36,
      columnNumber: 9
    }, this) : null
  ] }, void 0, !0, {
    fileName: "app/components/card/card-list-item.tsx",
    lineNumber: 19,
    columnNumber: 5
  }, this);
}

// app/components/layout/basket-modal.tsx
var import_jsx_dev_runtime15 = require("react/jsx-dev-runtime");
function BasketModal({
  open,
  onClose,
  basketData
}) {
  let recipes = useAppSelector((state) => state.recipeServings), submit = (0, import_react17.useSubmit)();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime15.jsxDEV)(
    Modal,
    {
      dialogClassName: "mt-20 backdrop:bg-gray-900/30 ",
      className: "max-w-3xl w-[60vw] max-h-[70vh] p-8 rounded-2xl space-y-6 overflow-auto overscroll-contain",
      open,
      onClose: () => onClose(),
      children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime15.jsxDEV)("h2", { children: "Basket" }, void 0, !1, {
          fileName: "app/components/layout/basket-modal.tsx",
          lineNumber: 26,
          columnNumber: 7
        }, this),
        (basketData == null ? void 0 : basketData.length) === 0 ? /* @__PURE__ */ (0, import_jsx_dev_runtime15.jsxDEV)("div", { className: "text-gray-400", children: "Basket is empty" }, void 0, !1, {
          fileName: "app/components/layout/basket-modal.tsx",
          lineNumber: 28,
          columnNumber: 9
        }, this) : basketData == null ? void 0 : basketData.map(({ id, title }) => {
          var _a;
          return /* @__PURE__ */ (0, import_jsx_dev_runtime15.jsxDEV)(
            CardListItem,
            {
              title,
              recipeId: id,
              onDelete: (e) => submit(e.currentTarget, {
                replace: !0
              }),
              subTitle: /* @__PURE__ */ (0, import_jsx_dev_runtime15.jsxDEV)(
                recipe_servings_form_default,
                {
                  recipeId: id,
                  defaultValue: (_a = recipes.find((item) => id === item.recipeId)) == null ? void 0 : _a.servings
                },
                void 0,
                !1,
                {
                  fileName: "app/components/layout/basket-modal.tsx",
                  lineNumber: 42,
                  columnNumber: 15
                },
                this
              )
            },
            id,
            !1,
            {
              fileName: "app/components/layout/basket-modal.tsx",
              lineNumber: 31,
              columnNumber: 11
            },
            this
          );
        })
      ]
    },
    void 0,
    !0,
    {
      fileName: "app/components/layout/basket-modal.tsx",
      lineNumber: 20,
      columnNumber: 5
    },
    this
  );
}

// app/actions/basket/delete-recipe.ts
var import_node2 = require("@remix-run/node");
var deleteRecipe = async ({ request }) => {
  let formData = await request.formData(), recipeId = formData.get("deleteId"), redirectTo = formData.get("redirectTo");
  return typeof redirectTo != "string" || typeof recipeId != "string" ? (0, import_node2.json)({ formError: "Form not submitted" }, { status: 400 }) : (await db.basket.update({
    where: { userId: "testuser0" },
    data: { recipes: { disconnect: { id: recipeId } } }
  }), (0, import_node2.redirect)(redirectTo));
};

// app/utils/session.server.ts
var argon2 = __toESM(require("argon2")), import_node3 = require("@remix-run/node");
async function login({ email, password }) {
  let user = await db.user.findUnique({
    where: { email }
  });
  return !user || !await argon2.verify(user.password, password) ? null : { id: user.id, email };
}
var sessionSecret = process.env.SESSION_SECRET;
if (!sessionSecret)
  throw new Error("SESSION_SECRET must be set");
var storage2 = (0, import_node3.createCookieSessionStorage)({
  cookie: {
    name: "RP_session",
    secure: !1,
    secrets: [sessionSecret],
    sameSite: "lax",
    path: "/",
    maxAge: 60 * 60 * 24 * 30,
    httpOnly: !0
  }
});
async function createUserSession(userId, redirectTo) {
  let session = await storage2.getSession();
  return session.set("userId", userId), (0, import_node3.redirect)(redirectTo, {
    headers: {
      "Set-Cookie": await storage2.commitSession(session)
    }
  });
}
function getUserSession(request) {
  return storage2.getSession(request.headers.get("Cookie"));
}
async function getUserId(request) {
  let userId = (await getUserSession(request)).get("userId");
  return !userId || typeof userId != "string" ? null : userId;
}
async function requireUserId(request, redirectTo = new URL(request.url).pathname) {
  let userId = (await getUserSession(request)).get("userId");
  if (!userId || typeof userId != "string") {
    let searchParams = new URLSearchParams([["redirectTo", redirectTo]]);
    throw (0, import_node3.redirect)(`/login?${searchParams}`);
  }
  return userId;
}
async function logout(request) {
  let session = await getUserSession(request);
  return (0, import_node3.redirect)("/", {
    headers: {
      "Set-Cookie": await storage2.destroySession(session)
    }
  });
}
async function register({ email, password }) {
  let passwordHash = await argon2.hash(password), user = await db.user.create({
    data: { email, password: passwordHash }
  });
  return { id: user.id, username: user.name };
}

// app/components/layout/toolbar.tsx
var import_react19 = require("@remix-run/react"), import_react20 = require("react");

// app/components/drop-down-menu.tsx
var import_react18 = require("react"), import_jsx_dev_runtime16 = require("react/jsx-dev-runtime");
function DropdownMenu({
  hasDownArrow,
  icon,
  summary,
  details,
  direction = "left"
}) {
  let [open, setOpen] = (0, import_react18.useState)(!1), detailsRef = (0, import_react18.useRef)(null);
  return (0, import_react18.useEffect)(() => {
    let clickOutside = (e) => {
      detailsRef.current && e.target && !detailsRef.current.contains(e.target) && setOpen(!1);
    };
    return window.addEventListener("click", clickOutside), () => {
      window.addEventListener("click", clickOutside);
    };
  }, []), /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(
    "div",
    {
      className: "relative select-none text-gray-500",
      ref: detailsRef,
      children: [
        typeof summary == "string" ? /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(
          "button",
          {
            className: "h-full btn-sm bg-white border-none shadow-sm flex items-center gap-2  cursor-pointer",
            onClick: (e) => {
              setOpen((o) => !o);
            },
            children: [
              icon,
              summary,
              hasDownArrow && /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(
                "span",
                {
                  className: `material-symbols-rounded transition-transform ${open ? "-rotate-180" : ""}`,
                  children: "expand_more"
                },
                void 0,
                !1,
                {
                  fileName: "app/components/drop-down-menu.tsx",
                  lineNumber: 51,
                  columnNumber: 13
                },
                this
              )
            ]
          },
          void 0,
          !0,
          {
            fileName: "app/components/drop-down-menu.tsx",
            lineNumber: 42,
            columnNumber: 9
          },
          this
        ) : /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)("div", { onClick: () => setOpen((prev) => !prev), children: summary }, void 0, !1, {
          fileName: "app/components/drop-down-menu.tsx",
          lineNumber: 61,
          columnNumber: 9
        }, this),
        open && /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)(
          "div",
          {
            className: `
          absolute z-10 
          flex flex-col 
           border-gray-200 rounded-lg 
          mt-1 px-2 py-2 
          bg-white shadow-xl
          ${direction === "left" ? "" : "right-0"}
				`,
            children: details
          },
          void 0,
          !1,
          {
            fileName: "app/components/drop-down-menu.tsx",
            lineNumber: 64,
            columnNumber: 9
          },
          this
        )
      ]
    },
    void 0,
    !0,
    {
      fileName: "app/components/drop-down-menu.tsx",
      lineNumber: 36,
      columnNumber: 5
    },
    this
  );
}

// app/components/layout/toolbar.tsx
var import_jsx_dev_runtime17 = require("react/jsx-dev-runtime"), Toolbar = () => {
  let { setClose, close, hidden } = (0, import_react20.useContext)(SiderContext), navigate = (0, import_react19.useNavigate)();
  return hidden ? null : /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)(
    "header",
    {
      className: `fixed z-10 w-screen min-h-[64px] flex items-center bg-inherit ${close ? "" : "pl-[255px]"}`,
      children: /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)("div", { className: "flex items-center layout-px w-full", children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)(
          "button",
          {
            className: "icon-btn-sm icon-btn-ui -ml-2",
            onClick: () => {
              setClose((prev) => !prev);
            },
            children: /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)(
              "span",
              {
                className: "material-symbols-rounded leading-none ",
                style: { fontVariationSettings: '"wght" 300 ' },
                children: "menu"
              },
              void 0,
              !1,
              {
                fileName: "app/components/layout/toolbar.tsx",
                lineNumber: 27,
                columnNumber: 11
              },
              this
            )
          },
          void 0,
          !1,
          {
            fileName: "app/components/layout/toolbar.tsx",
            lineNumber: 21,
            columnNumber: 9
          },
          this
        ),
        /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)("div", { className: "flex-1" }, void 0, !1, {
          fileName: "app/components/layout/toolbar.tsx",
          lineNumber: 34,
          columnNumber: 9
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)(import_react19.Link, { to: "/upload/details", className: "btn-sm btn-secondary mr-4", children: "Uplode Recipe" }, void 0, !1, {
          fileName: "app/components/layout/toolbar.tsx",
          lineNumber: 35,
          columnNumber: 9
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)(AuthCheck, { children: (user) => /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)(
          "button",
          {
            className: "icon-btn-sm icon-btn-ui",
            onClick: () => {
              user && navigate("?basket-panel=true");
            },
            children: /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)(
              "span",
              {
                className: "material-symbols-rounded leading-none ",
                style: { fontVariationSettings: "'wght' 300" },
                children: "shopping_basket"
              },
              void 0,
              !1,
              {
                fileName: "app/components/layout/toolbar.tsx",
                lineNumber: 46,
                columnNumber: 15
              },
              this
            )
          },
          void 0,
          !1,
          {
            fileName: "app/components/layout/toolbar.tsx",
            lineNumber: 40,
            columnNumber: 13
          },
          this
        ) }, void 0, !1, {
          fileName: "app/components/layout/toolbar.tsx",
          lineNumber: 38,
          columnNumber: 9
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)("div", { className: "w-[1px] h-[25px] mx-2 bg-gray-300" }, void 0, !1, {
          fileName: "app/components/layout/toolbar.tsx",
          lineNumber: 55,
          columnNumber: 9
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)(AuthCheck, { loginConfirmModal: !1, children: (user) => user !== null && user.id !== null && user.email ? /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)(import_jsx_dev_runtime17.Fragment, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)(
          DropdownMenu,
          {
            summary: /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)("button", { className: "icon-btn-sm icon-btn-ui", children: [
              /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)(
                "span",
                {
                  className: "material-symbols-rounded leading-none ",
                  style: { fontVariationSettings: "'wght' 300" },
                  children: "account_circle"
                },
                void 0,
                !1,
                {
                  fileName: "app/components/layout/toolbar.tsx",
                  lineNumber: 63,
                  columnNumber: 23
                },
                this
              ),
              /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)("span", { children: user.email.split("@")[0] }, void 0, !1, {
                fileName: "app/components/layout/toolbar.tsx",
                lineNumber: 69,
                columnNumber: 23
              }, this)
            ] }, void 0, !0, {
              fileName: "app/components/layout/toolbar.tsx",
              lineNumber: 62,
              columnNumber: 21
            }, this),
            details: /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)(LogoutForm, { btnClassName: "drop-down-item" }, void 0, !1, {
              fileName: "app/components/layout/toolbar.tsx",
              lineNumber: 72,
              columnNumber: 28
            }, this)
          },
          void 0,
          !1,
          {
            fileName: "app/components/layout/toolbar.tsx",
            lineNumber: 60,
            columnNumber: 17
          },
          this
        ) }, void 0, !1, {
          fileName: "app/components/layout/toolbar.tsx",
          lineNumber: 59,
          columnNumber: 15
        }, this) : /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)(
          import_react19.Link,
          {
            to: `/login?redirectTo=${window.location.href}`,
            className: "icon-btn-sm icon-btn-ui",
            children: [
              /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)(
                "span",
                {
                  className: "material-symbols-rounded leading-none ",
                  style: { fontVariationSettings: "'wght' 300" },
                  children: "account_circle"
                },
                void 0,
                !1,
                {
                  fileName: "app/components/layout/toolbar.tsx",
                  lineNumber: 80,
                  columnNumber: 17
                },
                this
              ),
              /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)("span", { children: "Login" }, void 0, !1, {
                fileName: "app/components/layout/toolbar.tsx",
                lineNumber: 86,
                columnNumber: 17
              }, this)
            ]
          },
          void 0,
          !0,
          {
            fileName: "app/components/layout/toolbar.tsx",
            lineNumber: 76,
            columnNumber: 15
          },
          this
        ) }, void 0, !1, {
          fileName: "app/components/layout/toolbar.tsx",
          lineNumber: 56,
          columnNumber: 9
        }, this)
      ] }, void 0, !0, {
        fileName: "app/components/layout/toolbar.tsx",
        lineNumber: 20,
        columnNumber: 7
      }, this)
    },
    void 0,
    !1,
    {
      fileName: "app/components/layout/toolbar.tsx",
      lineNumber: 15,
      columnNumber: 5
    },
    this
  );
}, toolbar_default = Toolbar;

// app/components/user/user-provider.tsx
var import_jsx_dev_runtime18 = require("react/jsx-dev-runtime"), UserProvider = ({
  user,
  children
}) => {
  let { Provider: Provider3 } = UserContext;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)(Provider3, { value: user, children }, void 0, !1, {
    fileName: "app/components/user/user-provider.tsx",
    lineNumber: 18,
    columnNumber: 10
  }, this);
}, user_provider_default = UserProvider;

// app/root.tsx
var import_jsx_dev_runtime19 = require("react/jsx-dev-runtime"), metaTitlePostfix = " - Recipie", meta = () => ({
  charset: "utf-8",
  title: "Recipie",
  viewport: "width=device-width,initial-scale=1"
}), links = () => [
  {
    as: "style",
    rel: "stylesheet preload",
    href: "https://fonts.googleapis.com/icon?family=Material+Icons"
  },
  {
    as: "style",
    rel: "stylesheet preload",
    href: "https://fonts.googleapis.com/icon?family=Material+Icons+Outlined"
  },
  {
    as: "style",
    rel: "stylesheet preload",
    href: "https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200"
  },
  {
    as: "style",
    rel: "stylesheet preload",
    href: "https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200"
  },
  {
    as: "style",
    rel: "stylesheet preload",
    href: "https://fonts.googleapis.com/icon?family=Material+Icons+Round"
  },
  {
    as: "style",
    rel: "stylesheet preload",
    href: "https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&display=swap"
  },
  {
    as: "style",
    rel: "stylesheet preload",
    href: "https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
  },
  { as: "style", rel: "stylesheet preload", href: app_default }
], loader = async ({ request }) => {
  let userId = await getUserId(request);
  if (!userId)
    return (0, import_node4.json)({ userId: null, basket: null, email: null });
  let email = await db.user.findFirst({
    where: { id: userId },
    select: { email: !0 }
  }), basket = await db.basket.findFirst({
    where: { userId },
    select: { recipes: { select: { id: !0, title: !0 } } }
  });
  return (0, import_node4.json)({ basket, userId, email: email == null ? void 0 : email.email });
}, action = async (props) => await deleteRecipe(props);
function App() {
  var _a;
  let data = (0, import_react21.useLoaderData)(), [searchParams] = (0, import_react21.useSearchParams)(), navigate = (0, import_react21.useNavigate)(), location = (0, import_react21.useLocation)();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)("html", { lang: "en", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)("head", { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)(import_react21.Meta, {}, void 0, !1, {
        fileName: "app/root.tsx",
        lineNumber: 127,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)(import_react21.Links, {}, void 0, !1, {
        fileName: "app/root.tsx",
        lineNumber: 128,
        columnNumber: 9
      }, this)
    ] }, void 0, !0, {
      fileName: "app/root.tsx",
      lineNumber: 126,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)("body", { id: "app", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)(import_react_redux2.Provider, { store, children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)(import_react22.PersistGate, { loading: null, persistor, children: /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)(user_provider_default, { user: { id: data.userId, email: data.email }, children: /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)(Layout, { toolbar: /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)(toolbar_default, {}, void 0, !1, {
          fileName: "app/root.tsx",
          lineNumber: 135,
          columnNumber: 32
        }, this), children: /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)(import_react21.Outlet, {}, void 0, !1, {
          fileName: "app/root.tsx",
          lineNumber: 136,
          columnNumber: 17
        }, this) }, void 0, !1, {
          fileName: "app/root.tsx",
          lineNumber: 135,
          columnNumber: 15
        }, this) }, void 0, !1, {
          fileName: "app/root.tsx",
          lineNumber: 134,
          columnNumber: 13
        }, this) }, void 0, !1, {
          fileName: "app/root.tsx",
          lineNumber: 133,
          columnNumber: 11
        }, this),
        searchParams.get("basket-panel") ? /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)(
          BasketModal,
          {
            open: !!searchParams.get("basket-panel"),
            onClose: () => {
              navigate(`${location.pathname}`);
            },
            basketData: (_a = data.basket) == null ? void 0 : _a.recipes
          },
          void 0,
          !1,
          {
            fileName: "app/root.tsx",
            lineNumber: 141,
            columnNumber: 13
          },
          this
        ) : null,
        /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)("div", { id: "modal-container" }, void 0, !1, {
          fileName: "app/root.tsx",
          lineNumber: 149,
          columnNumber: 11
        }, this)
      ] }, void 0, !0, {
        fileName: "app/root.tsx",
        lineNumber: 132,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)(import_react21.ScrollRestoration, {}, void 0, !1, {
        fileName: "app/root.tsx",
        lineNumber: 151,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)(import_react21.Scripts, {}, void 0, !1, {
        fileName: "app/root.tsx",
        lineNumber: 152,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)(import_react21.LiveReload, {}, void 0, !1, {
        fileName: "app/root.tsx",
        lineNumber: 153,
        columnNumber: 9
      }, this)
    ] }, void 0, !0, {
      fileName: "app/root.tsx",
      lineNumber: 131,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/root.tsx",
    lineNumber: 125,
    columnNumber: 5
  }, this);
}
var ErrorBoundary = ({ error }) => {
  let navigate = (0, import_react21.useNavigate)();
  return error ? /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)("div", { children: [
    "Oops! Something went wrong!",
    /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)(
      "button",
      {
        onClick: () => {
          navigate(-1);
        },
        children: "Go back"
      },
      void 0,
      !1,
      {
        fileName: "app/root.tsx",
        lineNumber: 166,
        columnNumber: 9
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)(import_react21.Link, { to: "/", children: "Home page" }, void 0, !1, {
      fileName: "app/root.tsx",
      lineNumber: 173,
      columnNumber: 9
    }, this)
  ] }, void 0, !0, {
    fileName: "app/root.tsx",
    lineNumber: 164,
    columnNumber: 7
  }, this) : null;
};

// app/routes/basket-panel/basket-panel.tsx
var basket_panel_exports = {};
__export(basket_panel_exports, {
  action: () => action2,
  loader: () => loader2
});
var import_node5 = require("@remix-run/node");
var loader2 = async () => {
  let recipes = await db.basket.findFirst({
    where: { userId: "testuser0" },
    select: { recipes: { select: { id: !0, title: !0 } } }
  });
  return (0, import_node5.json)(recipes);
}, action2 = async ({ request, params }) => (console.log(request, params), null);

// app/routes/recipe.$recipeId.modal.tsx
var recipe_recipeId_modal_exports = {};
__export(recipe_recipeId_modal_exports, {
  default: () => RecipeModal,
  loader: () => loader3
});
var import_node6 = require("@remix-run/node"), import_react23 = require("@remix-run/react"), import_react24 = require("react"), import_react25 = require("react");
var import_jsx_dev_runtime20 = require("react/jsx-dev-runtime"), mockData = [
  {
    id: "1",
    title: "Preparation",
    steps: [
      {
        id: "1",
        timeStemp: null,
        text: "Preheated 400 degrees F (200 degrees C) oven for 5 to 8 minutes"
      },
      {
        id: "2",
        timeStemp: null,
        text: "Preheated 400 degrees F (200 degrees C) oven for 5 to 8 minutes"
      },
      {
        id: "3",
        timeStemp: null,
        text: "Preheated 400 degrees F (200 degrees C) oven for 5 to 8 minutes"
      },
      {
        id: "4",
        timeStemp: null,
        text: "Preheated 400 degrees F (200 degrees C) oven for 5 to 8 minutes"
      }
    ]
  },
  {
    id: "2",
    title: "Preparation",
    steps: [
      {
        id: "1",
        timeStemp: null,
        text: "Preheated 400 degrees F (200 degrees C) oven for 5 to 8 minutes"
      }
    ]
  },
  {
    id: "3",
    title: "Preparation",
    steps: [
      {
        id: "1",
        timeStemp: null,
        text: "Preheated 400 degrees F (200 degrees C) oven for 5 to 8 minutes"
      }
    ]
  },
  {
    id: "4",
    title: "Preparation",
    steps: [
      {
        id: "1",
        timeStemp: null,
        text: "Preheated 400 degrees F (200 degrees C) oven for 5 to 8 minutes"
      }
    ]
  },
  {
    id: "5",
    title: "Preparation",
    steps: [
      {
        id: "1",
        timeStemp: null,
        text: "Preheated 400 degrees F (200 degrees C) oven for 5 to 8 minutes"
      }
    ]
  }
], loader3 = async ({ request, params, context }) => {
  let step = ((step2) => step2 > 0 ? step2 - 1 : 0)(Number(new URL(request.url).searchParams.get("step")));
  return (0, import_node6.json)([mockData[step], mockData[step + 1]]);
}, ModalContainer = ({
  children,
  onPrevious,
  onNext,
  showNext,
  showPrevious
}) => {
  let { recipeId } = (0, import_react23.useParams)();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)(
    "div",
    {
      className: "h-screen bg-gray-100 overflow-auto [scroll-snap-type:y_mandatory]",
      children: [
        children,
        /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)(
          "button",
          {
            onClick: onPrevious,
            className: `
        fixed 
        w-24 
        btn-ghost btn-sm 
        top-2 left-[calc(50vw_-_48px)] 
        flex-col 
        bg-gray-200/70 backdrop-blur-md 
        text-gray-500 
        select-none
        hover:animate-bounce-y-down
        ${showPrevious ? "" : "pointer-events-none invisible"}`,
            children: [
              /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("span", { className: "material-symbols-rounded block", children: "arrow_upward" }, void 0, !1, {
                fileName: "app/routes/recipe.$recipeId.modal.tsx",
                lineNumber: 139,
                columnNumber: 9
              }, this),
              "Previous"
            ]
          },
          void 0,
          !0,
          {
            fileName: "app/routes/recipe.$recipeId.modal.tsx",
            lineNumber: 125,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)(
          "button",
          {
            onClick: onNext,
            id: "next_btn",
            className: `
        fixed 
        w-24 
        btn-ghost btn-md 
        flex-col 
        bottom-2 left-[calc(50vw_-_48px)]
        bg-gray-200/70 backdrop-blur-md 
        text-black
        select-none 
        hover:animate-bounce-y-up
        ${showNext ? "" : "pointer-events-none invisible"}`,
            children: [
              "Next",
              /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("span", { className: "material-symbols-rounded block", children: "arrow_downward" }, void 0, !1, {
                fileName: "app/routes/recipe.$recipeId.modal.tsx",
                lineNumber: 158,
                columnNumber: 9
              }, this)
            ]
          },
          void 0,
          !0,
          {
            fileName: "app/routes/recipe.$recipeId.modal.tsx",
            lineNumber: 142,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)(
          import_react23.Link,
          {
            to: `/recipe/${recipeId}`,
            className: "fixed w-fit top-0 right-[10px] btn-ghost btn-md justify-end text-gray-500 ",
            children: /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("span", { className: "material-symbols-rounded", children: "close" }, void 0, !1, {
              fileName: "app/routes/recipe.$recipeId.modal.tsx",
              lineNumber: 164,
              columnNumber: 9
            }, this)
          },
          void 0,
          !1,
          {
            fileName: "app/routes/recipe.$recipeId.modal.tsx",
            lineNumber: 160,
            columnNumber: 7
          },
          this
        )
      ]
    },
    void 0,
    !0,
    {
      fileName: "app/routes/recipe.$recipeId.modal.tsx",
      lineNumber: 120,
      columnNumber: 5
    },
    this
  );
};
function RecipeModal() {
  let { setHidden } = (0, import_react24.useContext)(SiderContext), data = (0, import_react23.useLoaderData)(), [stepData, setStepData] = (0, import_react25.useState)(data), [stepInView, setStepInView] = (0, import_react25.useState)(1), [maxStep, setMaxStep] = (0, import_react25.useState)(1 / 0), fetcher = (0, import_react23.useFetcher)(), [shouldFetch, setShouldFetch] = (0, import_react25.useState)(!0), [hasData, setHasData] = (0, import_react25.useState)(!0), [targets, setTergets] = (0, import_react25.useState)([]), [nextStep, setNextStep] = (0, import_react25.useState)(3);
  (0, import_react24.useEffect)(() => (setHidden(!0), () => {
    setHidden(!1);
  }), [setHidden]);
  let targetRef = (0, import_react24.useCallback)((node) => {
    if (node !== null) {
      let idx = node.getAttribute("data-key");
      idx && setTergets((prev) => {
        let arr = [...prev];
        return arr[+idx] = node, arr;
      });
    }
  }, []);
  return (0, import_react24.useEffect)(() => {
    let options = {
      threshold: 1
    }, onIntersect = (entries, observer2) => {
      entries.forEach((entry2) => {
        if (entry2.isIntersecting) {
          let key = entry2.target.getAttribute("data-key");
          key && +key === targets.length - 2 && +key % 2 === 0 && +key !== maxStep - 1 && maxStep === 1 / 0 && (console.log("fetch", nextStep), setShouldFetch(!0), setNextStep(parseInt(key) + 3)), key && setStepInView(parseInt(key) + 1);
        }
      });
    }, observer = new IntersectionObserver(onIntersect, options);
    return targets.length > 0 && targets.forEach((target) => {
      observer.observe(target);
    }), () => {
      observer.disconnect();
    };
  }, [maxStep, targets, targets.length]), (0, import_react24.useEffect)(() => {
    !shouldFetch || !hasData || (fetcher.load(`/recipe/modal?step=${nextStep}`), setShouldFetch(!1));
  }, [fetcher, hasData, nextStep, shouldFetch]), (0, import_react24.useEffect)(() => {
    if (fetcher.data && fetcher.data[0] === null) {
      setHasData(!1), setShouldFetch(!1);
      return;
    }
    if (fetcher.data && fetcher.data[1] === null) {
      setStepData((prev) => [...prev, fetcher.data[0]]), setHasData(!1), setShouldFetch(!1);
      return;
    }
    fetcher.data && setStepData((prev) => [...prev, ...fetcher.data]);
  }, [fetcher.data]), (0, import_react24.useEffect)(() => {
    hasData || setMaxStep(targets.length);
  }, [hasData, targets.length]), /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)(
    ModalContainer,
    {
      showNext: stepInView !== maxStep,
      showPrevious: stepInView !== 1,
      onPrevious: () => {
        targets[stepInView - 2].scrollIntoView({
          block: "center",
          behavior: "smooth"
        }), setStepInView((prev) => prev - 1);
      },
      onNext: () => {
        targets[stepInView].scrollIntoView({
          block: "center",
          behavior: "smooth"
        }), setStepInView((prev) => prev + 1);
      },
      children: stepData == null ? void 0 : stepData.map(({ id, title, steps }, idx) => /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)(
        "div",
        {
          "data-key": idx,
          className: "max-w-7xl h-screen flex justify-center mx-auto space-x-6 scroll-m-0 py-20 px-8 [scroll-snap-align:center] ",
          ref: targetRef,
          children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("div", { className: "w-full  flex items-center", children: /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)(
              "div",
              {
                className: "flex-1 w-full h-full max-h-[70vh] p-5 rounded-2xl bg-white shadow-2xl ",
                children: /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)(
                  "img",
                  {
                    src: img1_default,
                    alt: "step-img",
                    className: "w-full h-full object-cover object-center rounded-2xl"
                  },
                  void 0,
                  !1,
                  {
                    fileName: "app/routes/recipe.$recipeId.modal.tsx",
                    lineNumber: 321,
                    columnNumber: 17
                  },
                  this
                )
              },
              void 0,
              !1,
              {
                fileName: "app/routes/recipe.$recipeId.modal.tsx",
                lineNumber: 317,
                columnNumber: 15
              },
              this
            ) }, void 0, !1, {
              fileName: "app/routes/recipe.$recipeId.modal.tsx",
              lineNumber: 316,
              columnNumber: 13
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("div", { className: " w-2/5 flex-shrink-0 flex flex-col", children: /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("div", { className: "overflow-y-auto flex-1", children: [
              /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("div", { className: "mt-2 mb-14 text-center", children: [
                /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("h4", { className: "text-primary-400 font-medium", children: [
                  "STEP ",
                  id
                ] }, void 0, !0, {
                  fileName: "app/routes/recipe.$recipeId.modal.tsx",
                  lineNumber: 331,
                  columnNumber: 19
                }, this),
                /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("h2", { className: "text-black", children: title }, void 0, !1, {
                  fileName: "app/routes/recipe.$recipeId.modal.tsx",
                  lineNumber: 332,
                  columnNumber: 19
                }, this)
              ] }, void 0, !0, {
                fileName: "app/routes/recipe.$recipeId.modal.tsx",
                lineNumber: 330,
                columnNumber: 17
              }, this),
              /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("ul", { className: " pl-14 pr-14 list-disc text-black marker:text-gray-300 marker:text-xl marker:leading-none", children: steps.map(({ text, id: id2 }) => /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("li", { className: "mb-8", children: /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("span", { className: "relative left-1 ", children: text }, void 0, !1, {
                fileName: "app/routes/recipe.$recipeId.modal.tsx",
                lineNumber: 337,
                columnNumber: 23
              }, this) }, id2, !1, {
                fileName: "app/routes/recipe.$recipeId.modal.tsx",
                lineNumber: 336,
                columnNumber: 21
              }, this)) }, void 0, !1, {
                fileName: "app/routes/recipe.$recipeId.modal.tsx",
                lineNumber: 334,
                columnNumber: 17
              }, this)
            ] }, void 0, !0, {
              fileName: "app/routes/recipe.$recipeId.modal.tsx",
              lineNumber: 329,
              columnNumber: 15
            }, this) }, void 0, !1, {
              fileName: "app/routes/recipe.$recipeId.modal.tsx",
              lineNumber: 328,
              columnNumber: 13
            }, this)
          ]
        },
        id,
        !0,
        {
          fileName: "app/routes/recipe.$recipeId.modal.tsx",
          lineNumber: 310,
          columnNumber: 11
        },
        this
      ))
    },
    void 0,
    !1,
    {
      fileName: "app/routes/recipe.$recipeId.modal.tsx",
      lineNumber: 290,
      columnNumber: 5
    },
    this
  );
}

// app/routes/recipe.like.$recipeId.ts
var recipe_like_recipeId_exports = {};
__export(recipe_like_recipeId_exports, {
  action: () => action3
});

// app/utils/request.server.ts
var import_node7 = require("@remix-run/node"), badRequest = (data) => (0, import_node7.json)(data, { status: 400 });

// app/routes/recipe.like.$recipeId.ts
async function requireFav(userId) {
  await db.favorite.findFirst({
    where: { userId },
    select: { id: !0 }
  }) || await db.favorite.create({
    data: { userId }
  });
}
var action3 = async ({ request, params }) => {
  let userId = await requireUserId(request), recipeId = params.recipeId;
  return !recipeId || typeof recipeId != "string" ? badRequest({ formError: "Recipe not exsit!" }) : (await requireFav(userId), await db.favorite.findFirst({
    where: { recipes: { some: { id: recipeId } }, userId },
    select: { id: !0 }
  }) ? await db.favorite.update({
    where: { userId },
    data: { recipes: { disconnect: { id: recipeId } } }
  }) : await db.favorite.update({
    where: { userId },
    data: { recipes: { connect: { id: recipeId } } }
  }), null);
};

// app/routes/add-basket.$recipeId.ts
var add_basket_recipeId_exports = {};
__export(add_basket_recipeId_exports, {
  action: () => action4
});
async function userBasket(userId) {
  return !!await db.basket.findFirst({
    where: { userId },
    select: { id: !0 }
  });
}
async function updateBasket({
  recipeId,
  userId
}) {
  return await userBasket(userId) || await db.basket.create({
    data: { userId }
  }), await db.basket.findFirst({
    where: {
      userId,
      recipes: { some: { id: recipeId } }
    }
  }) ? await db.basket.update({
    where: { userId },
    data: { recipes: { disconnect: { id: recipeId } } }
  }) : await db.basket.update({
    where: { userId },
    data: { recipes: { connect: { id: recipeId } } }
  }), null;
}
var action4 = async ({ request, params }) => {
  let userId = await requireUserId(request), recipeId = params.recipeId;
  if (!recipeId)
    throw new Error("Recipe no exist!");
  return await updateBasket({ recipeId, userId }), null;
};

// app/routes/recipe.$recipeId.tsx
var recipe_recipeId_exports = {};
__export(recipe_recipeId_exports, {
  default: () => RecipeIndex,
  loader: () => loader4
});

// app/components/recipe/recipe-header.tsx
var import_react29 = require("@remix-run/react"), import_moment = __toESM(require("moment"));

// app/components/difficulty.tsx
var import_client2 = require("@prisma/client"), import_react26 = require("react"), import_jsx_dev_runtime21 = require("react/jsx-dev-runtime"), getDifficulty = (difficulty) => {
  switch (difficulty) {
    case import_client2.Difficulty.DIFFICULT5:
      return 5;
    case import_client2.Difficulty.DIFFICULT4:
      return 4;
    case import_client2.Difficulty.MODERATE3:
      return 3;
    case import_client2.Difficulty.EASY2:
      return 2;
    case import_client2.Difficulty.EASY1:
      return 1;
    default:
      return 1;
  }
};
function DifficultyBtn({
  difficulty,
  isInput
}) {
  let [starValue, setStarValue] = (0, import_react26.useState)(getDifficulty(difficulty)), [clicked, setClicked] = (0, import_react26.useState)(0);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime21.jsxDEV)(import_jsx_dev_runtime21.Fragment, { children: [
    Array(5).fill("").map((_, idx) => /* @__PURE__ */ (0, import_jsx_dev_runtime21.jsxDEV)(
      "span",
      {
        className: `material-symbols-rounded leading-none text-primary ${isInput ? "cursor-pointer" : ""}`,
        style: starValue > idx ? { fontVariationSettings: '"FILL" 1' } : void 0,
        onMouseEnter: () => {
          isInput && setStarValue(idx + 1);
        },
        onMouseLeave: () => {
          isInput && !clicked ? setStarValue(1) : isInput && clicked && setStarValue(clicked);
        },
        onClick: () => {
          setClicked(idx + 1);
        },
        children: "star"
      },
      idx,
      !1,
      {
        fileName: "app/components/difficulty.tsx",
        lineNumber: 35,
        columnNumber: 11
      },
      this
    )),
    /* @__PURE__ */ (0, import_jsx_dev_runtime21.jsxDEV)("span", { className: ` ${isInput ? "text-black" : "text-gray-500"}`, children: starValue.toFixed(1) }, void 0, !1, {
      fileName: "app/components/difficulty.tsx",
      lineNumber: 65,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/difficulty.tsx",
    lineNumber: 31,
    columnNumber: 5
  }, this);
}

// app/components/tag.tsx
var import_react27 = require("@remix-run/react"), import_jsx_dev_runtime22 = require("react/jsx-dev-runtime");
function Tag({ text }) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(
    import_react27.Link,
    {
      className: "py-1.5 px-3 bg-gray-200 text-sm text-black font-bold rounded-full",
      to: "#",
      children: text
    },
    void 0,
    !1,
    {
      fileName: "app/components/tag.tsx",
      lineNumber: 5,
      columnNumber: 5
    },
    this
  );
}

// app/components/recipe/header-img.tsx
var import_react28 = require("react"), import_jsx_dev_runtime23 = require("react/jsx-dev-runtime");
function HeaderImg({ src }) {
  let ref = (0, import_react28.useRef)(null);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime23.jsxDEV)("div", { className: " flex-1 relative ", children: /* @__PURE__ */ (0, import_jsx_dev_runtime23.jsxDEV)("div", { className: " overflow-hidden aspect-w-4 aspect-h-3 rounded-2xl bg-white shadow-gray-300/50", children: /* @__PURE__ */ (0, import_jsx_dev_runtime23.jsxDEV)("div", { className: "w-full h-full ", ref, children: /* @__PURE__ */ (0, import_jsx_dev_runtime23.jsxDEV)(
    "img",
    {
      src,
      alt: "recipe-header-img",
      className: "w-full h-full object-cover object-center rounded-xl"
    },
    void 0,
    !1,
    {
      fileName: "app/components/recipe/header-img.tsx",
      lineNumber: 26,
      columnNumber: 11
    },
    this
  ) }, void 0, !1, {
    fileName: "app/components/recipe/header-img.tsx",
    lineNumber: 25,
    columnNumber: 9
  }, this) }, void 0, !1, {
    fileName: "app/components/recipe/header-img.tsx",
    lineNumber: 24,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "app/components/recipe/header-img.tsx",
    lineNumber: 23,
    columnNumber: 5
  }, this);
}

// app/components/card/content-card.tsx
var import_jsx_dev_runtime24 = require("react/jsx-dev-runtime");
function ContentCard({
  className,
  children
}) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(
    "div",
    {
      className: `w-full h-full border border-gray-50 bg-white px-9 py-8 rounded-3xl shadow-2xl shadow-gray-300/50 ${className}`,
      children
    },
    void 0,
    !1,
    {
      fileName: "app/components/card/content-card.tsx",
      lineNumber: 11,
      columnNumber: 5
    },
    this
  );
}

// app/components/recipe/recipe-header.tsx
var import_jsx_dev_runtime25 = require("react/jsx-dev-runtime"), date = new Date(2022, 8, 6);
function RecipeHeader({
  title,
  authorName,
  createdAt,
  difficulty
}) {
  let { recipeId } = (0, import_react29.useParams)();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("div", { className: "flex flex-col space-y-10", children: /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)(ContentCard, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("div", { className: "flex space-x-10", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)(HeaderImg, { src: img1_default }, void 0, !1, {
        fileName: "app/components/recipe/recipe-header.tsx",
        lineNumber: 30,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("div", { className: "flex-1 flex flex-col space-y-8", children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("h1", { className: " text-black", children: title }, void 0, !1, {
          fileName: "app/components/recipe/recipe-header.tsx",
          lineNumber: 32,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("div", { children: /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("div", { className: "flex items-center gap-2 text-gray-500", children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("span", { className: "inline-flex items-center gap-2", children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("span", { className: "material-icons-round leading-none text-gray-500", children: "person" }, void 0, !1, {
              fileName: "app/components/recipe/recipe-header.tsx",
              lineNumber: 36,
              columnNumber: 19
            }, this),
            authorName
          ] }, void 0, !0, {
            fileName: "app/components/recipe/recipe-header.tsx",
            lineNumber: 35,
            columnNumber: 17
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("div", { className: "self-stretch w-[1px] bg-gray-200" }, void 0, !1, {
            fileName: "app/components/recipe/recipe-header.tsx",
            lineNumber: 41,
            columnNumber: 17
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("span", { children: (0, import_moment.default)(createdAt).format("LL") }, void 0, !1, {
            fileName: "app/components/recipe/recipe-header.tsx",
            lineNumber: 42,
            columnNumber: 17
          }, this)
        ] }, void 0, !0, {
          fileName: "app/components/recipe/recipe-header.tsx",
          lineNumber: 34,
          columnNumber: 15
        }, this) }, void 0, !1, {
          fileName: "app/components/recipe/recipe-header.tsx",
          lineNumber: 33,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("div", { className: "flex-1", children: /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("div", { className: "flex gap-3", children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)(Tag, { text: "tag" }, void 0, !1, {
            fileName: "app/components/recipe/recipe-header.tsx",
            lineNumber: 47,
            columnNumber: 17
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)(Tag, { text: "tag" }, void 0, !1, {
            fileName: "app/components/recipe/recipe-header.tsx",
            lineNumber: 48,
            columnNumber: 17
          }, this)
        ] }, void 0, !0, {
          fileName: "app/components/recipe/recipe-header.tsx",
          lineNumber: 46,
          columnNumber: 15
        }, this) }, void 0, !1, {
          fileName: "app/components/recipe/recipe-header.tsx",
          lineNumber: 45,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("div", { className: "flex justify-center", children: /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)(
          import_react29.Link,
          {
            className: "btn-primary btn-md w-full h-fit text-lg cursor-pointer",
            to: `/recipe/${recipeId}/modal`,
            children: "Start Cooking"
          },
          void 0,
          !1,
          {
            fileName: "app/components/recipe/recipe-header.tsx",
            lineNumber: 52,
            columnNumber: 15
          },
          this
        ) }, void 0, !1, {
          fileName: "app/components/recipe/recipe-header.tsx",
          lineNumber: 51,
          columnNumber: 13
        }, this)
      ] }, void 0, !0, {
        fileName: "app/components/recipe/recipe-header.tsx",
        lineNumber: 31,
        columnNumber: 11
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/recipe/recipe-header.tsx",
      lineNumber: 29,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("div", { className: "flex items-center justify-around mt-10 text-gray-600", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("div", { className: "flex items-center text-gray-500", children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("span", { children: "Difficulty:" }, void 0, !1, {
          fileName: "app/components/recipe/recipe-header.tsx",
          lineNumber: 63,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)(DifficultyBtn, { difficulty }, void 0, !1, {
          fileName: "app/components/recipe/recipe-header.tsx",
          lineNumber: 64,
          columnNumber: 13
        }, this)
      ] }, void 0, !0, {
        fileName: "app/components/recipe/recipe-header.tsx",
        lineNumber: 62,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("div", { className: "w-[1px] bg-gray-200 h-[35px]" }, void 0, !1, {
        fileName: "app/components/recipe/recipe-header.tsx",
        lineNumber: 66,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("button", { className: "icon-btn-sm bg-red-400 rounded-full text-white", children: /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("span", { className: "material-symbols-rounded leading-none ", children: "favorite" }, void 0, !1, {
          fileName: "app/components/recipe/recipe-header.tsx",
          lineNumber: 69,
          columnNumber: 15
        }, this) }, void 0, !1, {
          fileName: "app/components/recipe/recipe-header.tsx",
          lineNumber: 68,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("span", { className: "", children: "320" }, void 0, !1, {
          fileName: "app/components/recipe/recipe-header.tsx",
          lineNumber: 73,
          columnNumber: 13
        }, this)
      ] }, void 0, !0, {
        fileName: "app/components/recipe/recipe-header.tsx",
        lineNumber: 67,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("div", { className: "w-[1px] bg-gray-200 h-[35px]" }, void 0, !1, {
        fileName: "app/components/recipe/recipe-header.tsx",
        lineNumber: 75,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("span", { className: "material-symbols-rounded leading-none", children: "shopping_basket" }, void 0, !1, {
          fileName: "app/components/recipe/recipe-header.tsx",
          lineNumber: 77,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("span", { className: "", children: "1,452" }, void 0, !1, {
          fileName: "app/components/recipe/recipe-header.tsx",
          lineNumber: 80,
          columnNumber: 13
        }, this)
      ] }, void 0, !0, {
        fileName: "app/components/recipe/recipe-header.tsx",
        lineNumber: 76,
        columnNumber: 11
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/recipe/recipe-header.tsx",
      lineNumber: 61,
      columnNumber: 9
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/recipe/recipe-header.tsx",
    lineNumber: 28,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "app/components/recipe/recipe-header.tsx",
    lineNumber: 27,
    columnNumber: 5
  }, this);
}

// app/components/recipe/recipe-ingredients/recipe-ingredients-table.tsx
var import_jsx_dev_runtime26 = require("react/jsx-dev-runtime");
function RecipeIngredientsTable({
  data
}) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime26.jsxDEV)("div", { className: "table mb-8", children: /* @__PURE__ */ (0, import_jsx_dev_runtime26.jsxDEV)("div", { className: "table-row-group", children: data.map(({ ingredient, ingredientId, unit, value }) => /* @__PURE__ */ (0, import_jsx_dev_runtime26.jsxDEV)("div", { className: "table-row", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime26.jsxDEV)("div", { className: "table-cell py-3 w-full", children: /* @__PURE__ */ (0, import_jsx_dev_runtime26.jsxDEV)("div", { className: "flex items-center", children: [
      ingredient.name,
      /* @__PURE__ */ (0, import_jsx_dev_runtime26.jsxDEV)("span", { className: "flex-1 h-0 mx-3 border-b-2 border-gray-300 border-dotted" }, void 0, !1, {
        fileName: "app/components/recipe/recipe-ingredients/recipe-ingredients-table.tsx",
        lineNumber: 21,
        columnNumber: 17
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/recipe/recipe-ingredients/recipe-ingredients-table.tsx",
      lineNumber: 19,
      columnNumber: 15
    }, this) }, void 0, !1, {
      fileName: "app/components/recipe/recipe-ingredients/recipe-ingredients-table.tsx",
      lineNumber: 18,
      columnNumber: 13
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime26.jsxDEV)("div", { className: "table-cell py-3 font-semibold text-secondary", children: [
      value,
      unit
    ] }, void 0, !0, {
      fileName: "app/components/recipe/recipe-ingredients/recipe-ingredients-table.tsx",
      lineNumber: 24,
      columnNumber: 13
    }, this)
  ] }, ingredientId, !0, {
    fileName: "app/components/recipe/recipe-ingredients/recipe-ingredients-table.tsx",
    lineNumber: 17,
    columnNumber: 11
  }, this)) }, void 0, !1, {
    fileName: "app/components/recipe/recipe-ingredients/recipe-ingredients-table.tsx",
    lineNumber: 15,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "app/components/recipe/recipe-ingredients/recipe-ingredients-table.tsx",
    lineNumber: 14,
    columnNumber: 5
  }, this);
}

// app/components/recipe/recipe-ingredients/serving-form.tsx
var import_react30 = require("@remix-run/react"), import_react31 = require("react"), import_react_hook_form3 = require("react-hook-form");
var import_jsx_dev_runtime27 = require("react/jsx-dev-runtime");
function ServingForm({
  onSubmit
}) {
  let { recipeId } = (0, import_react30.useParams)(), recipe = useAppSelector((state) => state.recipeServings).find((recipe2) => recipe2.recipeId === recipeId), {
    register: register2,
    handleSubmit,
    setValue,
    watch,
    reset,
    formState: { isSubmitSuccessful, isDirty }
  } = (0, import_react_hook_form3.useForm)({
    defaultValues: recipe ? { input: recipe.servings } : { input: 1 }
  }), watchValue = watch("input"), servingInputRef = (0, import_react31.useRef)(null), inputRef = (0, import_react31.useCallback)(
    (node) => {
      node !== null && (servingInputRef.current = node, register2("input").ref(node));
    },
    [register2]
  );
  return /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)(
    "form",
    {
      onSubmit: handleSubmit((e) => {
        onSubmit(e), reset(
          {
            input: e.input
          },
          { keepDirty: !1 }
        );
      }),
      children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)("div", { className: "flex items-center justify-center gap-2 text-center mb-6 py-9 text-xl font-bold", children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)("span", { className: "", children: "I need " }, void 0, !1, {
            fileName: "app/components/recipe/recipe-ingredients/serving-form.tsx",
            lineNumber: 55,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)("div", { className: "relative inline-block min-w-[60px] max-w-[80px] h-9  text-3xl  ", children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)(
              "button",
              {
                className: `
                    absolute 
                    bottom-full left-1/2 -translate-x-1/2 
                    flex 
                    mb-1 p-1 
                    border border-gray-200 rounded-full`,
                type: "button",
                onClick: () => {
                  servingInputRef.current && (servingInputRef.current.stepUp(), setValue("input", watchValue + 1, { shouldDirty: !0 }));
                },
                children: /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)("span", { className: "material-symbols-rounded text-lg leading-none text-gray-500", children: "keyboard_arrow_up" }, void 0, !1, {
                  fileName: "app/components/recipe/recipe-ingredients/serving-form.tsx",
                  lineNumber: 72,
                  columnNumber: 13
                }, this)
              },
              void 0,
              !1,
              {
                fileName: "app/components/recipe/recipe-ingredients/serving-form.tsx",
                lineNumber: 57,
                columnNumber: 11
              },
              this
            ),
            /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)(
              "span",
              {
                className: "whitespace-pre inline-block max-w-[80px] overflow-hidden",
                children: watchValue
              },
              void 0,
              !1,
              {
                fileName: "app/components/recipe/recipe-ingredients/serving-form.tsx",
                lineNumber: 76,
                columnNumber: 11
              },
              this
            ),
            /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)(
              "input",
              {
                ...register2("input"),
                type: "number",
                className: "absolute w-full top-0 left-0 text-center align-top outline-focus-outline",
                onWheel: (e) => {
                  e.target.blur();
                },
                onKeyDown: (e) => {
                  (e.target.value.length === 0 && ["0"].includes(e.key) || [".", "e"].includes(e.key)) && e.preventDefault();
                },
                ref: inputRef
              },
              void 0,
              !1,
              {
                fileName: "app/components/recipe/recipe-ingredients/serving-form.tsx",
                lineNumber: 82,
                columnNumber: 11
              },
              this
            ),
            /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)(
              "button",
              {
                className: `
                    absolute 
                    top-full left-1/2 -translate-x-1/2 
                    flex 
                    mt-1 p-1 
                    border border-gray-200 rounded-full
                    ${watchValue === 1 ? "text-gray-300 " : "text-gray-500"}
                    `,
                type: "button",
                onClick: (e) => {
                  servingInputRef.current && (servingInputRef.current.stepDown(), setValue("input", watchValue - 1, { shouldDirty: !0 }));
                },
                disabled: watchValue === 1,
                children: /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)("span", { className: "material-symbols-rounded text-lg leading-none  ", children: "keyboard_arrow_down" }, void 0, !1, {
                  fileName: "app/components/recipe/recipe-ingredients/serving-form.tsx",
                  lineNumber: 130,
                  columnNumber: 13
                }, this)
              },
              void 0,
              !1,
              {
                fileName: "app/components/recipe/recipe-ingredients/serving-form.tsx",
                lineNumber: 108,
                columnNumber: 11
              },
              this
            )
          ] }, void 0, !0, {
            fileName: "app/components/recipe/recipe-ingredients/serving-form.tsx",
            lineNumber: 56,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)("span", { className: "", children: " Servings" }, void 0, !1, {
            fileName: "app/components/recipe/recipe-ingredients/serving-form.tsx",
            lineNumber: 135,
            columnNumber: 9
          }, this)
        ] }, void 0, !0, {
          fileName: "app/components/recipe/recipe-ingredients/serving-form.tsx",
          lineNumber: 54,
          columnNumber: 7
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)(AuthCheck, { children: (userId) => /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)(
          "button",
          {
            className: `btn-md w-full gap-2 ${isSubmitSuccessful && !isDirty ? "btn-successful" : "btn-secondary"}`,
            disabled: userId === null || watchValue === 0,
            type: "submit",
            children: [
              /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)("span", { className: "material-symbols-rounded text-xl leading-none", children: isSubmitSuccessful && !isDirty ? "done" : " shopping_basket " }, void 0, !1, {
                fileName: "app/components/recipe/recipe-ingredients/serving-form.tsx",
                lineNumber: 148,
                columnNumber: 13
              }, this),
              userId ? isSubmitSuccessful && !isDirty ? recipe ? "Updated basket" : "Added to basket" : recipe ? "Update basket servings" : "Add to basket" : "Login to add in basket"
            ]
          },
          void 0,
          !0,
          {
            fileName: "app/components/recipe/recipe-ingredients/serving-form.tsx",
            lineNumber: 139,
            columnNumber: 11
          },
          this
        ) }, void 0, !1, {
          fileName: "app/components/recipe/recipe-ingredients/serving-form.tsx",
          lineNumber: 137,
          columnNumber: 7
        }, this)
      ]
    },
    void 0,
    !0,
    {
      fileName: "app/components/recipe/recipe-ingredients/serving-form.tsx",
      lineNumber: 43,
      columnNumber: 5
    },
    this
  );
}

// app/components/recipe/recipe-ingredients/index.tsx
var import_jsx_dev_runtime28 = require("react/jsx-dev-runtime");
function Index({
  data
}) {
  let dispatch = useAppDispatch();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(ContentCard, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)("h3", { className: "mb-6", children: "Ingredients" }, void 0, !1, {
      fileName: "app/components/recipe/recipe-ingredients/index.tsx",
      lineNumber: 20,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(RecipeIngredientsTable, { data }, void 0, !1, {
      fileName: "app/components/recipe/recipe-ingredients/index.tsx",
      lineNumber: 21,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)("div", { className: "mb-3 border-b border-gray-200" }, void 0, !1, {
      fileName: "app/components/recipe/recipe-ingredients/index.tsx",
      lineNumber: 23,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)("p", { className: "mb-9 text-right text-sm text-gray-400", children: [
      "Original recipe yields ",
      /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)("b", { children: "1" }, void 0, !1, {
        fileName: "app/components/recipe/recipe-ingredients/index.tsx",
        lineNumber: 25,
        columnNumber: 32
      }, this),
      " servings"
    ] }, void 0, !0, {
      fileName: "app/components/recipe/recipe-ingredients/index.tsx",
      lineNumber: 24,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(
      ServingForm,
      {
        onSubmit: (v) => {
          data.forEach((item) => {
            dispatch(
              updateRecipeServings({
                recipeId: item.recipeId,
                servings: v.input
              })
            );
          });
        }
      },
      void 0,
      !1,
      {
        fileName: "app/components/recipe/recipe-ingredients/index.tsx",
        lineNumber: 27,
        columnNumber: 7
      },
      this
    )
  ] }, void 0, !0, {
    fileName: "app/components/recipe/recipe-ingredients/index.tsx",
    lineNumber: 19,
    columnNumber: 5
  }, this);
}

// app/components/recipe/recipe-nutrition/nutrition-chart/radial-chart.tsx
var import_react32 = require("react"), import_recharts = __toESM(require_lib2()), import_jsx_dev_runtime29 = require("react/jsx-dev-runtime");
function RadialChart({
  fillColorClass,
  data
}) {
  let [rpcWidth, setRpcWidth] = (0, import_react32.useState)(0), [hasRpc, setHasRpc] = (0, import_react32.useState)(!1), rpcElementRef = (0, import_react32.useRef)(null), rpcRef = (0, import_react32.useCallback)((node) => {
    node !== null && (setRpcWidth(
      node.current.getBoundingClientRect().width
    ), setHasRpc(!0), rpcElementRef.current = node.current);
  }, []);
  return (0, import_react32.useEffect)(() => {
    let resizeObserver = new ResizeObserver((entries) => {
      for (let entry2 of entries)
        if (entry2.contentBoxSize) {
          let contentBoxSize = Array.isArray(
            entry2.contentBoxSize
          ) ? entry2.contentBoxSize[0] : entry2.contentBoxSize;
          setRpcWidth(contentBoxSize.blockSize);
        }
    });
    return hasRpc && rpcElementRef.current && resizeObserver.observe(rpcElementRef.current), () => {
      resizeObserver.disconnect();
    };
  }, [hasRpc, rpcWidth]), /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(
    import_recharts.ResponsiveContainer,
    {
      width: "100%",
      aspect: 1,
      height: "auto",
      debounce: 2,
      ref: rpcRef,
      children: /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(
        import_recharts.RadialBarChart,
        {
          id: "test",
          innerRadius: "100%",
          data,
          startAngle: 90,
          endAngle: -180,
          barSize: rpcWidth / 30,
          children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(
              import_recharts.PolarAngleAxis,
              {
                type: "number",
                dataKey: "pct",
                domain: [0, 100],
                tick: !1,
                axisLine: !1
              },
              void 0,
              !1,
              {
                fileName: "app/components/recipe/recipe-nutrition/nutrition-chart/radial-chart.tsx",
                lineNumber: 75,
                columnNumber: 9
              },
              this
            ),
            /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(
              import_recharts.RadialBar,
              {
                id: "radialBar",
                className: fillColorClass,
                background: !0,
                dataKey: "pct",
                cornerRadius: rpcWidth / 15,
                children: [
                  /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(
                    import_recharts.LabelList,
                    {
                      className: "font-ui font-bold ",
                      formatter: (v) => v + "%",
                      position: "center",
                      style: {
                        fontSize: rpcWidth ? rpcWidth / 100 + "rem" : "1.875rem",
                        transform: rpcWidth ? `translateY(-${rpcWidth * 0.08}px)` : "translateY(-16px)"
                      }
                    },
                    void 0,
                    !1,
                    {
                      fileName: "app/components/recipe/recipe-nutrition/nutrition-chart/radial-chart.tsx",
                      lineNumber: 91,
                      columnNumber: 11
                    },
                    this
                  ),
                  /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(
                    import_recharts.LabelList,
                    {
                      className: "font-bold fill-black ",
                      dataKey: "name",
                      position: "centerTop",
                      style: {
                        fontSize: rpcWidth ? rpcWidth / 210 + "rem" : "1.875rem",
                        transform: rpcWidth ? `translateY(${rpcWidth * 0.05}px)` : "translateY(8px)"
                      }
                    },
                    void 0,
                    !1,
                    {
                      fileName: "app/components/recipe/recipe-nutrition/nutrition-chart/radial-chart.tsx",
                      lineNumber: 104,
                      columnNumber: 11
                    },
                    this
                  ),
                  /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(
                    import_recharts.LabelList,
                    {
                      className: "fill-gray-500",
                      dataKey: "qat.value",
                      formatter: (v) => v + data[0].qat.mes,
                      position: "centerTop",
                      style: {
                        fontSize: rpcWidth ? rpcWidth / 210 + "rem" : "1.875rem",
                        transform: rpcWidth ? `translateY(${rpcWidth * 0.15}px)` : "translateY(8px)"
                      }
                    },
                    void 0,
                    !1,
                    {
                      fileName: "app/components/recipe/recipe-nutrition/nutrition-chart/radial-chart.tsx",
                      lineNumber: 115,
                      columnNumber: 11
                    },
                    this
                  )
                ]
              },
              void 0,
              !0,
              {
                fileName: "app/components/recipe/recipe-nutrition/nutrition-chart/radial-chart.tsx",
                lineNumber: 83,
                columnNumber: 9
              },
              this
            )
          ]
        },
        void 0,
        !0,
        {
          fileName: "app/components/recipe/recipe-nutrition/nutrition-chart/radial-chart.tsx",
          lineNumber: 66,
          columnNumber: 7
        },
        this
      )
    },
    void 0,
    !1,
    {
      fileName: "app/components/recipe/recipe-nutrition/nutrition-chart/radial-chart.tsx",
      lineNumber: 59,
      columnNumber: 5
    },
    this
  );
}

// app/components/recipe/recipe-nutrition/nutrition-chart/index.tsx
var import_jsx_dev_runtime30 = require("react/jsx-dev-runtime");
function NutritionChartIndex({
  data
}) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime30.jsxDEV)(import_jsx_dev_runtime30.Fragment, { children: data.map((d) => {
    let keyName = d[0].name;
    return keyName === "Protein" ? /* @__PURE__ */ (0, import_jsx_dev_runtime30.jsxDEV)(
      RadialChart,
      {
        fillColorClass: "fill-rose-400",
        data: d
      },
      keyName,
      !1,
      {
        fileName: "app/components/recipe/recipe-nutrition/nutrition-chart/index.tsx",
        lineNumber: 21,
        columnNumber: 13
      },
      this
    ) : keyName === "Fat" ? /* @__PURE__ */ (0, import_jsx_dev_runtime30.jsxDEV)(
      RadialChart,
      {
        fillColorClass: "fill-green-400",
        data: d
      },
      keyName,
      !1,
      {
        fileName: "app/components/recipe/recipe-nutrition/nutrition-chart/index.tsx",
        lineNumber: 30,
        columnNumber: 13
      },
      this
    ) : keyName === "Soldium" ? /* @__PURE__ */ (0, import_jsx_dev_runtime30.jsxDEV)(RadialChart, { fillColorClass: "fill-primary", data: d }, keyName, !1, {
      fileName: "app/components/recipe/recipe-nutrition/nutrition-chart/index.tsx",
      lineNumber: 39,
      columnNumber: 13
    }, this) : /* @__PURE__ */ (0, import_jsx_dev_runtime30.jsxDEV)(RadialChart, { fillColorClass: "fill-cyan-400", data: d }, keyName, !1, {
      fileName: "app/components/recipe/recipe-nutrition/nutrition-chart/index.tsx",
      lineNumber: 43,
      columnNumber: 11
    }, this);
  }) }, void 0, !1, {
    fileName: "app/components/recipe/recipe-nutrition/nutrition-chart/index.tsx",
    lineNumber: 15,
    columnNumber: 5
  }, this);
}

// app/components/recipe/recipe-nutrition/index.tsx
var import_jsx_dev_runtime31 = require("react/jsx-dev-runtime");
function IngredientsIndex({
  data
}) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(ContentCard, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)("p", { className: "text-gray-500", children: "per serving" }, void 0, !1, {
      fileName: "app/components/recipe/recipe-nutrition/index.tsx",
      lineNumber: 12,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)("h2", { className: "text-black mb-9", children: "542 kcal" }, void 0, !1, {
      fileName: "app/components/recipe/recipe-nutrition/index.tsx",
      lineNumber: 13,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)("h4", { className: "mb-4 text-primary font-bold", children: "Nutrition of per serving" }, void 0, !1, {
      fileName: "app/components/recipe/recipe-nutrition/index.tsx",
      lineNumber: 14,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)("p", { className: "mb-9 text-gray-500", children: [
      "The percentage means ",
      /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)("b", { children: "%Daliy value" }, void 0, !1, {
        fileName: "app/components/recipe/recipe-nutrition/index.tsx",
        lineNumber: 16,
        columnNumber: 30
      }, this),
      " that tells you how much nutrition in a serving of food contributes to a daliy diet. 2,000 calories a day is used for general nutrition advice."
    ] }, void 0, !0, {
      fileName: "app/components/recipe/recipe-nutrition/index.tsx",
      lineNumber: 15,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)("div", { className: "w-full grid grid-cols-2 gap-9", children: /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(NutritionChartIndex, { data }, void 0, !1, {
      fileName: "app/components/recipe/recipe-nutrition/index.tsx",
      lineNumber: 21,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "app/components/recipe/recipe-nutrition/index.tsx",
      lineNumber: 20,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/recipe/recipe-nutrition/index.tsx",
    lineNumber: 11,
    columnNumber: 5
  }, this);
}

// app/routes/recipe.$recipeId.tsx
var import_node8 = require("@remix-run/node"), import_client3 = require("@prisma/client");
var import_react33 = require("@remix-run/react"), import_jsx_dev_runtime32 = require("react/jsx-dev-runtime"), nutritionData = [
  [
    {
      name: "Protein",
      pct: 40,
      qat: { value: 13, mes: "g" }
    }
  ],
  [
    {
      name: "Fat",
      pct: 30,
      qat: { value: 10, mes: "g" }
    }
  ],
  [
    {
      name: "Soldium",
      pct: 10,
      qat: { value: 20, mes: "mg" }
    }
  ],
  [
    {
      name: "Cholestral",
      pct: 40,
      qat: { value: 13, mes: "g" }
    }
  ]
], RecipeWithIngredients = import_client3.Prisma.validator()({
  ingredientsNum: { include: { ingredient: !0 } }
}), loader4 = async ({ params }) => {
  let id = params.recipeId, recipe = await db.recipe.findUnique({
    where: { id },
    include: RecipeWithIngredients
  });
  return (0, import_node8.json)(recipe);
};
function RecipeIndex() {
  let data = (0, import_react33.useLoaderData)();
  if (!data)
    return /* @__PURE__ */ (0, import_jsx_dev_runtime32.jsxDEV)("div", { children: "Not found the recipe!" }, void 0, !1, {
      fileName: "app/routes/recipe.$recipeId.tsx",
      lineNumber: 113,
      columnNumber: 12
    }, this);
  let {
    title,
    authorId: authorName,
    createdAt,
    difficulty,
    ingredientsNum
  } = data;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime32.jsxDEV)("div", { className: "flex flex-col mx-auto min-h-screen relative max-w-7xl", children: /* @__PURE__ */ (0, import_jsx_dev_runtime32.jsxDEV)("div", { className: "flex-1 relative ", children: /* @__PURE__ */ (0, import_jsx_dev_runtime32.jsxDEV)("div", { className: "layout-px layout-pt pb-8 space-y-10", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime32.jsxDEV)(RecipeHeader, { title, createdAt, difficulty, authorName }, void 0, !1, {
      fileName: "app/routes/recipe.$recipeId.tsx",
      lineNumber: 127,
      columnNumber: 11
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime32.jsxDEV)("div", { className: "flex space-x-10 text-black ", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime32.jsxDEV)(Index, { data: ingredientsNum }, void 0, !1, {
        fileName: "app/routes/recipe.$recipeId.tsx",
        lineNumber: 129,
        columnNumber: 13
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime32.jsxDEV)(IngredientsIndex, { data: nutritionData }, void 0, !1, {
        fileName: "app/routes/recipe.$recipeId.tsx",
        lineNumber: 130,
        columnNumber: 13
      }, this)
    ] }, void 0, !0, {
      fileName: "app/routes/recipe.$recipeId.tsx",
      lineNumber: 128,
      columnNumber: 11
    }, this)
  ] }, void 0, !0, {
    fileName: "app/routes/recipe.$recipeId.tsx",
    lineNumber: 126,
    columnNumber: 9
  }, this) }, void 0, !1, {
    fileName: "app/routes/recipe.$recipeId.tsx",
    lineNumber: 125,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "app/routes/recipe.$recipeId.tsx",
    lineNumber: 124,
    columnNumber: 5
  }, this);
}

// app/routes/my-recipes.tsx
var my_recipes_exports = {};
__export(my_recipes_exports, {
  default: () => MyRecipes,
  loader: () => loader5
});
var import_react36 = require("react"), import_node9 = require("@remix-run/node");

// app/components/card/card-grid.tsx
var import_react35 = require("react");

// app/components/card/card.tsx
var import_react34 = require("@remix-run/react");
var import_jsx_dev_runtime33 = require("react/jsx-dev-runtime");
function IconForm({
  recipeId,
  action: action8,
  icon
}) {
  let fetcher = (0, import_react34.useFetcher)();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)(AuthCheck, { loginConfirmModal: !0, children: (user) => /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)(fetcher.Form, { method: "post", action: action8, children: /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)(
    "button",
    {
      type: "submit",
      className: "icon-btn-sm icon-btn-square flex ",
      onClick: (e) => {
        user != null && user.id ? e.stopPropagation() : e.preventDefault();
      },
      children: icon
    },
    void 0,
    !1,
    {
      fileName: "app/components/card/card.tsx",
      lineNumber: 34,
      columnNumber: 11
    },
    this
  ) }, void 0, !1, {
    fileName: "app/components/card/card.tsx",
    lineNumber: 33,
    columnNumber: 9
  }, this) }, void 0, !1, {
    fileName: "app/components/card/card.tsx",
    lineNumber: 31,
    columnNumber: 5
  }, this);
}
function Overlay({
  author,
  id,
  isLiked,
  isInBasket
}) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)(
    "div",
    {
      className: `
      opacity-0
      invisible
      group-hover:opacity-100 group-hover:visible
      transition-all

      absolute 
      flex items-end 
      w-full h-full 
      p-3 
      bg-gradient-to-t from-gray-800/80 via-transparent 
       text-white
      `,
      children: /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)("div", { className: "flex-1 flex justify-between", children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)("span", { className: "inline-flex p-0.5 rounded-full bg-white", children: /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)("span", { className: "material-icons-round  leading-none text-black", children: "person" }, void 0, !1, {
            fileName: "app/components/card/card.tsx",
            lineNumber: 78,
            columnNumber: 13
          }, this) }, void 0, !1, {
            fileName: "app/components/card/card.tsx",
            lineNumber: 77,
            columnNumber: 11
          }, this),
          author
        ] }, void 0, !0, {
          fileName: "app/components/card/card.tsx",
          lineNumber: 76,
          columnNumber: 9
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)("div", { className: "flex gap-3", children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)(
            IconForm,
            {
              recipeId: id,
              action: `/recipe/like/${id}`,
              icon: /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)(
                "span",
                {
                  className: `material-symbols-rounded  leading-none ${isLiked ? "text-red-500" : ""}`,
                  style: isLiked ? { fontVariationSettings: '"FILL" 1' } : void 0,
                  children: "favorite"
                },
                void 0,
                !1,
                {
                  fileName: "app/components/card/card.tsx",
                  lineNumber: 89,
                  columnNumber: 15
                },
                this
              )
            },
            void 0,
            !1,
            {
              fileName: "app/components/card/card.tsx",
              lineNumber: 85,
              columnNumber: 11
            },
            this
          ),
          /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)(
            IconForm,
            {
              recipeId: id,
              action: `/add-basket/${id}`,
              icon: /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)(
                "span",
                {
                  className: ` material-symbols-rounded  leading-none ${isInBasket ? "text-blue-500" : ""}`,
                  style: isInBasket ? { fontVariationSettings: '"FILL" 1' } : void 0,
                  children: "shopping_basket"
                },
                void 0,
                !1,
                {
                  fileName: "app/components/card/card.tsx",
                  lineNumber: 105,
                  columnNumber: 15
                },
                this
              )
            },
            void 0,
            !1,
            {
              fileName: "app/components/card/card.tsx",
              lineNumber: 101,
              columnNumber: 11
            },
            this
          )
        ] }, void 0, !0, {
          fileName: "app/components/card/card.tsx",
          lineNumber: 84,
          columnNumber: 9
        }, this)
      ] }, void 0, !0, {
        fileName: "app/components/card/card.tsx",
        lineNumber: 75,
        columnNumber: 7
      }, this)
    },
    void 0,
    !1,
    {
      fileName: "app/components/card/card.tsx",
      lineNumber: 60,
      columnNumber: 5
    },
    this
  );
}
function Card({
  id,
  title,
  favCounts,
  basketCounts,
  author,
  isLiked,
  isInBasket
}) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)(
    import_react34.Link,
    {
      to: `/recipe/${id}`,
      className: "group flex flex-col gap-2 bg-white p-2 rounded-lg shadow-gray-200/50 shadow-xl hover:shadow-gray-200 hover:shadow-2xl hover:-translate-y-2 transition-all ease-in",
      children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)("div", { className: "relative aspect-w-4 aspect-h-3 flex items-center justify-center overflow-hidden rounded-lg", children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)("img", { className: "w-full h-full object-cover object-center ", src: img1_default }, void 0, !1, {
            fileName: "app/components/card/card.tsx",
            lineNumber: 138,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)(
            Overlay,
            {
              author,
              id,
              isLiked,
              isInBasket
            },
            void 0,
            !1,
            {
              fileName: "app/components/card/card.tsx",
              lineNumber: 139,
              columnNumber: 9
            },
            this
          )
        ] }, void 0, !0, {
          fileName: "app/components/card/card.tsx",
          lineNumber: 137,
          columnNumber: 7
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)("h4", { className: "line-clamp-1 text-center text-black font-medium", children: title }, void 0, !1, {
          fileName: "app/components/card/card.tsx",
          lineNumber: 146,
          columnNumber: 7
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)("div", { className: "flex justify-center gap-4", children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)("span", { className: "flex items-center gap-1 text-gray-400 text-sm", children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)(
              "span",
              {
                className: "material-symbols-outlined text-xl leading-none ",
                style: { fontVariationSettings: '"wght" 300, "FILL" 0' },
                children: "favorite"
              },
              void 0,
              !1,
              {
                fileName: "app/components/card/card.tsx",
                lineNumber: 151,
                columnNumber: 11
              },
              this
            ),
            favCounts
          ] }, void 0, !0, {
            fileName: "app/components/card/card.tsx",
            lineNumber: 150,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)("span", { className: "flex items-center gap-1 text-gray-400 text-sm", children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)(
              "span",
              {
                className: "material-symbols-outlined text-xl leading-none ",
                style: { fontVariationSettings: '"wght" 300,"FILL" 0' },
                children: "shopping_basket"
              },
              void 0,
              !1,
              {
                fileName: "app/components/card/card.tsx",
                lineNumber: 160,
                columnNumber: 11
              },
              this
            ),
            basketCounts
          ] }, void 0, !0, {
            fileName: "app/components/card/card.tsx",
            lineNumber: 159,
            columnNumber: 9
          }, this)
        ] }, void 0, !0, {
          fileName: "app/components/card/card.tsx",
          lineNumber: 149,
          columnNumber: 7
        }, this)
      ]
    },
    void 0,
    !0,
    {
      fileName: "app/components/card/card.tsx",
      lineNumber: 133,
      columnNumber: 5
    },
    this
  );
}

// app/components/card/card-grid.tsx
var import_jsx_dev_runtime34 = require("react/jsx-dev-runtime");
function CardGrid({
  data
}) {
  let [modifiedData, setModifiedData] = (0, import_react35.useState)([]);
  return (0, import_react35.useEffect)(() => {
    if (data) {
      let newData = data.map((recipe) => ({
        ...recipe,
        favCounts: Math.floor(Math.random() * 1e3),
        basketCounts: Math.floor(Math.random() * 1e3),
        title: recipe.title,
        author: recipe.author.name ?? recipe.author.id,
        id: recipe.id
      }));
      setModifiedData(newData);
    }
  }, [data]), data ? /* @__PURE__ */ (0, import_jsx_dev_runtime34.jsxDEV)("div", { className: "grid grid-cols-[repeat(auto-fill,minmax(300px,1fr))] gap-9", children: modifiedData.map(
    ({ id, title, favCounts, basketCounts, author, isLiked, isInBasket }, idx) => /* @__PURE__ */ (0, import_jsx_dev_runtime34.jsxDEV)(
      Card,
      {
        id,
        title,
        favCounts,
        basketCounts,
        author,
        isLiked,
        isInBasket
      },
      `${title}_${idx}`,
      !1,
      {
        fileName: "app/components/card/card-grid.tsx",
        lineNumber: 43,
        columnNumber: 11
      },
      this
    )
  ) }, void 0, !1, {
    fileName: "app/components/card/card-grid.tsx",
    lineNumber: 37,
    columnNumber: 5
  }, this) : null;
}

// app/components/search-bar.tsx
var import_jsx_dev_runtime35 = require("react/jsx-dev-runtime");
function SearchBar({
  placeholder = "Search",
  border = !1,
  list,
  fetch
}) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime35.jsxDEV)("div", { className: " relative w-full max-w-md text-black", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime35.jsxDEV)(
      "div",
      {
        className: `
            peer
						flex w-full items-center
						gap-2
						rounded-lg 
						bg-white
						
						outline-[3px] outline-offset-1 
						outline-focus-outline
            transition-all 
            ease-in focus-within:outline
            ${border ? "rounded border border-gray-200 focus-within:border-transparent hover:border-gray-400" : "shadow-sm shadow-gray-300 focus-within:shadow-lg hover:shadow-lg"}
            
            `,
        children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime35.jsxDEV)("span", { className: "material-symbols-rounded pl-4 text-xl leading-none text-gray-400", children: "search" }, void 0, !1, {
            fileName: "app/components/search-bar.tsx",
            lineNumber: 34,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime35.jsxDEV)(
            "input",
            {
              type: "text",
              placeholder,
              className: `
              min-w-0
							flex-1
							bg-transparent py-3
							pr-4
              focus:outline-none
          `,
              onChange: (e) => fetch(e.target.value)
            },
            void 0,
            !1,
            {
              fileName: "app/components/search-bar.tsx",
              lineNumber: 37,
              columnNumber: 9
            },
            this
          )
        ]
      },
      void 0,
      !0,
      {
        fileName: "app/components/search-bar.tsx",
        lineNumber: 14,
        columnNumber: 7
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime35.jsxDEV)(
      "div",
      {
        className: `
            absolute
            z-10
            mt-2
            hidden
            w-full rounded-lg 
            border 
            border-gray-100 bg-white px-4 
            py-3 
            shadow-lg hover:block 
            focus:block 
            peer-focus-within:block
            `,
        children: list === void 0 || (list == null ? void 0 : list.length) === 0 ? /* @__PURE__ */ (0, import_jsx_dev_runtime35.jsxDEV)("div", { children: "No results" }, void 0, !1, {
          fileName: "app/components/search-bar.tsx",
          lineNumber: 67,
          columnNumber: 11
        }, this) : list == null ? void 0 : list.map((v, idx) => /* @__PURE__ */ (0, import_jsx_dev_runtime35.jsxDEV)("div", { children: v.value }, v.value + idx, !1, {
          fileName: "app/components/search-bar.tsx",
          lineNumber: 72,
          columnNumber: 20
        }, this))
      },
      void 0,
      !1,
      {
        fileName: "app/components/search-bar.tsx",
        lineNumber: 51,
        columnNumber: 7
      },
      this
    )
  ] }, void 0, !0, {
    fileName: "app/components/search-bar.tsx",
    lineNumber: 13,
    columnNumber: 5
  }, this);
}

// app/routes/my-recipes.tsx
var import_react37 = require("@remix-run/react");

// app/lib/loaders/search-recipes.server.ts
function getSearchParams(requestUrl) {
  return new URL(requestUrl).searchParams.get("search") ?? "";
}
async function searchAllRecipes(request) {
  let param = getSearchParams(request.url), list = (await db.recipe.findMany({
    where: {
      title: { contains: param }
    },
    take: 10
  })).map((recipe) => ({ title: recipe.title, id: recipe.id }));
  return param.length === 0 ? [] : list;
}
async function searchUserRecipes(request, userId) {
  let param = getSearchParams(request.url);
  return (await db.recipe.findMany({
    where: {
      authorId: userId,
      title: { contains: param }
    },
    take: 10
  })).map((recipe) => ({ title: recipe.title, id: recipe.id }));
}
async function searchFavoriteRecipes(request, userId) {
  let param = getSearchParams(request.url);
  return (await db.recipe.findMany({
    where: {
      favorite: { some: { userId } },
      title: { contains: param }
    },
    take: 10
  })).map((recipe) => ({ title: recipe.title, id: recipe.id }));
}

// app/lib/loaders/query-card-list.ts
var import_client4 = require("@prisma/client");
async function getLikedAndBasket({
  userId,
  recipes
}) {
  let userFavs = await db.favorite.findFirst({
    where: { userId },
    select: { recipes: { select: { id: !0 } } }
  }), userBasket2 = await db.basket.findFirst({
    where: { userId },
    select: { recipes: { select: { id: !0 } } }
  });
  return recipes.map((recipe) => ({
    ...recipe,
    isLiked: !!(userFavs != null && userFavs.recipes.find((item) => item.id === recipe.id)),
    isInBasket: !!(userBasket2 != null && userBasket2.recipes.find((item) => item.id === recipe.id))
  }));
}
var recipesListData = import_client4.Prisma.validator()({
  select: {
    title: !0,
    id: !0,
    favorite: { include: { user: { select: { id: !0 } } } },
    baskets: !0,
    author: !0
  }
});
async function getAllRecipes(take) {
  return await db.recipe.findMany({
    take: take ?? 20,
    ...recipesListData
  });
}
async function getFavRecipes(userId) {
  return await db.recipe.findMany({
    where: {
      favorite: { some: { userId } }
    },
    ...recipesListData,
    take: 20
  });
}

// app/routes/my-recipes.tsx
var import_jsx_dev_runtime36 = require("react/jsx-dev-runtime"), loader5 = async ({ request }) => {
  let userId = await requireUserId(request), searchRes = await searchUserRecipes(request, userId), myRecipes = await db.recipe.findMany({
    where: { authorId: userId },
    ...recipesListData
  }), mappedMyRecipes = myRecipes.map((recipe) => ({
    ...recipe,
    isLiked: !!recipe.favorite.find((item) => item.userId === userId)
  }));
  return (0, import_node9.json)({ myRecipes, searchRes });
};
function MyRecipes() {
  var _a;
  let data = (0, import_react37.useLoaderData)(), fetcher = (0, import_react37.useFetcher)(), [searchList, setSearchList] = (0, import_react36.useState)([]);
  return (0, import_react36.useEffect)(() => {
    var _a2;
    (_a2 = fetcher.data) != null && _a2.searchRes && (console.log(fetcher.data.searchRes), setSearchList(fetcher.data.searchRes));
  }, [(_a = fetcher.data) == null ? void 0 : _a.searchRes]), /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)("div", { className: "layout-pt layout-px flex flex-col gap-9", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)("div", { className: "flex justify-center gap-6", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(
        SearchBar,
        {
          placeholder: "My Recipes Search",
          list: searchList.map((item) => ({ value: item.title, id: item.id })),
          fetch: (inputValue) => {
            fetcher.load(`/my-recipes?search=${inputValue}`);
          }
        },
        void 0,
        !1,
        {
          fileName: "app/routes/my-recipes.tsx",
          lineNumber: 48,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(
        DropdownMenu,
        {
          summary: "New",
          details: /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)("span", { children: "Popular" }, void 0, !1, {
            fileName: "app/routes/my-recipes.tsx",
            lineNumber: 59,
            columnNumber: 20
          }, this),
          hasDownArrow: !0
        },
        void 0,
        !1,
        {
          fileName: "app/routes/my-recipes.tsx",
          lineNumber: 57,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(
        DropdownMenu,
        {
          summary: "Filter",
          details: /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)("div", { children: "filter checkbox" }, void 0, !1, {
            fileName: "app/routes/my-recipes.tsx",
            lineNumber: 64,
            columnNumber: 20
          }, this),
          icon: /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)("span", { className: "material-symbols-rounded", children: "tune" }, void 0, !1, {
            fileName: "app/routes/my-recipes.tsx",
            lineNumber: 65,
            columnNumber: 17
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "app/routes/my-recipes.tsx",
          lineNumber: 62,
          columnNumber: 9
        },
        this
      )
    ] }, void 0, !0, {
      fileName: "app/routes/my-recipes.tsx",
      lineNumber: 47,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(CardGrid, { data: data.myRecipes }, void 0, !1, {
      fileName: "app/routes/my-recipes.tsx",
      lineNumber: 77,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/routes/my-recipes.tsx",
    lineNumber: 46,
    columnNumber: 5
  }, this);
}

// app/routes/favorite.tsx
var favorite_exports = {};
__export(favorite_exports, {
  default: () => Favorite,
  loader: () => loader6,
  meta: () => meta2
});
var import_node10 = require("@remix-run/node"), import_react38 = require("@remix-run/react");
var import_jsx_dev_runtime37 = require("react/jsx-dev-runtime"), meta2 = () => ({
  charset: "utf-8",
  title: "Favorite" + metaTitlePostfix
}), loader6 = async ({ request }) => {
  let userId = await requireUserId(request), searchRes = await searchFavoriteRecipes(request, userId), favRecipes = await getFavRecipes(userId), favRecipesWithLiked = await getLikedAndBasket({
    userId,
    recipes: favRecipes
  });
  return (0, import_node10.json)({ searchRes, favRecipes: favRecipesWithLiked });
};
function Favorite() {
  let data = (0, import_react38.useLoaderData)(), fetcher = (0, import_react38.useFetcher)();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime37.jsxDEV)("div", { className: "layout-pt layout-px flex flex-col gap-9", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime37.jsxDEV)("div", { className: "flex justify-center gap-6", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime37.jsxDEV)(
        SearchBar,
        {
          placeholder: "Favorite Search",
          list: data.searchRes.map((item) => ({
            id: item.id,
            value: item.title
          })),
          fetch: (inputValue) => {
            fetcher.load(`/favorite?search=${inputValue}`);
          }
        },
        void 0,
        !1,
        {
          fileName: "app/routes/favorite.tsx",
          lineNumber: 45,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ (0, import_jsx_dev_runtime37.jsxDEV)(
        DropdownMenu,
        {
          summary: "New",
          details: /* @__PURE__ */ (0, import_jsx_dev_runtime37.jsxDEV)("span", { children: "Popular" }, void 0, !1, {
            fileName: "app/routes/favorite.tsx",
            lineNumber: 59,
            columnNumber: 20
          }, this),
          hasDownArrow: !0
        },
        void 0,
        !1,
        {
          fileName: "app/routes/favorite.tsx",
          lineNumber: 57,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ (0, import_jsx_dev_runtime37.jsxDEV)(
        DropdownMenu,
        {
          summary: "Filter",
          details: /* @__PURE__ */ (0, import_jsx_dev_runtime37.jsxDEV)("div", { children: "filter checkbox" }, void 0, !1, {
            fileName: "app/routes/favorite.tsx",
            lineNumber: 64,
            columnNumber: 20
          }, this),
          icon: /* @__PURE__ */ (0, import_jsx_dev_runtime37.jsxDEV)("span", { className: "material-symbols-rounded", children: "tune" }, void 0, !1, {
            fileName: "app/routes/favorite.tsx",
            lineNumber: 65,
            columnNumber: 17
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "app/routes/favorite.tsx",
          lineNumber: 62,
          columnNumber: 9
        },
        this
      )
    ] }, void 0, !0, {
      fileName: "app/routes/favorite.tsx",
      lineNumber: 44,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime37.jsxDEV)(CardGrid, { data: data.favRecipes }, void 0, !1, {
      fileName: "app/routes/favorite.tsx",
      lineNumber: 68,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/routes/favorite.tsx",
    lineNumber: 43,
    columnNumber: 5
  }, this);
}

// app/routes/basket.tsx
var basket_exports = {};
__export(basket_exports, {
  default: () => BasketIndex,
  loader: () => loader7,
  meta: () => meta3
});
var import_node11 = require("@remix-run/node"), import_react42 = require("@remix-run/react");

// app/components/basket/basket-table/index.tsx
var import_react41 = require("react");

// app/components/basket/basket-table/table-row.tsx
var import_react40 = require("react");

// app/components/basket/basket-table/table-row-form.tsx
var import_react39 = require("react"), import_react_hook_form4 = require("react-hook-form");
var import_jsx_dev_runtime38 = require("react/jsx-dev-runtime");
function TableRowForm({
  value,
  unit,
  setInputValue,
  isDeleted,
  hasSetBtn,
  defaultValue
}) {
  let methods = (0, import_react_hook_form4.useForm)({
    mode: "onChange"
  }), { reset, watch } = methods;
  return (0, import_react39.useEffect)(() => {
    defaultValue && (reset({ input: defaultValue }), console.log(defaultValue));
  }, [defaultValue, reset]), (0, import_react39.useEffect)(() => {
    let subscription = watch((v) => {
      v.input && setInputValue(v.input);
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [setInputValue, watch]), /* @__PURE__ */ (0, import_jsx_dev_runtime38.jsxDEV)(import_react_hook_form4.FormProvider, { ...methods, children: /* @__PURE__ */ (0, import_jsx_dev_runtime38.jsxDEV)("form", { className: "relative flex items-stretch ", children: /* @__PURE__ */ (0, import_jsx_dev_runtime38.jsxDEV)(
    number_input_default,
    {
      registerName: "input",
      maxValue: value,
      showErrors: !0,
      unit
    },
    void 0,
    !1,
    {
      fileName: "app/components/basket/basket-table/table-row-form.tsx",
      lineNumber: 48,
      columnNumber: 9
    },
    this
  ) }, void 0, !1, {
    fileName: "app/components/basket/basket-table/table-row-form.tsx",
    lineNumber: 47,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "app/components/basket/basket-table/table-row-form.tsx",
    lineNumber: 46,
    columnNumber: 5
  }, this);
}

// app/components/basket/basket-table/table-row.tsx
var import_jsx_dev_runtime39 = require("react/jsx-dev-runtime");
function TableRow({
  name,
  value,
  unit,
  localBasket
}) {
  let [isDeleted, setIsDeleted] = (0, import_react40.useState)(!1), dispatch = useAppDispatch();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)("div", { className: "relative table-row-group text-secondary ", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)("div", { className: "table-row", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)("div", { className: "table-cell px-4 first:pl-8 last:pr-8 py-3 ", children: /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)("div", { className: "flex items-center", children: /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)("span", { children: name }, void 0, !1, {
        fileName: "app/components/basket/basket-table/table-row.tsx",
        lineNumber: 34,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/components/basket/basket-table/table-row.tsx",
        lineNumber: 33,
        columnNumber: 11
      }, this) }, void 0, !1, {
        fileName: "app/components/basket/basket-table/table-row.tsx",
        lineNumber: 32,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)(
        "div",
        {
          className: `
          relative 
          table-cell px-4 first:pl-8 last:pr-8 
          py-3 
          text-secondary font-bold 
          text-lg
          `,
          children: /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)("span", { className: "[background:linear-gradient(to_bottom,transparent_50%,#fbbf2490_50%)]", children: value * localBasket.servings - (isNaN(localBasket.hadQant) ? 0 : localBasket.hadQant) + unit }, void 0, !1, {
            fileName: "app/components/basket/basket-table/table-row.tsx",
            lineNumber: 46,
            columnNumber: 11
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "app/components/basket/basket-table/table-row.tsx",
          lineNumber: 37,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)("div", { className: "table-cell px-4 first:pl-8 last:pr-8 py-3", children: /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)("div", { className: "", children: value * localBasket.servings + unit }, void 0, !1, {
        fileName: "app/components/basket/basket-table/table-row.tsx",
        lineNumber: 56,
        columnNumber: 11
      }, this) }, void 0, !1, {
        fileName: "app/components/basket/basket-table/table-row.tsx",
        lineNumber: 55,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)("div", { className: "table-cell px-4 first:pl-8 last:pr-8 py-3 ", children: /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)(
        TableRowForm,
        {
          setInputValue: (value2) => void dispatch(updateHadQuan({ name, hadQant: value2 })),
          defaultValue: (localBasket == null ? void 0 : localBasket.hadQant) ?? 0,
          isDeleted,
          value,
          unit
        },
        void 0,
        !1,
        {
          fileName: "app/components/basket/basket-table/table-row.tsx",
          lineNumber: 62,
          columnNumber: 11
        },
        this
      ) }, void 0, !1, {
        fileName: "app/components/basket/basket-table/table-row.tsx",
        lineNumber: 61,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)("div", { className: "table-cell px-4 first:pl-8 last:pr-8 align-middle py-3 text-gray-500", children: /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)(
        "button",
        {
          className: "flex p-1",
          onClick: () => {
            setIsDeleted((prev) => !prev);
          },
          children: /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)(
            "span",
            {
              className: `material-symbols-outlined leading-none ${isDeleted ? "text-green-500" : "text-red-600"}`,
              children: isDeleted ? "undo" : "delete"
            },
            void 0,
            !1,
            {
              fileName: "app/components/basket/basket-table/table-row.tsx",
              lineNumber: 92,
              columnNumber: 13
            },
            this
          )
        },
        void 0,
        !1,
        {
          fileName: "app/components/basket/basket-table/table-row.tsx",
          lineNumber: 86,
          columnNumber: 11
        },
        this
      ) }, void 0, !1, {
        fileName: "app/components/basket/basket-table/table-row.tsx",
        lineNumber: 85,
        columnNumber: 9
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/basket/basket-table/table-row.tsx",
      lineNumber: 31,
      columnNumber: 7
    }, this),
    isDeleted && /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)(
      "div",
      {
        className: "absolute top-0 left-0  h-full bg-white/50 mix-blend-screen",
        style: { width: "calc(100% - 56px)" }
      },
      void 0,
      !1,
      {
        fileName: "app/components/basket/basket-table/table-row.tsx",
        lineNumber: 103,
        columnNumber: 9
      },
      this
    )
  ] }, void 0, !0, {
    fileName: "app/components/basket/basket-table/table-row.tsx",
    lineNumber: 30,
    columnNumber: 5
  }, this);
}

// app/store/selectBasket.ts
var import_toolkit7 = require("@reduxjs/toolkit"), ingredientsSelector = (state) => state.ingredients, recipeServingsSelector = (state) => state.recipeServings, selectBasket = () => (0, import_toolkit7.createSelector)(
  ingredientsSelector,
  recipeServingsSelector,
  (ingredients, recipes) => ingredients.map((ingredient) => {
    let newServings = ingredient.recipeIds.map(
      (id) => {
        var _a;
        return ((_a = recipes.find((item) => item.recipeId === id)) == null ? void 0 : _a.servings) ?? 0;
      }
    );
    return {
      name: ingredient.name,
      hadQant: ingredient.hadQant,
      servings: newServings.length > 0 ? newServings.reduce((a, b) => a + b, 0) : 0
    };
  })
);

// app/components/basket/basket-table/index.tsx
var import_jsx_dev_runtime40 = require("react/jsx-dev-runtime");
function BasketTable({
  data
}) {
  let selectBasketMemo = (0, import_react41.useMemo)(selectBasket, []), basket = useAppSelector(selectBasketMemo), ingredients = useAppSelector((state) => state.ingredients), recipeServings = useAppSelector((state) => state.recipeServings), dispatch = useAppDispatch();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime40.jsxDEV)("div", { className: "table table-auto w-full text-black ", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime40.jsxDEV)("div", { className: "table-header-group font-medium ", children: /* @__PURE__ */ (0, import_jsx_dev_runtime40.jsxDEV)("div", { className: "table-row ", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime40.jsxDEV)("div", { className: "table-cell  text-left px-4 pt-8 pb-3 first:pl-8 last:pr-8 border-b border-gray-200", children: "INGREDIENTS" }, void 0, !1, {
        fileName: "app/components/basket/basket-table/index.tsx",
        lineNumber: 115,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime40.jsxDEV)("div", { className: "table-cell w-28 text-left px-4 pt-8 pb-3 first:pl-8 last:pr-8 border-b border-gray-200", children: "NEED" }, void 0, !1, {
        fileName: "app/components/basket/basket-table/index.tsx",
        lineNumber: 118,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime40.jsxDEV)("div", { className: "table-cell text-left px-4 pt-8 pb-3 first:pl-8 last:pr-8 border-b border-gray-200", children: "REQUIRE" }, void 0, !1, {
        fileName: "app/components/basket/basket-table/index.tsx",
        lineNumber: 122,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime40.jsxDEV)("div", { className: "table-cell text-left px-4 pt-8 pb-3 first:pl-8 last:pr-8 border-b border-gray-200", children: "HAVE" }, void 0, !1, {
        fileName: "app/components/basket/basket-table/index.tsx",
        lineNumber: 126,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime40.jsxDEV)("div", { className: "table-cell w-8 text-left px-4 pt-8 pb-3 first:pl-8 last:pr-8 border-b border-gray-200" }, void 0, !1, {
        fileName: "app/components/basket/basket-table/index.tsx",
        lineNumber: 132,
        columnNumber: 11
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/basket/basket-table/index.tsx",
      lineNumber: 114,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "app/components/basket/basket-table/index.tsx",
      lineNumber: 113,
      columnNumber: 7
    }, this),
    data == null ? void 0 : data.map(({ ingredient: { name }, value, unit }, idx) => /* @__PURE__ */ (0, import_jsx_dev_runtime40.jsxDEV)(
      TableRow,
      {
        name,
        value: parseInt(value),
        unit,
        localBasket: basket.find(
          (ingredient) => ingredient.name === name
        ) ?? { name, hadQant: 0, servings: 1 }
      },
      `${name}_${idx}`,
      !1,
      {
        fileName: "app/components/basket/basket-table/index.tsx",
        lineNumber: 136,
        columnNumber: 9
      },
      this
    ))
  ] }, void 0, !0, {
    fileName: "app/components/basket/basket-table/index.tsx",
    lineNumber: 112,
    columnNumber: 5
  }, this);
}

// app/routes/basket.tsx
var import_jsx_dev_runtime41 = require("react/jsx-dev-runtime"), meta3 = () => ({
  charset: "utf-8",
  title: "Basket" + metaTitlePostfix
}), loader7 = async ({ request }) => {
  let userId = await requireUserId(request), basket = await db.basket.findUnique({
    where: { userId },
    include: {
      recipes: {
        select: {
          title: !0,
          id: !0,
          ingredientsNum: { include: { ingredient: !0 } }
        }
      }
    }
  }), ingredients = [];
  return basket == null || basket.recipes.forEach(({ ingredientsNum }) => {
    let foundIng = ingredients.find(
      ({ ingredientId }) => ingredientId === ingredientsNum[0].ingredientId
    );
    foundIng ? foundIng.value += ingredientsNum[0].value : ingredients = ingredients.concat(ingredientsNum);
  }), (0, import_node11.json)({ basket, ingredients });
};
function BasketIndex() {
  let data = (0, import_react42.useLoaderData)();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime41.jsxDEV)("div", { className: "layout-py layout-px", children: /* @__PURE__ */ (0, import_jsx_dev_runtime41.jsxDEV)("div", { className: "max-w-6xl mx-auto grid [grid-template-areas:'header_header''ingredients_sideList'] grid-rows-[auto,1fr] grid-cols-[3fr,2fr] gap-6", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime41.jsxDEV)("h2", { children: "Basket" }, void 0, !1, {
      fileName: "app/routes/basket.tsx",
      lineNumber: 85,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime41.jsxDEV)("div", { className: "[grid-area:ingredients] ", children: /* @__PURE__ */ (0, import_jsx_dev_runtime41.jsxDEV)(ContentCard, { className: "!p-0", children: /* @__PURE__ */ (0, import_jsx_dev_runtime41.jsxDEV)(BasketTable, { data: data == null ? void 0 : data.ingredients }, void 0, !1, {
      fileName: "app/routes/basket.tsx",
      lineNumber: 89,
      columnNumber: 13
    }, this) }, void 0, !1, {
      fileName: "app/routes/basket.tsx",
      lineNumber: 88,
      columnNumber: 11
    }, this) }, void 0, !1, {
      fileName: "app/routes/basket.tsx",
      lineNumber: 86,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime41.jsxDEV)(ContentCard, { className: "[grid-area:sideList] flex flex-col gap-8 h-full ", children: /* @__PURE__ */ (0, import_jsx_dev_runtime41.jsxDEV)(import_react42.Outlet, {}, void 0, !1, {
      fileName: "app/routes/basket.tsx",
      lineNumber: 94,
      columnNumber: 11
    }, this) }, void 0, !1, {
      fileName: "app/routes/basket.tsx",
      lineNumber: 93,
      columnNumber: 9
    }, this)
  ] }, void 0, !0, {
    fileName: "app/routes/basket.tsx",
    lineNumber: 84,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "app/routes/basket.tsx",
    lineNumber: 83,
    columnNumber: 5
  }, this);
}

// app/routes/basket/index.tsx
var basket_exports2 = {};
__export(basket_exports2, {
  action: () => action5,
  default: () => BasketSidePanel,
  loader: () => loader8
});
var import_node12 = require("@remix-run/node"), import_react43 = require("@remix-run/react"), import_react44 = require("react");
var import_jsx_dev_runtime42 = require("react/jsx-dev-runtime"), loader8 = async ({ request }) => {
  let basket = await db.basket.findUnique({
    where: { userId: "testuser0" },
    include: {
      recipes: {
        select: {
          title: !0,
          id: !0,
          ingredientsNum: { include: { ingredient: !0 } }
        }
      }
    }
  }), query = new URL(request.url).searchParams.get("search") ?? "", list = (await (async () => query.length === 0 ? [null] : await db.recipe.findMany({
    where: {
      AND: [
        { baskets: { some: { id: "testbasket0" } } },
        { title: { contains: query } }
      ]
    },
    take: 10
  }))()).map((v) => v === null ? v : v.title);
  return { basket, list };
}, action5 = async ({ request }) => {
  let id = (await request.formData()).get("deleteId");
  return id && await db.basket.update({
    where: { id: "testbasket0" },
    data: { recipes: { disconnect: { id: id.toString() } } }
  }), (0, import_node12.json)({});
};
function BasketSidePanel() {
  var _a;
  let data = (0, import_react43.useLoaderData)(), fetcher = (0, import_react43.useFetcher)(), servings = useAppSelector((state) => state.recipeServings), dispatch = useAppDispatch(), [resList, setResList] = (0, import_react44.useState)(null);
  (0, import_react44.useEffect)(() => {
    data == null || data.basket.recipes.forEach(({ id, ingredientsNum }) => {
      dispatch(addRecipeServings({ recipeId: id, servings: 1 })), ingredientsNum.forEach(({ ingredient }) => {
        dispatch(
          addIngredient({ name: ingredient.name, recipeIds: [id], hadQant: 0 })
        ), dispatch(addRecipeId({ name: ingredient.name, recipeId: id }));
      });
    });
  }, [data == null ? void 0 : data.basket.recipes, dispatch]);
  let onSearch = (inputValue) => {
    fetcher.load(`/basket?index&search=${inputValue}`);
  };
  return (0, import_react44.useEffect)(() => {
    var _a2;
    (_a2 = fetcher.data) != null && _a2.list && setResList(fetcher.data.list);
  }, [(_a = fetcher.data) == null ? void 0 : _a.list]), /* @__PURE__ */ (0, import_jsx_dev_runtime42.jsxDEV)(import_jsx_dev_runtime42.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime42.jsxDEV)(
      SearchBar,
      {
        placeholder: "Basket Search",
        border: !0,
        fetch: onSearch,
        list: resList == null ? void 0 : resList.map((item) => ({ id: "", value: item }))
      },
      void 0,
      !1,
      {
        fileName: "app/routes/basket/index.tsx",
        lineNumber: 124,
        columnNumber: 7
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime42.jsxDEV)("div", { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime42.jsxDEV)("h4", { className: "mb-4 font-bold text-black", children: "Recipes in basket" }, void 0, !1, {
        fileName: "app/routes/basket/index.tsx",
        lineNumber: 131,
        columnNumber: 9
      }, this),
      (data == null ? void 0 : data.basket.recipes) && (data == null ? void 0 : data.basket.recipes.map(({ title, id, ingredientsNum }, idx) => {
        var _a2;
        return /* @__PURE__ */ (0, import_jsx_dev_runtime42.jsxDEV)(
          CardListItem,
          {
            title,
            recipeId: id,
            onDelete: (e) => {
              ingredientsNum.forEach((item) => {
                dispatch(
                  deleteRecipeId({
                    name: item.ingredient.name,
                    recipeId: id
                  })
                );
              }), dispatch(deleteRecipeServings({ recipeId: id })), fetcher.submit(e.currentTarget, {
                action: "/basket?index"
              });
            },
            subTitle: /* @__PURE__ */ (0, import_jsx_dev_runtime42.jsxDEV)(
              recipe_servings_form_default,
              {
                recipeId: id,
                defaultValue: (_a2 = servings.find((item) => item.recipeId === id)) == null ? void 0 : _a2.servings
              },
              void 0,
              !1,
              {
                fileName: "app/routes/basket/index.tsx",
                lineNumber: 155,
                columnNumber: 19
              },
              this
            )
          },
          `${title}_${idx}`,
          !1,
          {
            fileName: "app/routes/basket/index.tsx",
            lineNumber: 136,
            columnNumber: 15
          },
          this
        );
      }))
    ] }, void 0, !0, {
      fileName: "app/routes/basket/index.tsx",
      lineNumber: 130,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/routes/basket/index.tsx",
    lineNumber: 123,
    columnNumber: 5
  }, this);
}

// app/routes/logout.tsx
var logout_exports = {};
__export(logout_exports, {
  action: () => action6,
  loader: () => loader9
});
var import_node13 = require("@remix-run/node");
var action6 = async ({ request }) => logout(request), loader9 = async () => (0, import_node13.redirect)("/");

// app/routes/upload.tsx
var upload_exports = {};
__export(upload_exports, {
  ErrorBoundary: () => ErrorBoundary2,
  default: () => Upload,
  loader: () => loader10
});
var import_node14 = require("@remix-run/node"), import_react45 = require("@remix-run/react"), import_react46 = require("react"), import_uuid = require("uuid");
var import_jsx_dev_runtime43 = require("react/jsx-dev-runtime"), defaultSideList = [
  { value: "Details", route: "./details" },
  { value: "Ingredients", route: "./ingredients" }
], defaultStepList = [
  {
    value: "Steps"
  },
  { stepId: "1", value: "title", route: "./1" }
], SideList = ({
  route,
  value,
  idx,
  stepId,
  onDelete
}) => route ? /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)("li", { className: "relative flex", children: [
  /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)(
    import_react45.NavLink,
    {
      to: route,
      className: ({ isActive }) => `
        
                        sider-item 
                        sider-item-gray 
                      ${isActive ? "bg-primary/10 " : "text-black"}
                      `,
      children: [
        stepId ? idx + 1 + " . " : null,
        value
      ]
    },
    void 0,
    !0,
    {
      fileName: "app/routes/upload.tsx",
      lineNumber: 52,
      columnNumber: 7
    },
    this
  ),
  onDelete && stepId ? /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)(
    "button",
    {
      className: "icon-btn-ui absolute right-8 top-2 z-50 flex h-fit rounded-full p-1 text-red-300 hover:bg-red-500 hover:text-white",
      onClick: () => {
        onDelete(stepId);
      },
      children: /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)(
        "span",
        {
          className: "material-symbols-outlined leading-none ",
          style: { fontVariationSettings: '"GRAD" -25' },
          children: "delete"
        },
        void 0,
        !1,
        {
          fileName: "app/routes/upload.tsx",
          lineNumber: 72,
          columnNumber: 11
        },
        this
      )
    },
    void 0,
    !1,
    {
      fileName: "app/routes/upload.tsx",
      lineNumber: 65,
      columnNumber: 9
    },
    this
  ) : null
] }, `${value}_${idx}`, !0, {
  fileName: "app/routes/upload.tsx",
  lineNumber: 51,
  columnNumber: 5
}, this) : /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)(
  "li",
  {
    className: "sider-item px-0 text-sm uppercase tracking-wider text-gray-400",
    children: value
  },
  `${value}_${route}`,
  !1,
  {
    fileName: "app/routes/upload.tsx",
    lineNumber: 42,
    columnNumber: 7
  },
  this
), loader10 = async ({ request }) => {
  let userId = await requireUserId(request);
  return (0, import_node14.json)({ userId });
};
function Upload() {
  let { stepIdx } = (0, import_react45.useParams)(), [sideList, setSideList] = (0, import_react46.useState)(defaultSideList), stepForms = useAppSelector((state) => state.stepForm), dispatch = useAppDispatch(), navigate = (0, import_react45.useNavigate)();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)("div", { className: "layout-px mx-auto max-w-6xl space-y-6 py-14", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)("header", { className: "flex items-center justify-between  text-black ", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)("h2", { className: "", children: "Upload Recipe" }, void 0, !1, {
        fileName: "app/routes/upload.tsx",
        lineNumber: 135,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)("div", { className: "flex gap-2", children: /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)("button", { className: "btn-secondary btn-sm", children: "Public" }, void 0, !1, {
        fileName: "app/routes/upload.tsx",
        lineNumber: 137,
        columnNumber: 11
      }, this) }, void 0, !1, {
        fileName: "app/routes/upload.tsx",
        lineNumber: 136,
        columnNumber: 9
      }, this)
    ] }, void 0, !0, {
      fileName: "app/routes/upload.tsx",
      lineNumber: 133,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)(ContentCard, { className: "flex max-h-[700px] !py-0 !px-0", children: /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)("div", { className: "flex w-full flex-1 space-x-8", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)("div", { className: "w-60 border-r border-gray-200 py-6 ", children: /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)("nav", { className: "flex h-full flex-col", children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)("ul", { className: "flex-1  overflow-auto", children: [
          defaultSideList.map(({ value, route }, idx) => /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)(
            SideList,
            {
              route,
              value,
              idx
            },
            `${value}_${idx}`,
            !1,
            {
              fileName: "app/routes/upload.tsx",
              lineNumber: 148,
              columnNumber: 21
            },
            this
          )),
          /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)(SideList, { value: "Steps", idx: 999 }, void 0, !1, {
            fileName: "app/routes/upload.tsx",
            lineNumber: 156,
            columnNumber: 17
          }, this),
          stepForms.length > 0 ? stepForms.map(({ title, id }, idx) => /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)(
            SideList,
            {
              route: `/upload/${idx + 1}`,
              value: title,
              stepId: id,
              idx,
              onDelete: () => {
                stepIdx && +stepIdx === idx + 1 ? navigate(`/upload/${idx}`) : stepIdx && +stepIdx > idx + 1 && navigate(`/upload/${+stepIdx - 1}`), dispatch(deleteStep({ id }));
              }
            },
            `${title}_${idx}`,
            !1,
            {
              fileName: "app/routes/upload.tsx",
              lineNumber: 160,
              columnNumber: 25
            },
            this
          )) : defaultStepList.map(({ value, stepId, route }, idx) => /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)(
            SideList,
            {
              route,
              value,
              stepId,
              idx,
              onDelete: (stepId2) => {
                navigate(`/upload/${idx}`), dispatch(deleteStep({ id: stepId2 }));
              }
            },
            `${value}_${idx}`,
            !1,
            {
              fileName: "app/routes/upload.tsx",
              lineNumber: 179,
              columnNumber: 25
            },
            this
          ))
        ] }, void 0, !0, {
          fileName: "app/routes/upload.tsx",
          lineNumber: 145,
          columnNumber: 15
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)("div", { className: "flex pt-4", children: /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)(
          import_react45.Link,
          {
            to: `/upload/${stepForms.length > 0 ? stepForms.length + 1 : defaultStepList.length + 1}`,
            className: "btn-sm btn-secondary sider-item flex-1  ",
            onClick: () => {
              dispatch(
                addStep({
                  title: "",
                  methods: [{ timeStamp: "", content: "" }],
                  id: (0, import_uuid.v4)()
                })
              );
            },
            children: "Add a step"
          },
          void 0,
          !1,
          {
            fileName: "app/routes/upload.tsx",
            lineNumber: 194,
            columnNumber: 17
          },
          this
        ) }, void 0, !1, {
          fileName: "app/routes/upload.tsx",
          lineNumber: 193,
          columnNumber: 15
        }, this)
      ] }, void 0, !0, {
        fileName: "app/routes/upload.tsx",
        lineNumber: 144,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/routes/upload.tsx",
        lineNumber: 143,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)("div", { className: "flex flex-1 py-6", children: /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)("div", { className: "flex-1 overflow-auto pr-9", children: /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)(import_react45.Outlet, {}, void 0, !1, {
        fileName: "app/routes/upload.tsx",
        lineNumber: 218,
        columnNumber: 15
      }, this) }, void 0, !1, {
        fileName: "app/routes/upload.tsx",
        lineNumber: 217,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/routes/upload.tsx",
        lineNumber: 216,
        columnNumber: 11
      }, this)
    ] }, void 0, !0, {
      fileName: "app/routes/upload.tsx",
      lineNumber: 142,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "app/routes/upload.tsx",
      lineNumber: 141,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/routes/upload.tsx",
    lineNumber: 132,
    columnNumber: 5
  }, this);
}
var ErrorBoundary2 = ({ error }) => {
  let navigate = (0, import_react45.useNavigate)();
  return console.log("error"), /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)("div", { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)("h1", { children: "Oops! Something went wrong!" }, void 0, !1, {
      fileName: "app/routes/upload.tsx",
      lineNumber: 233,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)(
      "button",
      {
        onClick: () => {
          navigate(-1);
        },
        children: "Go back"
      },
      void 0,
      !1,
      {
        fileName: "app/routes/upload.tsx",
        lineNumber: 234,
        columnNumber: 7
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)(import_react45.Link, { to: "/", children: "Home page" }, void 0, !1, {
      fileName: "app/routes/upload.tsx",
      lineNumber: 241,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/routes/upload.tsx",
    lineNumber: 232,
    columnNumber: 5
  }, this);
};

// app/routes/upload/ingredients.tsx
var ingredients_exports = {};
__export(ingredients_exports, {
  default: () => ingredients_default
});
var import_react47 = require("@remix-run/react"), import_react_hook_form5 = require("react-hook-form"), import_jsx_dev_runtime44 = require("react/jsx-dev-runtime"), ingredients_default = () => {
  let { register: register2, control } = (0, import_react_hook_form5.useForm)({
    defaultValues: { serving: 1, ingredients: [{ name: "", qty: "" }] }
  }), { fields, append, remove } = (0, import_react_hook_form5.useFieldArray)({
    control,
    name: "ingredients"
  });
  return /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)("div", { className: "space-y-12", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)("h3", { className: "font-medium text-black", children: "Ingredients" }, void 0, !1, {
      fileName: "app/routes/upload/ingredients.tsx",
      lineNumber: 21,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)("form", { className: "flex flex-col space-y-12", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)("label", { children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)("p", { className: "label-required", children: "Default serving" }, void 0, !1, {
          fileName: "app/routes/upload/ingredients.tsx",
          lineNumber: 24,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)(
          "input",
          {
            ...register2("serving"),
            type: "number",
            placeholder: "1",
            className: "input w-12 text-right",
            min: 1
          },
          void 0,
          !1,
          {
            fileName: "app/routes/upload/ingredients.tsx",
            lineNumber: 25,
            columnNumber: 11
          },
          this
        ),
        /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)("span", { className: "ml-2", children: "serving" }, void 0, !1, {
          fileName: "app/routes/upload/ingredients.tsx",
          lineNumber: 32,
          columnNumber: 11
        }, this)
      ] }, void 0, !0, {
        fileName: "app/routes/upload/ingredients.tsx",
        lineNumber: 23,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)("label", { children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)("p", { className: "label-required", children: "Ingredients list" }, void 0, !1, {
          fileName: "app/routes/upload/ingredients.tsx",
          lineNumber: 35,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)("ul", { className: "space-y-4", children: [
          fields.map((field, idx) => /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)("div", { className: "flex gap-4", children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)(
              "input",
              {
                ...field,
                name: `ingredients.${idx}.name`,
                className: "input flex-1",
                placeholder: "Name"
              },
              void 0,
              !1,
              {
                fileName: "app/routes/upload/ingredients.tsx",
                lineNumber: 40,
                columnNumber: 19
              },
              this
            ),
            /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)(
              "input",
              {
                ...field,
                name: `ingredients.${idx}.qty`,
                className: "input w-20",
                placeholder: "QTY"
              },
              void 0,
              !1,
              {
                fileName: "app/routes/upload/ingredients.tsx",
                lineNumber: 46,
                columnNumber: 19
              },
              this
            ),
            /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)(
              "button",
              {
                className: "btn-sm btn-ghost",
                type: "button",
                onClick: () => {
                  remove(idx);
                },
                disabled: fields.length === 1,
                children: "Delet"
              },
              void 0,
              !1,
              {
                fileName: "app/routes/upload/ingredients.tsx",
                lineNumber: 52,
                columnNumber: 19
              },
              this
            )
          ] }, field.id, !0, {
            fileName: "app/routes/upload/ingredients.tsx",
            lineNumber: 39,
            columnNumber: 17
          }, this)),
          /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)(
            "button",
            {
              className: "btn-sm btn-border",
              type: "button",
              onClick: () => {
                append({ name: "", qty: "" });
              },
              children: "Add a ingredient"
            },
            void 0,
            !1,
            {
              fileName: "app/routes/upload/ingredients.tsx",
              lineNumber: 65,
              columnNumber: 13
            },
            this
          )
        ] }, void 0, !0, {
          fileName: "app/routes/upload/ingredients.tsx",
          lineNumber: 36,
          columnNumber: 11
        }, this)
      ] }, void 0, !0, {
        fileName: "app/routes/upload/ingredients.tsx",
        lineNumber: 34,
        columnNumber: 9
      }, this)
    ] }, void 0, !0, {
      fileName: "app/routes/upload/ingredients.tsx",
      lineNumber: 22,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)("div", { className: "flex gap-4", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)(import_react47.Link, { to: "./details", className: "btn-sm btn-gray", children: "Previous" }, void 0, !1, {
        fileName: "app/routes/upload/ingredients.tsx",
        lineNumber: 78,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)(import_react47.Link, { to: "../1", className: "btn-sm btn-primary", children: "Next" }, void 0, !1, {
        fileName: "app/routes/upload/ingredients.tsx",
        lineNumber: 81,
        columnNumber: 9
      }, this)
    ] }, void 0, !0, {
      fileName: "app/routes/upload/ingredients.tsx",
      lineNumber: 77,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/routes/upload/ingredients.tsx",
    lineNumber: 20,
    columnNumber: 5
  }, this);
};

// app/routes/upload/$stepIdx.tsx
var stepIdx_exports = {};
__export(stepIdx_exports, {
  default: () => StepsPage
});
var import_react49 = require("@remix-run/react"), import_react50 = require("react"), import_react_hook_form8 = require("react-hook-form"), import_uuid2 = require("uuid");

// app/components/methods-field-array.tsx
var import_react_hook_form7 = require("react-hook-form");

// app/components/textarea.tsx
var import_react48 = require("react"), import_react_hook_form6 = require("react-hook-form"), import_jsx_dev_runtime45 = require("react/jsx-dev-runtime");
function Textarea({
  methods,
  maxLength,
  name,
  rows,
  placeholder = ""
}) {
  let { register: register2, watch, control } = (0, import_react_hook_form6.useFormContext)(), watchValue = watch(name), textareaMyRef = null, { ref, ...rest } = register2(name);
  return (0, import_react48.useEffect)(() => {
    if (textareaMyRef && window) {
      let computedStyle = window.getComputedStyle(textareaMyRef), borderTop = +computedStyle.getPropertyValue("border-top-width").replace("px", ""), borderBottom = +computedStyle.getPropertyValue("border-bottom-width").replace("px", "");
      textareaMyRef.style.height = textareaMyRef.scrollHeight + borderBottom + borderTop + "px";
    }
  }, [watchValue, textareaMyRef]), /* @__PURE__ */ (0, import_jsx_dev_runtime45.jsxDEV)("div", { className: "relative w-full", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime45.jsxDEV)(
      "textarea",
      {
        ...rest,
        rows,
        className: ` input w-full resize-none align-bottom text-black ${maxLength ? "pb-8" : ""}`,
        maxLength,
        placeholder,
        ref: (e) => {
          ref(e), textareaMyRef = e;
        }
      },
      void 0,
      !1,
      {
        fileName: "app/components/textarea.tsx",
        lineNumber: 118,
        columnNumber: 7
      },
      this
    ),
    maxLength !== void 0 && /* @__PURE__ */ (0, import_jsx_dev_runtime45.jsxDEV)("span", { className: "absolute inline-block right-0 bottom-0 mr-2 mb-2 text-gray-400 text-xs", children: [
      watchValue ? watchValue.length : 0,
      "/",
      maxLength
    ] }, void 0, !0, {
      fileName: "app/components/textarea.tsx",
      lineNumber: 143,
      columnNumber: 9
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/textarea.tsx",
    lineNumber: 116,
    columnNumber: 5
  }, this);
}

// app/components/methods-field-array.tsx
var import_jsx_dev_runtime46 = require("react/jsx-dev-runtime"), regexNum = new RegExp("^[0-9]$"), regexChar = new RegExp("^[a-zA-Z]$"), TimeInput = ({
  name,
  ...methods
}) => {
  let { register: register2, control, watch, setValue } = methods, watchValue = watch(name);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime46.jsxDEV)(
    "input",
    {
      ...register2(name),
      type: "text",
      className: "input w-20 text-right",
      placeholder: "0:00",
      onKeyDown: (e) => {
        watchValue.length === 4 && regexNum.test(e.key) && e.preventDefault(), regexChar.test(e.key) && e.preventDefault();
      },
      onFocus: (e) => {
        setValue(name, e.target.value.replace(":", ""));
      },
      onBlur: (e) => {
        let arr = e.target.value.split("");
        for (; arr.length < 4; )
          arr.unshift("0");
        let length = arr.length;
        arr.splice(length - 2, 0, ":"), setValue(name, arr.join(""));
      }
    },
    void 0,
    !1,
    {
      fileName: "app/components/methods-field-array.tsx",
      lineNumber: 24,
      columnNumber: 5
    },
    this
  );
};
function MethodsFieldArray({
  name
}) {
  let methods = (0, import_react_hook_form7.useFormContext)(), { register: register2, control, setValue } = methods, { fields, append, remove } = (0, import_react_hook_form7.useFieldArray)({
    control,
    name
  });
  return /* @__PURE__ */ (0, import_jsx_dev_runtime46.jsxDEV)("ul", { className: "space-y-4", children: [
    fields.map((field, idx) => /* @__PURE__ */ (0, import_jsx_dev_runtime46.jsxDEV)("div", { children: /* @__PURE__ */ (0, import_jsx_dev_runtime46.jsxDEV)("div", { className: "flex gap-4", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime46.jsxDEV)(TimeInput, { ...methods, name: `${name}.${idx}.timeStemp` }, void 0, !1, {
        fileName: "app/components/methods-field-array.tsx",
        lineNumber: 76,
        columnNumber: 15
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime46.jsxDEV)(
        Textarea,
        {
          ...methods,
          name: `${name}.${idx}.content`,
          rows: 1,
          placeholder: "Method"
        },
        void 0,
        !1,
        {
          fileName: "app/components/methods-field-array.tsx",
          lineNumber: 77,
          columnNumber: 15
        },
        this
      ),
      /* @__PURE__ */ (0, import_jsx_dev_runtime46.jsxDEV)(
        "button",
        {
          type: "button",
          className: "btn-ghost",
          onClick: () => {
            remove(idx);
          },
          disabled: fields.length === 1,
          children: "Delet"
        },
        void 0,
        !1,
        {
          fileName: "app/components/methods-field-array.tsx",
          lineNumber: 83,
          columnNumber: 15
        },
        this
      )
    ] }, void 0, !0, {
      fileName: "app/components/methods-field-array.tsx",
      lineNumber: 75,
      columnNumber: 13
    }, this) }, field.id, !1, {
      fileName: "app/components/methods-field-array.tsx",
      lineNumber: 74,
      columnNumber: 11
    }, this)),
    /* @__PURE__ */ (0, import_jsx_dev_runtime46.jsxDEV)(
      "button",
      {
        className: "btn-sm btn-border",
        type: "button",
        onClick: () => {
          append({ content: "", timeStemp: "" });
        },
        children: "Add a method"
      },
      void 0,
      !1,
      {
        fileName: "app/components/methods-field-array.tsx",
        lineNumber: 97,
        columnNumber: 7
      },
      this
    )
  ] }, void 0, !0, {
    fileName: "app/components/methods-field-array.tsx",
    lineNumber: 71,
    columnNumber: 5
  }, this);
}

// app/components/step-form.tsx
var import_jsx_dev_runtime47 = require("react/jsx-dev-runtime");
function StepForm() {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime47.jsxDEV)(
    "form",
    {
      className: "flex flex-col space-y-12",
      children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime47.jsxDEV)("label", { children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime47.jsxDEV)("p", { className: "label-required", children: "Step Title" }, void 0, !1, {
            fileName: "app/components/step-form.tsx",
            lineNumber: 40,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime47.jsxDEV)(Textarea, { name: "title", maxLength: 100, rows: 2 }, void 0, !1, {
            fileName: "app/components/step-form.tsx",
            lineNumber: 41,
            columnNumber: 9
          }, this)
        ] }, void 0, !0, {
          fileName: "app/components/step-form.tsx",
          lineNumber: 39,
          columnNumber: 7
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime47.jsxDEV)("div", { children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime47.jsxDEV)("p", { className: "label-required", children: "Methods" }, void 0, !1, {
            fileName: "app/components/step-form.tsx",
            lineNumber: 44,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime47.jsxDEV)(MethodsFieldArray, { name: "methods" }, void 0, !1, {
            fileName: "app/components/step-form.tsx",
            lineNumber: 45,
            columnNumber: 9
          }, this)
        ] }, void 0, !0, {
          fileName: "app/components/step-form.tsx",
          lineNumber: 43,
          columnNumber: 7
        }, this)
      ]
    },
    void 0,
    !0,
    {
      fileName: "app/components/step-form.tsx",
      lineNumber: 34,
      columnNumber: 5
    },
    this
  );
}

// app/routes/upload/$stepIdx.tsx
var import_jsx_dev_runtime48 = require("react/jsx-dev-runtime"), defaultValues = {
  title: "",
  methods: [{ content: "", timeStamp: "" }]
};
function StepsPage() {
  let { stepIdx } = (0, import_react49.useParams)(), dispatch = useAppDispatch(), navigate = (0, import_react49.useNavigate)(), localStepForms = useAppSelector((state) => state.stepForm), localStepForm = stepIdx ? localStepForms[+stepIdx - 1] : void 0, methods = (0, import_react_hook_form8.useForm)({
    defaultValues: localStepForm || defaultValues,
    shouldUnregister: !0
  }), { handleSubmit, reset, getValues } = methods;
  (0, import_react50.useEffect)(() => {
    localStepForm && reset(localStepForm);
  }, [dispatch, localStepForm, reset, stepIdx]), (0, import_react50.useEffect)(() => () => {
    let formValue = getValues();
    formValue && localStepForm && dispatch(
      updateStep({
        title: formValue.title,
        methods: formValue.methods,
        id: localStepForm.id
      })
    );
  }, [dispatch, getValues, localStepForm, stepIdx]);
  let onSubmit = (v) => {
    localStepForm && dispatch(
      updateStep({
        title: v.title,
        methods: v.methods,
        id: localStepForm.id
      })
    );
  }, onSubmitAdd = (v) => {
    stepIdx && !localStepForms[+stepIdx] && dispatch(
      addStep({
        title: "",
        methods: [{ timeStamp: "", content: "" }],
        id: (0, import_uuid2.v4)()
      })
    );
  };
  return /* @__PURE__ */ (0, import_jsx_dev_runtime48.jsxDEV)("div", { className: "space-y-12", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime48.jsxDEV)("h3", { className: "font-medium text-primary-600", children: [
      "Step ",
      stepIdx
    ] }, void 0, !0, {
      fileName: "app/routes/upload/$stepIdx.tsx",
      lineNumber: 83,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime48.jsxDEV)(import_react_hook_form8.FormProvider, { ...methods, children: /* @__PURE__ */ (0, import_jsx_dev_runtime48.jsxDEV)(StepForm, {}, void 0, !1, {
      fileName: "app/routes/upload/$stepIdx.tsx",
      lineNumber: 85,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "app/routes/upload/$stepIdx.tsx",
      lineNumber: 84,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime48.jsxDEV)("div", { className: "flex gap-4", children: [
      stepIdx && stepIdx !== "1" ? /* @__PURE__ */ (0, import_jsx_dev_runtime48.jsxDEV)(
        "button",
        {
          className: "btn-sm btn-gray",
          onClick: () => {
            handleSubmit(onSubmit)(), navigate(`../${+stepIdx - 1}`);
          },
          type: "submit",
          children: "Previous"
        },
        void 0,
        !1,
        {
          fileName: "app/routes/upload/$stepIdx.tsx",
          lineNumber: 89,
          columnNumber: 11
        },
        this
      ) : null,
      stepIdx ? /* @__PURE__ */ (0, import_jsx_dev_runtime48.jsxDEV)(
        "button",
        {
          className: "btn-sm btn-primary",
          onClick: () => {
            handleSubmit(onSubmitAdd)(), navigate(`../${+stepIdx + 1}`);
          },
          type: "submit",
          children: "Next step"
        },
        void 0,
        !1,
        {
          fileName: "app/routes/upload/$stepIdx.tsx",
          lineNumber: 102,
          columnNumber: 11
        },
        this
      ) : null
    ] }, void 0, !0, {
      fileName: "app/routes/upload/$stepIdx.tsx",
      lineNumber: 87,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/routes/upload/$stepIdx.tsx",
    lineNumber: 82,
    columnNumber: 5
  }, this);
}

// app/routes/upload/details.tsx
var details_exports = {};
__export(details_exports, {
  default: () => Details
});
var import_react57 = require("@remix-run/react"), import_react58 = require("react"), import_react_hook_form11 = require("react-hook-form"), import_react_select = require("react-select"), import_creatable = __toESM(require("react-select/creatable"));

// app/components/image-input-form/img-upload-input.tsx
var import_react56 = require("react"), import_react_hook_form10 = require("react-hook-form");

// app/components/image-input-form/img-upload.tsx
var import_react53 = require("react"), import_react_hook_form9 = require("react-hook-form");

// app/components/image-input-form/img-canvas.tsx
var import_react51 = require("react"), import_react_konva = __toESM(require_ReactKonva()), import_use_image = __toESM(require("use-image")), import_jsx_dev_runtime49 = require("react/jsx-dev-runtime"), LOCAL_RECT_KEY = "rectAttrs", setRectSizePos = (rect, sizePosObj) => {
  let { x, y, scale, width, height } = sizePosObj;
  rect.setPosition({ x, y }), rect.scale({ x: scale.x, y: scale.y }), rect.setSize({ width, height });
}, checkImgSize = (image, container, pageStage) => {
  let info = { direction: "wider", diffPct: 1, rectDefaultScale: 1 }, minDiff = 1;
  return image.width > container.clientWidth ? minDiff = Math.min(minDiff, container.clientWidth / image.width) : image.width < pageStage.width() && (info.rectDefaultScale = image.width / pageStage.width()), image.height > window.innerHeight * 0.6 ? minDiff = Math.min(minDiff, window.innerHeight * 0.6 / image.height) : image.height < pageStage.height() && (info.rectDefaultScale = image.height / pageStage.height()), info.diffPct = minDiff, info;
}, setImgSize = (image, konvaImg, container) => {
  let ratio = image.width / image.height, minWidth = 1 / 0;
  minWidth = Math.min(
    minWidth,
    container.clientWidth,
    image.width,
    window.innerHeight * 0.6 * ratio
  ), konvaImg.setSize({ width: minWidth, height: minWidth / ratio });
}, ImgCanvas = (0, import_react51.forwardRef)(
  ({ src, width, height, container, pageImgRef, isNewImg, setIsNewImg }, ref) => {
    let stageRef = (0, import_react51.useRef)(null), rectRef = (0, import_react51.useRef)(null), trRef = (0, import_react51.useRef)(null), [image] = (0, import_use_image.default)(src), imageRef = (0, import_react51.useRef)(null), [localValue, setLocalValue] = (0, import_react51.useState)(
      null
    ), setTrAttr = (image2, rect, container2, pageStage) => {
      if (rect && image2 && container2 && pageStage) {
        let rectPos = rect.getPosition(), rectScale = rect.getAbsoluteScale(), imgInfo = checkImgSize(image2, container2, pageStage), localObj = {
          x: rectPos.x,
          y: rectPos.y,
          scale: rectScale,
          width: rect.width(),
          height: rect.height(),
          diffPct: imgInfo.diffPct,
          rectDefaultScale: imgInfo.rectDefaultScale
        };
        setLocalValue(localObj);
      }
    }, getTotalBox = (boxes) => {
      let minX = 1 / 0, minY = 1 / 0, maxX = -1 / 0, maxY = -1 / 0;
      return boxes.forEach((box) => {
        minX = Math.min(minX, box.x), minY = Math.min(minY, box.y), maxX = Math.max(maxX, box.x + box.width), maxY = Math.max(maxY, box.y + box.height);
      }), { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }, onTransformEnd = (e) => {
      let rect = rectRef.current;
      image && rect && container && (pageImgRef == null ? void 0 : pageImgRef.stage) && setTrAttr(image, rect, container, pageImgRef.stage);
    }, boundBoxFunc = (oldBox, newBox) => !stageRef.current || newBox.x < 0 || newBox.y < 0 || newBox.x + newBox.width > stageRef.current.width() || newBox.y + newBox.height > stageRef.current.height() ? oldBox : newBox, onDragMove = () => {
      let tr = trRef.current, stage = stageRef.current;
      if (!tr || !stage)
        return;
      let boxes = tr.nodes().map((node) => node.getClientRect()), box = getTotalBox(boxes);
      tr.nodes().forEach((shape) => {
        let absPos = shape.getAbsolutePosition(), offsetX = box.x - absPos.x, offsetY = box.y - absPos.y, newPos = { ...absPos };
        box.x < 0 && (newPos.x = -offsetX), box.y < 0 && (newPos.y = -offsetY), box.x + box.width > stage.width() && (newPos.x = stage.width() - box.width - offsetX), box.y + box.height > stage.height() && (newPos.y = stage.height() - box.height - offsetY), shape.setAbsolutePosition(newPos);
      });
    }, onDragEnd = () => {
      image && rectRef.current && container && (pageImgRef == null ? void 0 : pageImgRef.stage) && setTrAttr(image, rectRef.current, container, pageImgRef.stage);
    }, onConfirm = () => {
      (pageImgRef == null ? void 0 : pageImgRef.img) && localValue && (pageImgRef.img.setPosition({
        x: localValue.x === 0 ? 0 : -(localValue.x / localValue.diffPct / localValue.scale.x),
        y: localValue.y === 0 ? 0 : -(localValue.y / localValue.diffPct / localValue.scale.y)
      }), pageImgRef.img.scale({
        x: 1 / Math.abs(localValue.scale.x),
        y: 1 / Math.abs(localValue.scale.y)
      }), console.log("change page img and save to localStorage", pageImgRef.img), localStorage.setItem(LOCAL_RECT_KEY, JSON.stringify(localValue)));
    };
    return (0, import_react51.useImperativeHandle)(ref, () => ({
      onConfirm
    })), (0, import_react51.useEffect)(() => {
      image && imageRef.current && container && (setImgSize(image, imageRef.current, container), console.log("set img size"));
    }, [container, image, width, height]), (0, import_react51.useEffect)(() => {
      let img = imageRef.current, stage = stageRef.current;
      img && stage && stage.setSize(img.getSize()), console.log("set image size and stage size");
    }, [width, height, image]), (0, import_react51.useEffect)(() => {
      var _a;
      let rect = rectRef.current, local = localStorage.getItem(LOCAL_RECT_KEY);
      if (!isNewImg && local && rect) {
        let parsed = JSON.parse(local);
        setLocalValue(parsed), setRectSizePos(rect, {
          x: parsed.x,
          y: parsed.y,
          scale: {
            x: parsed.scale.x,
            y: parsed.scale.y
          },
          width: parsed.width,
          height: parsed.height
        });
      }
      if ((isNewImg || !local) && rect && (pageImgRef == null ? void 0 : pageImgRef.stage) && container && image) {
        let imgInfo = checkImgSize(image, container, pageImgRef.stage), sizePosObj = {
          x: 0,
          y: 0,
          scale: {
            x: imgInfo.rectDefaultScale,
            y: imgInfo.rectDefaultScale
          },
          width: pageImgRef.stage.width() * imgInfo.diffPct,
          height: pageImgRef.stage.height() * imgInfo.diffPct,
          diffPct: imgInfo.diffPct,
          rectDefaultScale: imgInfo.rectDefaultScale
        };
        console.log("not found lovalvalue set rect:", sizePosObj), setRectSizePos(rect, sizePosObj), setLocalValue(sizePosObj), isNewImg && setIsNewImg(!1), local && localStorage.removeItem(LOCAL_RECT_KEY);
      }
      let tr = trRef.current;
      tr && rect && (tr.nodes([rect]), (_a = tr.getLayer()) == null || _a.batchDraw());
    }, [container, image, pageImgRef == null ? void 0 : pageImgRef.stage, isNewImg, setIsNewImg]), container ? /* @__PURE__ */ (0, import_jsx_dev_runtime49.jsxDEV)(import_react_konva.Stage, { width, height, ref: stageRef, children: /* @__PURE__ */ (0, import_jsx_dev_runtime49.jsxDEV)(import_react_konva.Layer, { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime49.jsxDEV)(import_react_konva.Image, { image, ref: imageRef }, void 0, !1, {
        fileName: "app/components/image-input-form/img-canvas.tsx",
        lineNumber: 351,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime49.jsxDEV)(
        import_react_konva.Rect,
        {
          x: 0,
          y: 0,
          width,
          height,
          fill: "rgba(0,0,0,0.5)",
          globalCompositeOperation: "multiply"
        },
        void 0,
        !1,
        {
          fileName: "app/components/image-input-form/img-canvas.tsx",
          lineNumber: 352,
          columnNumber: 11
        },
        this
      ),
      /* @__PURE__ */ (0, import_jsx_dev_runtime49.jsxDEV)(
        import_react_konva.Rect,
        {
          x: 0,
          y: 0,
          fill: "white",
          globalCompositeOperation: "overlay",
          draggable: !0,
          ref: rectRef,
          onDragMove,
          onDragEnd
        },
        void 0,
        !1,
        {
          fileName: "app/components/image-input-form/img-canvas.tsx",
          lineNumber: 360,
          columnNumber: 11
        },
        this
      ),
      /* @__PURE__ */ (0, import_jsx_dev_runtime49.jsxDEV)(
        import_react_konva.Transformer,
        {
          onTransformEnd,
          boundBoxFunc,
          ref: trRef,
          rotateEnabled: !1,
          enabledAnchors: [
            "top-left",
            "top-right",
            "bottom-left",
            "bottom-right"
          ]
        },
        void 0,
        !1,
        {
          fileName: "app/components/image-input-form/img-canvas.tsx",
          lineNumber: 370,
          columnNumber: 11
        },
        this
      )
    ] }, void 0, !0, {
      fileName: "app/components/image-input-form/img-canvas.tsx",
      lineNumber: 350,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "app/components/image-input-form/img-canvas.tsx",
      lineNumber: 349,
      columnNumber: 7
    }, this) : /* @__PURE__ */ (0, import_jsx_dev_runtime49.jsxDEV)("div", { children: "NO 'container' found!" }, void 0, !1, {
      fileName: "app/components/image-input-form/img-canvas.tsx",
      lineNumber: 345,
      columnNumber: 14
    }, this);
  }
);
ImgCanvas.displayName = "ImgCanvas";
var img_canvas_default = ImgCanvas;

// app/components/image-input-form/use-resize-observer.ts
var import_react52 = require("react"), useResizeObserver = (ref, callback) => {
  let [width, setWidth] = (0, import_react52.useState)(0), [height, setHeight] = (0, import_react52.useState)(0), onResize = (0, import_react52.useCallback)(
    (entries) => {
      if (!Array.isArray(entries))
        return;
      let entry2 = entries[0];
      setWidth(entry2.contentRect.width), setHeight(entry2.contentRect.height), callback && callback(entry2.contentRect);
    },
    [callback]
  );
  return (0, import_react52.useEffect)(() => {
    if (!ref.current)
      return;
    let resizeObserver = new ResizeObserver((entries) => onResize(entries));
    return resizeObserver.observe(ref.current), () => {
      resizeObserver.disconnect();
    };
  }, [onResize, ref]), [width, height];
};

// app/components/image-input-form/img-upload.tsx
var import_jsx_dev_runtime50 = require("react/jsx-dev-runtime"), getFileSize = (files) => {
  let numberOfBytes = 0;
  for (let file of files)
    numberOfBytes += file.size;
  let units = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"], exponent = Math.min(
    Math.floor(Math.log(numberOfBytes) / Math.log(1024)),
    units.length - 1
  ), approx = numberOfBytes / 1024 ** exponent;
  return { text: exponent === 0 ? numberOfBytes + " bytes" : `${approx.toFixed(3)} ${units[exponent]} (${numberOfBytes} bytes)`, isOverSize: !1 };
};
function ImgUpload({
  name,
  src,
  onClose,
  pageImgRef
}) {
  let { register: register2, setValue, setError } = (0, import_react_hook_form9.useFormContext)(), containerRef = (0, import_react53.useRef)(null), imgCanvasRef = (0, import_react53.useRef)(null), [width, height] = useResizeObserver(containerRef), [isNewImg, setIsNewImg] = (0, import_react53.useState)(!1), onSubmitFile = async (e) => {
    let files = e.target.files;
    if (files) {
      let size = getFileSize(files);
      if (size.isOverSize) {
        setError(name, {
          type: "overSize",
          message: "The size of file is over the limit. Your file size should be under 2MB!"
        });
        return;
      }
      let file = files[0], reader = new FileReader();
      reader.addEventListener(
        "load",
        () => {
          setValue(name, {
            name: file.name,
            type: file.type,
            src: reader.result,
            size: size.text
          });
        },
        !1
      ), reader.readAsDataURL(file);
    }
    setIsNewImg(!0);
  };
  return /* @__PURE__ */ (0, import_jsx_dev_runtime50.jsxDEV)(import_jsx_dev_runtime50.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime50.jsxDEV)(
      "div",
      {
        className: "flex justify-center w-full h-fit max-h-[60vh] overflow-hidden bg-gray-600",
        ref: containerRef,
        children: src.length > 0 ? /* @__PURE__ */ (0, import_jsx_dev_runtime50.jsxDEV)(
          img_canvas_default,
          {
            src,
            width,
            height,
            container: containerRef.current,
            pageImgRef,
            ref: imgCanvasRef,
            isNewImg,
            setIsNewImg
          },
          void 0,
          !1,
          {
            fileName: "app/components/image-input-form/img-upload.tsx",
            lineNumber: 91,
            columnNumber: 11
          },
          this
        ) : /* @__PURE__ */ (0, import_jsx_dev_runtime50.jsxDEV)("div", { className: "flex items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_dev_runtime50.jsxDEV)("p", { className: " p-4 text-gray-500 font-medium text-center", children: "No file yet!" }, void 0, !1, {
          fileName: "app/components/image-input-form/img-upload.tsx",
          lineNumber: 105,
          columnNumber: 13
        }, this) }, void 0, !1, {
          fileName: "app/components/image-input-form/img-upload.tsx",
          lineNumber: 104,
          columnNumber: 11
        }, this)
      },
      void 0,
      !1,
      {
        fileName: "app/components/image-input-form/img-upload.tsx",
        lineNumber: 86,
        columnNumber: 7
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime50.jsxDEV)("div", { className: "flex justify-between my-4 mx-6", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime50.jsxDEV)("label", { className: "btn-border btn-sm cursor-pointer", children: [
        "Choose File",
        /* @__PURE__ */ (0, import_jsx_dev_runtime50.jsxDEV)(
          "input",
          {
            className: "hidden",
            type: "file",
            accept: "image/*",
            onChange: onSubmitFile
          },
          void 0,
          !1,
          {
            fileName: "app/components/image-input-form/img-upload.tsx",
            lineNumber: 114,
            columnNumber: 11
          },
          this
        ),
        /* @__PURE__ */ (0, import_jsx_dev_runtime50.jsxDEV)("input", { ...register2(name, { required: !0 }), type: "hidden" }, void 0, !1, {
          fileName: "app/components/image-input-form/img-upload.tsx",
          lineNumber: 120,
          columnNumber: 11
        }, this)
      ] }, void 0, !0, {
        fileName: "app/components/image-input-form/img-upload.tsx",
        lineNumber: 112,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime50.jsxDEV)("div", { className: "flex space-x-4", children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime50.jsxDEV)(
          "button",
          {
            className: "btn-ghost btn-md",
            onClick: (e) => {
              e.stopPropagation(), onClose();
            },
            children: "Cancel"
          },
          void 0,
          !1,
          {
            fileName: "app/components/image-input-form/img-upload.tsx",
            lineNumber: 123,
            columnNumber: 11
          },
          this
        ),
        /* @__PURE__ */ (0, import_jsx_dev_runtime50.jsxDEV)(
          "button",
          {
            className: "btn-primary btn-md",
            onClick: (e) => {
              var _a;
              e.stopPropagation(), (_a = imgCanvasRef.current) == null || _a.onConfirm(), onClose();
            },
            children: "Comfirm"
          },
          void 0,
          !1,
          {
            fileName: "app/components/image-input-form/img-upload.tsx",
            lineNumber: 132,
            columnNumber: 11
          },
          this
        )
      ] }, void 0, !0, {
        fileName: "app/components/image-input-form/img-upload.tsx",
        lineNumber: 122,
        columnNumber: 9
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/image-input-form/img-upload.tsx",
      lineNumber: 111,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/image-input-form/img-upload.tsx",
    lineNumber: 85,
    columnNumber: 5
  }, this);
}

// app/components/image-input-form/modal.tsx
var import_react54 = require("react"), import_react_dom2 = __toESM(require("react-dom")), import_jsx_dev_runtime51 = require("react/jsx-dev-runtime"), ImgModal = ({
  children,
  open
}) => {
  let [renderChildren, setRenderChildren] = (0, import_react54.useState)(!1), [containerDiv, setContainerDiv] = (0, import_react54.useState)(null);
  return (0, import_react54.useEffect)(() => {
    if (typeof window != "object")
      return;
    let div = document.createElement("div");
    return div.id = "modal-container", open && (document.body.appendChild(div), setContainerDiv(div), setRenderChildren(!0)), () => {
      console.log("removeChild");
      let el = document.getElementById("modal-container");
      el && document.body.removeChild(el);
    };
  }, [open]), !open || typeof window != "object" || !containerDiv ? null : import_react_dom2.default.createPortal(
    /* @__PURE__ */ (0, import_jsx_dev_runtime51.jsxDEV)("div", { className: "fixed flex items-center justify-center left-0 top-0 right-0 bottom-0 bg-gray-600/50", children: /* @__PURE__ */ (0, import_jsx_dev_runtime51.jsxDEV)("div", { className: "overflow-hidden w-1/2 max-h-[75vh] rounded-lg bg-white", children }, void 0, !1, {
      fileName: "app/components/image-input-form/modal.tsx",
      lineNumber: 41,
      columnNumber: 7
    }, this) }, void 0, !1, {
      fileName: "app/components/image-input-form/modal.tsx",
      lineNumber: 40,
      columnNumber: 5
    }, this),
    containerDiv
  );
};

// app/components/image-input-form/page-img.tsx
var import_react55 = require("react"), import_react_konva2 = __toESM(require_ReactKonva()), import_use_image2 = __toESM(require("use-image")), import_jsx_dev_runtime52 = require("react/jsx-dev-runtime"), PageImg = (0, import_react55.forwardRef)(({ src, container }, ref) => {
  let [image] = (0, import_use_image2.default)(src), stageRef = (0, import_react55.useRef)(null), imgRef = (0, import_react55.useRef)(null);
  return (0, import_react55.useEffect)(() => {
    let img = imgRef.current;
    return () => {
      if (img) {
        let imgPos = img.getPosition(), imgScale = img.scale(), newImgScale = imgScale || { x: 1, y: 1 }, imgSize = img.getSize();
      }
    };
  }, []), (0, import_react55.useImperativeHandle)(ref, () => ({
    stage: stageRef.current,
    img: imgRef.current
  })), container ? /* @__PURE__ */ (0, import_jsx_dev_runtime52.jsxDEV)(import_jsx_dev_runtime52.Fragment, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime52.jsxDEV)(
    import_react_konva2.Stage,
    {
      width: container.clientWidth,
      height: container.clientHeight,
      ref: stageRef,
      children: /* @__PURE__ */ (0, import_jsx_dev_runtime52.jsxDEV)(import_react_konva2.Layer, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime52.jsxDEV)(import_react_konva2.Image, { image, ref: imgRef }, void 0, !1, {
        fileName: "app/components/image-input-form/page-img.tsx",
        lineNumber: 52,
        columnNumber: 11
      }, this) }, void 0, !1, {
        fileName: "app/components/image-input-form/page-img.tsx",
        lineNumber: 51,
        columnNumber: 9
      }, this)
    },
    void 0,
    !1,
    {
      fileName: "app/components/image-input-form/page-img.tsx",
      lineNumber: 46,
      columnNumber: 7
    },
    this
  ) }, void 0, !1, {
    fileName: "app/components/image-input-form/page-img.tsx",
    lineNumber: 45,
    columnNumber: 5
  }, this) : null;
});
PageImg.displayName = "PageImg";
var page_img_default = PageImg;

// app/components/image-input-form/img-upload-input.tsx
var import_jsx_dev_runtime53 = require("react/jsx-dev-runtime");
function ImgUploadInput({
  name,
  text
}) {
  var _a;
  let {
    register: register2,
    setValue,
    watch,
    getValues,
    setError,
    formState: { errors }
  } = (0, import_react_hook_form10.useFormContext)(), watchValue = watch(name), [open, setOpen] = (0, import_react56.useState)(!1), pageImgRef = (0, import_react56.useRef)(null), pageStageRef = (0, import_react56.useRef)(null), canvasContainerRef = (0, import_react56.useRef)(null), [width, height] = useResizeObserver(canvasContainerRef);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime53.jsxDEV)("div", { className: "h-full", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime53.jsxDEV)(
      "div",
      {
        className: ` 
          items-center justify-center 
          border rounded-lg 
          hover:border-gray-300 hover:bg-gray-50 
          aspect-w-4 aspect-h-3
          overflow-hidden
          `,
        onClick: (e) => {
          setOpen(!0);
        },
        ref: canvasContainerRef,
        children: [
          watchValue.src.length > 0 ? /* @__PURE__ */ (0, import_jsx_dev_runtime53.jsxDEV)(
            page_img_default,
            {
              src: watchValue.src,
              container: canvasContainerRef.current,
              ref: pageImgRef
            },
            void 0,
            !1,
            {
              fileName: "app/components/image-input-form/img-upload-input.tsx",
              lineNumber: 67,
              columnNumber: 11
            },
            this
          ) : /* @__PURE__ */ (0, import_jsx_dev_runtime53.jsxDEV)("div", { className: "flex items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_dev_runtime53.jsxDEV)("p", { className: " p-4 text-gray-500 font-medium text-center", children: [
            "Click here to upload ",
            text
          ] }, void 0, !0, {
            fileName: "app/components/image-input-form/img-upload-input.tsx",
            lineNumber: 74,
            columnNumber: 13
          }, this) }, void 0, !1, {
            fileName: "app/components/image-input-form/img-upload-input.tsx",
            lineNumber: 73,
            columnNumber: 11
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime53.jsxDEV)(ImgModal, { open, children: /* @__PURE__ */ (0, import_jsx_dev_runtime53.jsxDEV)(
            ImgUpload,
            {
              name,
              src: watchValue.src,
              onClose: () => setOpen(!1),
              pageImgRef: pageImgRef.current
            },
            void 0,
            !1,
            {
              fileName: "app/components/image-input-form/img-upload-input.tsx",
              lineNumber: 81,
              columnNumber: 11
            },
            this
          ) }, void 0, !1, {
            fileName: "app/components/image-input-form/img-upload-input.tsx",
            lineNumber: 80,
            columnNumber: 9
          }, this)
        ]
      },
      void 0,
      !0,
      {
        fileName: "app/components/image-input-form/img-upload-input.tsx",
        lineNumber: 51,
        columnNumber: 7
      },
      this
    ),
    /* @__PURE__ */ (0, import_jsx_dev_runtime53.jsxDEV)("label", { children: "Size:" }, void 0, !1, {
      fileName: "app/components/image-input-form/img-upload-input.tsx",
      lineNumber: 89,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime53.jsxDEV)("output", { id: "fileSize", children: watchValue.size }, void 0, !1, {
      fileName: "app/components/image-input-form/img-upload-input.tsx",
      lineNumber: 90,
      columnNumber: 7
    }, this),
    errors && /* @__PURE__ */ (0, import_jsx_dev_runtime53.jsxDEV)("p", { className: "text-red-500 font-medium", children: (_a = errors[name]) == null ? void 0 : _a.message }, void 0, !1, {
      fileName: "app/components/image-input-form/img-upload-input.tsx",
      lineNumber: 93,
      columnNumber: 9
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/image-input-form/img-upload-input.tsx",
    lineNumber: 50,
    columnNumber: 5
  }, this);
}

// app/routes/upload/details.tsx
var import_jsx_dev_runtime54 = require("react/jsx-dev-runtime"), mockTags = [
  { value: "breakfast", label: "Breakfast" },
  { value: "dinner", label: "Dinner" }
], defaultFormValues = {
  title: "",
  tags: mockTags,
  difficulty: "EASY1",
  thumbnail: { name: "", src: "", type: "", size: "" }
}, ControlComponent = ({
  children,
  ...props
}) => {
  let { isFocused } = props;
  return /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)(
    import_react_select.components.Control,
    {
      ...props,
      className: ` py-0.5 ${isFocused ? "!border-focus-outline !shadow-[0_0_0_1px_black] !shadow-focus-outline " : "border-gray-200"}
      rounded-lg
      `,
      children
    },
    void 0,
    !1,
    {
      fileName: "app/routes/upload/details.tsx",
      lineNumber: 57,
      columnNumber: 5
    },
    this
  );
}, OptionComponent = ({
  children,
  ...props
}) => /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)(
  import_react_select.components.Option,
  {
    ...props,
    className: ` cursor-pointer rounded-lg ${props.isFocused ? "text-primary-600 bg-primary-600/10" : ""} `,
    children
  },
  void 0,
  !1,
  {
    fileName: "app/routes/upload/details.tsx",
    lineNumber: 77,
    columnNumber: 5
  },
  this
), MenuComponent = ({
  children,
  ...props
}) => /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)(import_react_select.components.Menu, { ...props, className: "rounded-lg shadow-lg", children }, void 0, !1, {
  fileName: "app/routes/upload/details.tsx",
  lineNumber: 93,
  columnNumber: 5
}, this), MenuListComponent = ({
  children,
  ...props
}) => /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)(import_react_select.components.MenuList, { ...props, className: "p-2", children }, void 0, !1, {
  fileName: "app/routes/upload/details.tsx",
  lineNumber: 104,
  columnNumber: 5
}, this);
function Details() {
  let localDetails = useAppSelector((state) => state.detailsForm), dispatch = useAppDispatch(), methods = (0, import_react_hook_form11.useForm)({
    defaultValues: defaultFormValues
  }), { getValues } = methods;
  return (0, import_react58.useEffect)(() => {
    if (localDetails) {
      let { title, difficulty, tags, thumbnail } = localDetails;
      methods.reset({
        title,
        difficulty,
        tags: tags.map((v) => ({
          value: v,
          label: v.charAt(0).toLocaleUpperCase() + v.slice(1)
        })),
        thumbnail
      });
    }
  }, [localDetails, methods]), (0, import_react58.useEffect)(() => () => {
    let value = getValues();
    value && dispatch(
      updateDetails({
        title: value.title,
        difficulty: value.difficulty,
        tags: value.tags.map((v) => v.value),
        thumbnail: value.thumbnail
      })
    );
  }, [dispatch, getValues]), /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)("div", { className: "space-y-12 ", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)("h3", { className: "font-medium text-black", children: "Details" }, void 0, !1, {
      fileName: "app/routes/upload/details.tsx",
      lineNumber: 165,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)(import_react_hook_form11.FormProvider, { ...methods, children: /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)("form", { className: "flex gap-6", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)("div", { className: "flex flex-1 flex-col space-y-12", children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)("label", { children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)("p", { className: "label-required", children: "Tilte" }, void 0, !1, {
            fileName: "app/routes/upload/details.tsx",
            lineNumber: 170,
            columnNumber: 15
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)(Textarea, { name: "title", maxLength: 100, rows: 2 }, void 0, !1, {
            fileName: "app/routes/upload/details.tsx",
            lineNumber: 171,
            columnNumber: 15
          }, this)
        ] }, void 0, !0, {
          fileName: "app/routes/upload/details.tsx",
          lineNumber: 169,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)("label", { children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)("p", { className: "label-required", children: "Tags" }, void 0, !1, {
            fileName: "app/routes/upload/details.tsx",
            lineNumber: 174,
            columnNumber: 15
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)(
            import_react_hook_form11.Controller,
            {
              name: "tags",
              control: methods.control,
              render: ({ field: { name, value } }) => /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)(
                import_creatable.default,
                {
                  id: name,
                  isClearable: !0,
                  isMulti: !0,
                  options: mockTags,
                  className: "",
                  components: {
                    ClearIndicator: void 0,
                    Control: ControlComponent,
                    Option: OptionComponent,
                    Menu: MenuComponent,
                    MenuList: MenuListComponent
                  }
                },
                void 0,
                !1,
                {
                  fileName: "app/routes/upload/details.tsx",
                  lineNumber: 179,
                  columnNumber: 19
                },
                this
              )
            },
            void 0,
            !1,
            {
              fileName: "app/routes/upload/details.tsx",
              lineNumber: 175,
              columnNumber: 15
            },
            this
          )
        ] }, void 0, !0, {
          fileName: "app/routes/upload/details.tsx",
          lineNumber: 173,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)("label", { children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)("p", { className: "label-required", children: "Difficulty" }, void 0, !1, {
            fileName: "app/routes/upload/details.tsx",
            lineNumber: 197,
            columnNumber: 15
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)("div", { className: "flex items-center", children: /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)(DifficultyBtn, { isInput: !0, difficulty: "EASY1" }, void 0, !1, {
            fileName: "app/routes/upload/details.tsx",
            lineNumber: 199,
            columnNumber: 17
          }, this) }, void 0, !1, {
            fileName: "app/routes/upload/details.tsx",
            lineNumber: 198,
            columnNumber: 15
          }, this)
        ] }, void 0, !0, {
          fileName: "app/routes/upload/details.tsx",
          lineNumber: 196,
          columnNumber: 13
        }, this)
      ] }, void 0, !0, {
        fileName: "app/routes/upload/details.tsx",
        lineNumber: 168,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)("div", { className: "w-2/5 justify-self-stretch", children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)("label", { className: "label-required", children: "Thumbnail" }, void 0, !1, {
          fileName: "app/routes/upload/details.tsx",
          lineNumber: 204,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)(ImgUploadInput, { name: "thumbnail", text: "Thumbnail" }, void 0, !1, {
          fileName: "app/routes/upload/details.tsx",
          lineNumber: 205,
          columnNumber: 13
        }, this)
      ] }, void 0, !0, {
        fileName: "app/routes/upload/details.tsx",
        lineNumber: 203,
        columnNumber: 11
      }, this)
    ] }, void 0, !0, {
      fileName: "app/routes/upload/details.tsx",
      lineNumber: 167,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "app/routes/upload/details.tsx",
      lineNumber: 166,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime54.jsxDEV)(import_react57.Link, { to: "../ingredients", className: "btn-sm btn-primary w-fit", children: "Next" }, void 0, !1, {
      fileName: "app/routes/upload/details.tsx",
      lineNumber: 209,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/routes/upload/details.tsx",
    lineNumber: 164,
    columnNumber: 5
  }, this);
}

// app/routes/index.tsx
var routes_exports = {};
__export(routes_exports, {
  default: () => Index2,
  loader: () => loader11
});
var import_node15 = require("@remix-run/node"), import_react59 = require("@remix-run/react"), import_react60 = require("react");
var import_jsx_dev_runtime55 = require("react/jsx-dev-runtime"), loader11 = async ({ request }) => {
  let searchRes = await searchAllRecipes(request), userId = await getUserId(request), allRecipe = await getAllRecipes();
  if (!userId)
    return (0, import_node15.json)({ searchRes, allRecipe });
  let allRecipeWithLiked = await getLikedAndBasket({
    userId,
    recipes: allRecipe
  });
  return (0, import_node15.json)({ searchRes, allRecipe: allRecipeWithLiked });
};
function Index2() {
  var _a;
  let data = (0, import_react59.useLoaderData)(), fetcher = (0, import_react59.useFetcher)(), [resList, setResList] = (0, import_react60.useState)([]);
  return (0, import_react60.useEffect)(() => {
    var _a2;
    (_a2 = fetcher.data) != null && _a2.searcheRes && setResList(fetcher.data.searcheRes);
  }, [(_a = fetcher.data) == null ? void 0 : _a.searcheRes]), /* @__PURE__ */ (0, import_jsx_dev_runtime55.jsxDEV)("div", { className: "layout-pt layout-px flex flex-col gap-9", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime55.jsxDEV)("div", { className: "flex justify-center gap-6", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime55.jsxDEV)(
        SearchBar,
        {
          list: resList == null ? void 0 : resList.map((item) => ({ value: item.title, id: item.id })),
          fetch: (inputValue) => {
            fetcher.load(`/?index&search=${inputValue}`);
          }
        },
        void 0,
        !1,
        {
          fileName: "app/routes/index.tsx",
          lineNumber: 47,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ (0, import_jsx_dev_runtime55.jsxDEV)(
        DropdownMenu,
        {
          summary: "New",
          details: /* @__PURE__ */ (0, import_jsx_dev_runtime55.jsxDEV)("span", { children: "Popular" }, void 0, !1, {
            fileName: "app/routes/index.tsx",
            lineNumber: 55,
            columnNumber: 20
          }, this),
          hasDownArrow: !0
        },
        void 0,
        !1,
        {
          fileName: "app/routes/index.tsx",
          lineNumber: 53,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ (0, import_jsx_dev_runtime55.jsxDEV)(
        DropdownMenu,
        {
          summary: "Filter",
          details: /* @__PURE__ */ (0, import_jsx_dev_runtime55.jsxDEV)("div", { children: "filter checkbox" }, void 0, !1, {
            fileName: "app/routes/index.tsx",
            lineNumber: 60,
            columnNumber: 20
          }, this),
          icon: /* @__PURE__ */ (0, import_jsx_dev_runtime55.jsxDEV)("span", { className: "material-symbols-rounded", children: "tune" }, void 0, !1, {
            fileName: "app/routes/index.tsx",
            lineNumber: 61,
            columnNumber: 17
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "app/routes/index.tsx",
          lineNumber: 58,
          columnNumber: 9
        },
        this
      )
    ] }, void 0, !0, {
      fileName: "app/routes/index.tsx",
      lineNumber: 46,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime55.jsxDEV)(CardGrid, { data: data.allRecipe }, void 0, !1, {
      fileName: "app/routes/index.tsx",
      lineNumber: 65,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/routes/index.tsx",
    lineNumber: 45,
    columnNumber: 5
  }, this);
}

// app/routes/login.tsx
var login_exports = {};
__export(login_exports, {
  action: () => action7,
  default: () => Login,
  meta: () => meta4
});
var import_node16 = require("@remix-run/node"), import_react61 = require("@remix-run/react"), import_react62 = require("react"), import_react_hook_form12 = require("react-hook-form");
var import_jsx_dev_runtime56 = require("react/jsx-dev-runtime"), meta4 = () => ({
  title: "Login" + metaTitlePostfix
});
function validateUrl(url, host) {
  return console.log(url), url.includes(host) ? url : "/";
}
function validateFormType(formType) {
  return typeof formType == "string" && ["login", "register"].includes(formType);
}
var badRequest2 = (data) => (0, import_node16.json)(data, { status: 400 }), action7 = async ({ request }) => {
  let url = new URL(request.url), form = await request.formData(), email = form.get("email"), password = form.get("password"), redirectTo = validateUrl(form.get("redirectTo") || "/", url.host), formType = form.get("formType");
  if (typeof email != "string" || typeof password != "string" || typeof redirectTo != "string" || !validateFormType(formType))
    return badRequest2({ formError: "Form not submitted correctly" });
  let fields = { formType, email, password };
  switch (formType) {
    case "login": {
      let user = await login({ email, password });
      return console.log({ user }), user ? (console.log(redirectTo), createUserSession(user.id, redirectTo)) : badRequest2({
        fields,
        formError: "Email of Password combination is incorrect"
      });
    }
    case "register": {
      if (await db.user.findFirst({
        where: { email }
      }))
        return badRequest2({ fields, formError: "User already exists" });
      let user = await register({ email, password });
      return user ? createUserSession(user.id, redirectTo) : badRequest2({
        fields,
        formError: "Somethig went wrong trying to create a new user"
      });
    }
    default:
      return badRequest2({ fields, formError: "FormType invalid" });
  }
};
function Login() {
  let [formType, setFormType] = (0, import_react62.useState)("login"), [searchParams] = (0, import_react61.useSearchParams)(), submit = (0, import_react61.useSubmit)(), {
    register: register2,
    watch,
    handleSubmit,
    formState: { errors, isDirty }
  } = (0, import_react_hook_form12.useForm)({
    defaultValues: {
      email: "",
      password: "",
      redirectTo: "",
      formType: "login"
    }
  }), [watchEmail, watchPsw] = watch(["email", "password"]);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime56.jsxDEV)("div", { className: "mx-auto layout-px layout-pb pt-32 max-w-6xl flex justify-center", children: /* @__PURE__ */ (0, import_jsx_dev_runtime56.jsxDEV)("div", { className: "flex flex-col w-96 bg-white p-8 rounded-xl shadow-2xl shadow-gray-300/50 space-y-6", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime56.jsxDEV)("h1", { children: [
      " ",
      formType === "login" ? "Login" : "Create account"
    ] }, void 0, !0, {
      fileName: "app/routes/login.tsx",
      lineNumber: 128,
      columnNumber: 9
    }, this),
    formType === "register" ? /* @__PURE__ */ (0, import_jsx_dev_runtime56.jsxDEV)("div", { className: "flex space-x-2 p-4 rounded-lg bg-primary/10", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime56.jsxDEV)("span", { className: "material-symbols-rounded text-primary", children: "priority_high" }, void 0, !1, {
        fileName: "app/routes/login.tsx",
        lineNumber: 131,
        columnNumber: 13
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime56.jsxDEV)("p", { children: "Please do not input any sensitive personal informations, since this is a demo website which does not protect your datas and would delete the datas in 7 days." }, void 0, !1, {
        fileName: "app/routes/login.tsx",
        lineNumber: 134,
        columnNumber: 13
      }, this)
    ] }, void 0, !0, {
      fileName: "app/routes/login.tsx",
      lineNumber: 130,
      columnNumber: 11
    }, this) : null,
    /* @__PURE__ */ (0, import_jsx_dev_runtime56.jsxDEV)(
      "form",
      {
        method: "post",
        className: "flex flex-col gap-y-6",
        onSubmit: handleSubmit((v, e) => {
          console.log(v, e), submit(e.target);
        }),
        children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime56.jsxDEV)("input", { ...register2("formType"), type: "hidden", value: formType }, void 0, !1, {
            fileName: "app/routes/login.tsx",
            lineNumber: 146,
            columnNumber: 11
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime56.jsxDEV)(
            "input",
            {
              ...register2("redirectTo"),
              type: "hidden",
              value: searchParams.get("redirectTo") ?? void 0
            },
            void 0,
            !1,
            {
              fileName: "app/routes/login.tsx",
              lineNumber: 147,
              columnNumber: 11
            },
            this
          ),
          /* @__PURE__ */ (0, import_jsx_dev_runtime56.jsxDEV)(
            "label",
            {
              className: `
            relative 
            before:block 
            before:content-['Email'] 
            before:absolute 
            before:top-2
            before:left-2 
            before:origin-top-left
            before:px-1
            before:bg-white 
            before:text-gray-400
            ${watchEmail.length > 0 ? "before:-top-2 before:text-gray-500 before:scale-75" : ""}
            focus-within:before:-top-2
            focus-within:before:text-black
            focus-within:before:scale-75
            before:transition-all
            before:cursor-text
            `,
              children: /* @__PURE__ */ (0, import_jsx_dev_runtime56.jsxDEV)(
                "input",
                {
                  ...register2("email", {
                    required: !0
                  }),
                  type: "email",
                  className: "input w-full",
                  autoComplete: "email"
                },
                void 0,
                !1,
                {
                  fileName: "app/routes/login.tsx",
                  lineNumber: 176,
                  columnNumber: 13
                },
                this
              )
            },
            void 0,
            !1,
            {
              fileName: "app/routes/login.tsx",
              lineNumber: 152,
              columnNumber: 11
            },
            this
          ),
          /* @__PURE__ */ (0, import_jsx_dev_runtime56.jsxDEV)(
            "label",
            {
              className: `
            relative 
            before:block 
            before:content-['Password'] 
            before:absolute 
            before:top-2
            before:left-2 
            before:origin-top-left
            before:px-1
            before:bg-white 
            before:text-gray-400
            ${watchPsw.length > 0 ? "before:-top-2 before:text-gray-500 before:scale-75" : ""}
            focus-within:before:-top-2
            focus-within:before:text-black
            focus-within:before:scale-75
            before:transition-all
            before:cursor-text
            `,
              children: [
                /* @__PURE__ */ (0, import_jsx_dev_runtime56.jsxDEV)(
                  "input",
                  {
                    ...register2("password", {
                      required: !0
                    }),
                    type: "password",
                    className: "input w-full",
                    autoComplete: "current-password"
                  },
                  void 0,
                  !1,
                  {
                    fileName: "app/routes/login.tsx",
                    lineNumber: 209,
                    columnNumber: 13
                  },
                  this
                ),
                /* @__PURE__ */ (0, import_jsx_dev_runtime56.jsxDEV)(
                  "span",
                  {
                    className: `text-xs ${errors.password ? "text-red-500" : "text-gray-500"} `,
                    children: "Should include charactor and number and begin with charactor in 8-32 long"
                  },
                  void 0,
                  !1,
                  {
                    fileName: "app/routes/login.tsx",
                    lineNumber: 220,
                    columnNumber: 13
                  },
                  this
                )
              ]
            },
            void 0,
            !0,
            {
              fileName: "app/routes/login.tsx",
              lineNumber: 185,
              columnNumber: 11
            },
            this
          ),
          /* @__PURE__ */ (0, import_jsx_dev_runtime56.jsxDEV)("div", { children: /* @__PURE__ */ (0, import_jsx_dev_runtime56.jsxDEV)(
            "button",
            {
              type: "submit",
              className: "btn-primary btn-md w-full",
              disabled: !isDirty,
              children: "Submit"
            },
            void 0,
            !1,
            {
              fileName: "app/routes/login.tsx",
              lineNumber: 230,
              columnNumber: 13
            },
            this
          ) }, void 0, !1, {
            fileName: "app/routes/login.tsx",
            lineNumber: 229,
            columnNumber: 11
          }, this)
        ]
      },
      void 0,
      !0,
      {
        fileName: "app/routes/login.tsx",
        lineNumber: 141,
        columnNumber: 9
      },
      this
    ),
    formType === "login" ? /* @__PURE__ */ (0, import_jsx_dev_runtime56.jsxDEV)("button", { className: "link", onClick: () => setFormType("register"), children: "Create new account" }, void 0, !1, {
      fileName: "app/routes/login.tsx",
      lineNumber: 240,
      columnNumber: 11
    }, this) : /* @__PURE__ */ (0, import_jsx_dev_runtime56.jsxDEV)("button", { className: "link", onClick: () => setFormType("login"), children: "Login" }, void 0, !1, {
      fileName: "app/routes/login.tsx",
      lineNumber: 244,
      columnNumber: 11
    }, this)
  ] }, void 0, !0, {
    fileName: "app/routes/login.tsx",
    lineNumber: 127,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "app/routes/login.tsx",
    lineNumber: 126,
    columnNumber: 5
  }, this);
}

// server-assets-manifest:@remix-run/dev/assets-manifest
var assets_manifest_default = { version: "fb01e175", entry: { module: "/build/entry.client-QPAIZSM6.js", imports: ["/build/_shared/chunk-2V4E7QDU.js", "/build/_shared/chunk-UAIS7CJ2.js", "/build/_shared/chunk-CUPSZOF3.js"] }, routes: { root: { id: "root", parentId: void 0, path: "", index: void 0, caseSensitive: void 0, module: "/build/root-HK54PA2I.js", imports: ["/build/_shared/chunk-VCITOLEB.js", "/build/_shared/chunk-A76BYB4T.js", "/build/_shared/chunk-PC7DKCCK.js", "/build/_shared/chunk-PDABV4SV.js", "/build/_shared/chunk-7RAIFTL2.js", "/build/_shared/chunk-UN6WIT2S.js", "/build/_shared/chunk-AZO6JVLN.js", "/build/_shared/chunk-SH4AKRQ3.js"], hasAction: !0, hasLoader: !0, hasCatchBoundary: !1, hasErrorBoundary: !0 }, "routes/add-basket.$recipeId": { id: "routes/add-basket.$recipeId", parentId: "root", path: "add-basket/:recipeId", index: void 0, caseSensitive: void 0, module: "/build/routes/add-basket.$recipeId-B27PPFBP.js", imports: void 0, hasAction: !0, hasLoader: !1, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/basket": { id: "routes/basket", parentId: "root", path: "basket", index: void 0, caseSensitive: void 0, module: "/build/routes/basket-NYY2RGJP.js", imports: ["/build/_shared/chunk-OOPRYBMH.js", "/build/_shared/chunk-LFDIS6R5.js", "/build/_shared/chunk-MLCWLZAX.js"], hasAction: !1, hasLoader: !0, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/basket-panel/basket-panel": { id: "routes/basket-panel/basket-panel", parentId: "root", path: "basket-panel/basket-panel", index: void 0, caseSensitive: void 0, module: "/build/routes/basket-panel/basket-panel-B6JBNWWT.js", imports: void 0, hasAction: !0, hasLoader: !0, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/basket/index": { id: "routes/basket/index", parentId: "routes/basket", path: void 0, index: !0, caseSensitive: void 0, module: "/build/routes/basket/index-RCPLQYGL.js", imports: ["/build/_shared/chunk-A76BYB4T.js", "/build/_shared/chunk-PDABV4SV.js", "/build/_shared/chunk-7RAIFTL2.js", "/build/_shared/chunk-BC24VAOR.js", "/build/_shared/chunk-SH4AKRQ3.js"], hasAction: !0, hasLoader: !0, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/favorite": { id: "routes/favorite", parentId: "root", path: "favorite", index: void 0, caseSensitive: void 0, module: "/build/routes/favorite-FWGIW6VZ.js", imports: ["/build/_shared/chunk-OOPRYBMH.js", "/build/_shared/chunk-4UVX32CE.js", "/build/_shared/chunk-JAMTYS77.js", "/build/_shared/chunk-BC24VAOR.js"], hasAction: !1, hasLoader: !0, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/index": { id: "routes/index", parentId: "root", path: void 0, index: !0, caseSensitive: void 0, module: "/build/routes/index-BEK6RADI.js", imports: ["/build/_shared/chunk-OOPRYBMH.js", "/build/_shared/chunk-JAMTYS77.js", "/build/_shared/chunk-BC24VAOR.js"], hasAction: !1, hasLoader: !0, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/login": { id: "routes/login", parentId: "root", path: "login", index: void 0, caseSensitive: void 0, module: "/build/routes/login-NQOTJVAK.js", imports: ["/build/_shared/chunk-OOPRYBMH.js", "/build/_shared/chunk-LFDIS6R5.js"], hasAction: !0, hasLoader: !1, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/logout": { id: "routes/logout", parentId: "root", path: "logout", index: void 0, caseSensitive: void 0, module: "/build/routes/logout-QCIOKXNT.js", imports: void 0, hasAction: !0, hasLoader: !0, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/my-recipes": { id: "routes/my-recipes", parentId: "root", path: "my-recipes", index: void 0, caseSensitive: void 0, module: "/build/routes/my-recipes-3BDAV7RB.js", imports: ["/build/_shared/chunk-4UVX32CE.js", "/build/_shared/chunk-JAMTYS77.js", "/build/_shared/chunk-BC24VAOR.js"], hasAction: !1, hasLoader: !0, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/recipe.$recipeId": { id: "routes/recipe.$recipeId", parentId: "root", path: "recipe/:recipeId", index: void 0, caseSensitive: void 0, module: "/build/routes/recipe.$recipeId-C3X7HSM4.js", imports: ["/build/_shared/chunk-LFDIS6R5.js", "/build/_shared/chunk-MLCWLZAX.js", "/build/_shared/chunk-M42BSJR2.js"], hasAction: !1, hasLoader: !0, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/recipe.$recipeId.modal": { id: "routes/recipe.$recipeId.modal", parentId: "root", path: "recipe/:recipeId/modal", index: void 0, caseSensitive: void 0, module: "/build/routes/recipe.$recipeId.modal-6J756PTX.js", imports: void 0, hasAction: !1, hasLoader: !0, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/recipe.like.$recipeId": { id: "routes/recipe.like.$recipeId", parentId: "root", path: "recipe/like/:recipeId", index: void 0, caseSensitive: void 0, module: "/build/routes/recipe.like.$recipeId-XSEN5HM7.js", imports: void 0, hasAction: !0, hasLoader: !1, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/upload": { id: "routes/upload", parentId: "root", path: "upload", index: void 0, caseSensitive: void 0, module: "/build/routes/upload-ARVFQBDM.js", imports: ["/build/_shared/chunk-OOPRYBMH.js", "/build/_shared/chunk-OXVWDGG7.js", "/build/_shared/chunk-MLCWLZAX.js"], hasAction: !1, hasLoader: !0, hasCatchBoundary: !1, hasErrorBoundary: !0 }, "routes/upload/$stepIdx": { id: "routes/upload/$stepIdx", parentId: "routes/upload", path: ":stepIdx", index: void 0, caseSensitive: void 0, module: "/build/routes/upload/$stepIdx-C334SANH.js", imports: ["/build/_shared/chunk-4JP7P7OL.js", "/build/_shared/chunk-PDABV4SV.js", "/build/_shared/chunk-7RAIFTL2.js"], hasAction: !1, hasLoader: !1, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/upload/details": { id: "routes/upload/details", parentId: "routes/upload", path: "details", index: void 0, caseSensitive: void 0, module: "/build/routes/upload/details-G4Q5OD5R.js", imports: ["/build/_shared/chunk-4JP7P7OL.js", "/build/_shared/chunk-M42BSJR2.js", "/build/_shared/chunk-PDABV4SV.js", "/build/_shared/chunk-7RAIFTL2.js"], hasAction: !1, hasLoader: !1, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/upload/ingredients": { id: "routes/upload/ingredients", parentId: "routes/upload", path: "ingredients", index: void 0, caseSensitive: void 0, module: "/build/routes/upload/ingredients-JZH7OKXF.js", imports: ["/build/_shared/chunk-7RAIFTL2.js"], hasAction: !1, hasLoader: !1, hasCatchBoundary: !1, hasErrorBoundary: !1 } }, url: "/build/manifest-FB01E175.js" };

// server-entry-module:@remix-run/dev/server-build
var assetsBuildDirectory = "public/build", future = { v2_meta: !1 }, publicPath = "/build/", entry = { module: entry_server_exports }, routes = {
  root: {
    id: "root",
    parentId: void 0,
    path: "",
    index: void 0,
    caseSensitive: void 0,
    module: root_exports
  },
  "routes/basket-panel/basket-panel": {
    id: "routes/basket-panel/basket-panel",
    parentId: "root",
    path: "basket-panel/basket-panel",
    index: void 0,
    caseSensitive: void 0,
    module: basket_panel_exports
  },
  "routes/recipe.$recipeId.modal": {
    id: "routes/recipe.$recipeId.modal",
    parentId: "root",
    path: "recipe/:recipeId/modal",
    index: void 0,
    caseSensitive: void 0,
    module: recipe_recipeId_modal_exports
  },
  "routes/recipe.like.$recipeId": {
    id: "routes/recipe.like.$recipeId",
    parentId: "root",
    path: "recipe/like/:recipeId",
    index: void 0,
    caseSensitive: void 0,
    module: recipe_like_recipeId_exports
  },
  "routes/add-basket.$recipeId": {
    id: "routes/add-basket.$recipeId",
    parentId: "root",
    path: "add-basket/:recipeId",
    index: void 0,
    caseSensitive: void 0,
    module: add_basket_recipeId_exports
  },
  "routes/recipe.$recipeId": {
    id: "routes/recipe.$recipeId",
    parentId: "root",
    path: "recipe/:recipeId",
    index: void 0,
    caseSensitive: void 0,
    module: recipe_recipeId_exports
  },
  "routes/my-recipes": {
    id: "routes/my-recipes",
    parentId: "root",
    path: "my-recipes",
    index: void 0,
    caseSensitive: void 0,
    module: my_recipes_exports
  },
  "routes/favorite": {
    id: "routes/favorite",
    parentId: "root",
    path: "favorite",
    index: void 0,
    caseSensitive: void 0,
    module: favorite_exports
  },
  "routes/basket": {
    id: "routes/basket",
    parentId: "root",
    path: "basket",
    index: void 0,
    caseSensitive: void 0,
    module: basket_exports
  },
  "routes/basket/index": {
    id: "routes/basket/index",
    parentId: "routes/basket",
    path: void 0,
    index: !0,
    caseSensitive: void 0,
    module: basket_exports2
  },
  "routes/logout": {
    id: "routes/logout",
    parentId: "root",
    path: "logout",
    index: void 0,
    caseSensitive: void 0,
    module: logout_exports
  },
  "routes/upload": {
    id: "routes/upload",
    parentId: "root",
    path: "upload",
    index: void 0,
    caseSensitive: void 0,
    module: upload_exports
  },
  "routes/upload/ingredients": {
    id: "routes/upload/ingredients",
    parentId: "routes/upload",
    path: "ingredients",
    index: void 0,
    caseSensitive: void 0,
    module: ingredients_exports
  },
  "routes/upload/$stepIdx": {
    id: "routes/upload/$stepIdx",
    parentId: "routes/upload",
    path: ":stepIdx",
    index: void 0,
    caseSensitive: void 0,
    module: stepIdx_exports
  },
  "routes/upload/details": {
    id: "routes/upload/details",
    parentId: "routes/upload",
    path: "details",
    index: void 0,
    caseSensitive: void 0,
    module: details_exports
  },
  "routes/index": {
    id: "routes/index",
    parentId: "root",
    path: void 0,
    index: !0,
    caseSensitive: void 0,
    module: routes_exports
  },
  "routes/login": {
    id: "routes/login",
    parentId: "root",
    path: "login",
    index: void 0,
    caseSensitive: void 0,
    module: login_exports
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  assets,
  assetsBuildDirectory,
  entry,
  future,
  publicPath,
  routes
});
//# sourceMappingURL=index.js.map
